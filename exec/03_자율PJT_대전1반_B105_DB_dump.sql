-- we don't know how to generate root <with-no-name> (class Root) :(
create sequence hibernate_sequence;

alter sequence hibernate_sequence owner to b105;

-- Unknown how to generate base type type

comment on type pg_catalog.bool is 'boolean, ''true''/''false''';

alter type pg_catalog.bool owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.bytea is 'variable-length string, binary values escaped';

alter type pg_catalog.bytea owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.char is 'single character';

alter type pg_catalog.char owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.name is '63-byte type for storing system identifiers';

alter type pg_catalog.name owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.int8 is '~18 digit integer, 8-byte storage';

alter type pg_catalog.int8 owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.int2 is '-32 thousand to 32 thousand, 2-byte storage';

alter type pg_catalog.int2 owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.int4 is '-2 billion to 2 billion integer, 4-byte storage';

alter type pg_catalog.int4 owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regproc is 'registered procedure';

alter type pg_catalog.regproc owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.text is 'variable-length string, no limit specified';

alter type pg_catalog.text owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.oid is 'object identifier(oid), maximum 4 billion';

alter type pg_catalog.oid owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.tid is '(block, offset), physical location of tuple';

alter type pg_catalog.tid owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.xid is 'transaction id';

alter type pg_catalog.xid owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.cid is 'command identifier type, sequence in transaction id';

alter type pg_catalog.cid owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.json is 'JSON stored as text';

alter type pg_catalog.json owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.xml is 'XML content';

alter type pg_catalog.xml owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.pg_node_tree is 'string representing an internal node tree';

alter type pg_catalog.pg_node_tree owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.point is 'geometric point ''(x, y)''';

alter type pg_catalog.point owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.lseg is 'geometric line segment ''(pt1,pt2)''';

alter type pg_catalog.lseg owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.path is 'geometric path ''(pt1,...)''';

alter type pg_catalog.path owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.box is 'geometric box ''(lower left,upper right)''';

alter type pg_catalog.box owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.polygon is 'geometric polygon ''(pt1,...)''';

alter type pg_catalog.polygon owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.line is 'geometric line';

alter type pg_catalog.line owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.cidr is 'network IP address/netmask, network address';

alter type pg_catalog.cidr owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.float4 is 'single-precision floating point number, 4-byte storage';

alter type pg_catalog.float4 owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.float8 is 'double-precision floating point number, 8-byte storage';

alter type pg_catalog.float8 owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.circle is 'geometric circle ''(center,radius)''';

alter type pg_catalog.circle owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.macaddr8 is 'XX:XX:XX:XX:XX:XX:XX:XX, MAC address';

alter type pg_catalog.macaddr8 owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.money is 'monetary amounts, $d,ddd.cc';

alter type pg_catalog.money owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.macaddr is 'XX:XX:XX:XX:XX:XX, MAC address';

alter type pg_catalog.macaddr owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.inet is 'IP address/netmask, host address, netmask optional';

alter type pg_catalog.inet owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.aclitem is 'access control list';

alter type pg_catalog.aclitem owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.bpchar is 'char(length), blank-padded string, fixed storage length';

alter type pg_catalog.bpchar owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.varchar is 'varchar(length), non-blank-padded string, variable storage length';

alter type pg_catalog.varchar owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.date is 'date';

alter type pg_catalog.date owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.time is 'time of day';

alter type pg_catalog.time owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.timestamp is 'date and time';

alter type pg_catalog.timestamp owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.timestamptz is 'date and time with time zone';

alter type pg_catalog.timestamptz owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.interval is '@ <number> <units>, time interval';

alter type pg_catalog.interval owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.timetz is 'time of day with time zone';

alter type pg_catalog.timetz owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.bit is 'fixed-length bit string';

alter type pg_catalog.bit owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.varbit is 'variable-length bit string';

alter type pg_catalog.varbit owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.numeric is 'numeric(precision, decimal), arbitrary precision number';

alter type pg_catalog.numeric owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.refcursor is 'reference to cursor (portal name)';

alter type pg_catalog.refcursor owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regprocedure is 'registered procedure (with args)';

alter type pg_catalog.regprocedure owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regoper is 'registered operator';

alter type pg_catalog.regoper owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regoperator is 'registered operator (with args)';

alter type pg_catalog.regoperator owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regclass is 'registered class';

alter type pg_catalog.regclass owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regtype is 'registered type';

alter type pg_catalog.regtype owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.uuid is 'UUID datatype';

alter type pg_catalog.uuid owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.txid_snapshot is 'txid snapshot';

alter type pg_catalog.txid_snapshot owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.pg_lsn is 'PostgreSQL LSN datatype';

alter type pg_catalog.pg_lsn owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.pg_ndistinct is 'multivariate ndistinct coefficients';

alter type pg_catalog.pg_ndistinct owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.pg_dependencies is 'multivariate dependencies';

alter type pg_catalog.pg_dependencies owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.tsvector is 'text representation for text search';

alter type pg_catalog.tsvector owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.tsquery is 'query representation for text search';

alter type pg_catalog.tsquery owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.gtsvector is 'GiST index internal text representation for text search';

alter type pg_catalog.gtsvector owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regconfig is 'registered text search configuration';

alter type pg_catalog.regconfig owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regdictionary is 'registered text search dictionary';

alter type pg_catalog.regdictionary owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.jsonb is 'Binary JSON';

alter type pg_catalog.jsonb owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.jsonpath is 'JSON path';

alter type pg_catalog.jsonpath owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regnamespace is 'registered namespace';

alter type pg_catalog.regnamespace owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regrole is 'registered role';

alter type pg_catalog.regrole owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.pg_mcv_list is 'multivariate MCV list';

alter type pg_catalog.pg_mcv_list owner to postgres;

create domain information_schema.cardinal_number as integer
    constraint cardinal_number_domain_check check (VALUE >= 0);

alter domain information_schema.cardinal_number owner to postgres;

create domain information_schema.character_data as varchar;

alter domain information_schema.character_data owner to postgres;

create domain information_schema.sql_identifier as name;

alter domain information_schema.sql_identifier owner to postgres;

create domain information_schema.time_stamp as timestamp(2) with time zone
    default CURRENT_TIMESTAMP(2);

alter domain information_schema.time_stamp owner to postgres;

create domain information_schema.yes_or_no as varchar(3)
    constraint yes_or_no_check check ((VALUE)::text = ANY
                                      ((ARRAY ['YES'::character varying, 'NO'::character varying])::text[]));

alter domain information_schema.yes_or_no owner to postgres;

create table pg_catalog.pg_default_acl
(
    oid             oid       not null,
    defaclrole      oid       not null,
    defaclnamespace oid       not null,
    defaclobjtype   "char"    not null,
    defaclacl       aclitem[] not null
);

alter table pg_catalog.pg_default_acl
    owner to postgres;

create unique index pg_default_acl_role_nsp_obj_index
    on pg_catalog.pg_default_acl (defaclrole, defaclnamespace, defaclobjtype);

create unique index pg_default_acl_oid_index
    on pg_catalog.pg_default_acl (oid);

grant select on pg_catalog.pg_default_acl to public;

create table pg_catalog.pg_pltemplate
(
    tmplname      name    not null,
    tmpltrusted   boolean not null,
    tmpldbacreate boolean not null,
    tmplhandler   text    not null,
    tmplinline    text,
    tmplvalidator text,
    tmpllibrary   text    not null,
    tmplacl       aclitem[]
)
    tablespace pg_global;

alter table pg_catalog.pg_pltemplate
    owner to postgres;

create unique index pg_pltemplate_name_index
    on pg_catalog.pg_pltemplate (tmplname collate "C")
    tablespace pg_global;

grant select on pg_catalog.pg_pltemplate to public;

create table pg_catalog.pg_tablespace
(
    oid        oid  not null,
    spcname    name not null,
    spcowner   oid  not null,
    spcacl     aclitem[],
    spcoptions text[]
)
    tablespace pg_global;

alter table pg_catalog.pg_tablespace
    owner to postgres;

create unique index pg_tablespace_oid_index
    on pg_catalog.pg_tablespace (oid)
    tablespace pg_global;

create unique index pg_tablespace_spcname_index
    on pg_catalog.pg_tablespace (spcname collate "C")
    tablespace pg_global;

grant select on pg_catalog.pg_tablespace to public;

create table pg_catalog.pg_shdepend
(
    dbid       oid     not null,
    classid    oid     not null,
    objid      oid     not null,
    objsubid   integer not null,
    refclassid oid     not null,
    refobjid   oid     not null,
    deptype    "char"  not null
)
    tablespace pg_global;

alter table pg_catalog.pg_shdepend
    owner to postgres;

create index pg_shdepend_depender_index
    on pg_catalog.pg_shdepend (dbid, classid, objid, objsubid)
    tablespace pg_global;

create index pg_shdepend_reference_index
    on pg_catalog.pg_shdepend (refclassid, refobjid)
    tablespace pg_global;

grant select on pg_catalog.pg_shdepend to public;

create table pg_catalog.pg_type
(
    oid            oid      not null,
    typname        name     not null,
    typnamespace   oid      not null,
    typowner       oid      not null,
    typlen         smallint not null,
    typbyval       boolean  not null,
    typtype        "char"   not null,
    typcategory    "char"   not null,
    typispreferred boolean  not null,
    typisdefined   boolean  not null,
    typdelim       "char"   not null,
    typrelid       oid      not null,
    typelem        oid      not null,
    typarray       oid      not null,
    typinput       regproc  not null,
    typoutput      regproc  not null,
    typreceive     regproc  not null,
    typsend        regproc  not null,
    typmodin       regproc  not null,
    typmodout      regproc  not null,
    typanalyze     regproc  not null,
    typalign       "char"   not null,
    typstorage     "char"   not null,
    typnotnull     boolean  not null,
    typbasetype    oid      not null,
    typtypmod      integer  not null,
    typndims       integer  not null,
    typcollation   oid      not null,
    typdefaultbin  pg_node_tree,
    typdefault     text,
    typacl         aclitem[]
);

alter table pg_catalog.pg_type
    owner to postgres;

create unique index pg_type_oid_index
    on pg_catalog.pg_type (oid);

create unique index pg_type_typname_nsp_index
    on pg_catalog.pg_type (typname collate "C", typnamespace);

grant select on pg_catalog.pg_type to public;

create table pg_catalog.pg_attribute
(
    attrelid      oid      not null,
    attname       name     not null,
    atttypid      oid      not null,
    attstattarget integer  not null,
    attlen        smallint not null,
    attnum        smallint not null,
    attndims      integer  not null,
    attcacheoff   integer  not null,
    atttypmod     integer  not null,
    attbyval      boolean  not null,
    attstorage    "char"   not null,
    attalign      "char"   not null,
    attnotnull    boolean  not null,
    atthasdef     boolean  not null,
    atthasmissing boolean  not null,
    attidentity   "char"   not null,
    attgenerated  "char"   not null,
    attisdropped  boolean  not null,
    attislocal    boolean  not null,
    attinhcount   integer  not null,
    attcollation  oid      not null,
    attacl        aclitem[],
    attoptions    text[],
    attfdwoptions text[],
    attmissingval anyarray
);

alter table pg_catalog.pg_attribute
    owner to postgres;

create unique index pg_attribute_relid_attnam_index
    on pg_catalog.pg_attribute (attrelid, attname collate "C");

create unique index pg_attribute_relid_attnum_index
    on pg_catalog.pg_attribute (attrelid, attnum);

grant select on pg_catalog.pg_attribute to public;

create table pg_catalog.pg_proc
(
    oid             oid       not null,
    proname         name      not null,
    pronamespace    oid       not null,
    proowner        oid       not null,
    prolang         oid       not null,
    procost         real      not null,
    prorows         real      not null,
    provariadic     oid       not null,
    prosupport      regproc   not null,
    prokind         "char"    not null,
    prosecdef       boolean   not null,
    proleakproof    boolean   not null,
    proisstrict     boolean   not null,
    proretset       boolean   not null,
    provolatile     "char"    not null,
    proparallel     "char"    not null,
    pronargs        smallint  not null,
    pronargdefaults smallint  not null,
    prorettype      oid       not null,
    proargtypes     oidvector not null,
    proallargtypes  oid[],
    proargmodes     "char"[],
    proargnames     text[],
    proargdefaults  pg_node_tree,
    protrftypes     oid[],
    prosrc          text      not null,
    probin          text,
    proconfig       text[],
    proacl          aclitem[]
);

alter table pg_catalog.pg_proc
    owner to postgres;

create unique index pg_proc_oid_index
    on pg_catalog.pg_proc (oid);

create unique index pg_proc_proname_args_nsp_index
    on pg_catalog.pg_proc (proname collate "C", proargtypes, pronamespace);

grant select on pg_catalog.pg_proc to public;

create table pg_catalog.pg_class
(
    oid                 oid      not null,
    relname             name     not null,
    relnamespace        oid      not null,
    reltype             oid      not null,
    reloftype           oid      not null,
    relowner            oid      not null,
    relam               oid      not null,
    relfilenode         oid      not null,
    reltablespace       oid      not null,
    relpages            integer  not null,
    reltuples           real     not null,
    relallvisible       integer  not null,
    reltoastrelid       oid      not null,
    relhasindex         boolean  not null,
    relisshared         boolean  not null,
    relpersistence      "char"   not null,
    relkind             "char"   not null,
    relnatts            smallint not null,
    relchecks           smallint not null,
    relhasrules         boolean  not null,
    relhastriggers      boolean  not null,
    relhassubclass      boolean  not null,
    relrowsecurity      boolean  not null,
    relforcerowsecurity boolean  not null,
    relispopulated      boolean  not null,
    relreplident        "char"   not null,
    relispartition      boolean  not null,
    relrewrite          oid      not null,
    relfrozenxid        xid      not null,
    relminmxid          xid      not null,
    relacl              aclitem[],
    reloptions          text[],
    relpartbound        pg_node_tree
);

alter table pg_catalog.pg_class
    owner to postgres;

create unique index pg_class_oid_index
    on pg_catalog.pg_class (oid);

create unique index pg_class_relname_nsp_index
    on pg_catalog.pg_class (relname collate "C", relnamespace);

create index pg_class_tblspc_relfilenode_index
    on pg_catalog.pg_class (reltablespace, relfilenode);

grant select on pg_catalog.pg_class to public;

create table pg_catalog.pg_authid
(
    oid            oid     not null,
    rolname        name    not null,
    rolsuper       boolean not null,
    rolinherit     boolean not null,
    rolcreaterole  boolean not null,
    rolcreatedb    boolean not null,
    rolcanlogin    boolean not null,
    rolreplication boolean not null,
    rolbypassrls   boolean not null,
    rolconnlimit   integer not null,
    rolpassword    text,
    rolvaliduntil  timestamp with time zone
)
    tablespace pg_global;

alter table pg_catalog.pg_authid
    owner to postgres;

create unique index pg_authid_rolname_index
    on pg_catalog.pg_authid (rolname collate "C")
    tablespace pg_global;

create unique index pg_authid_oid_index
    on pg_catalog.pg_authid (oid)
    tablespace pg_global;

create table pg_catalog.pg_auth_members
(
    roleid       oid     not null,
    member       oid     not null,
    grantor      oid     not null,
    admin_option boolean not null
)
    tablespace pg_global;

alter table pg_catalog.pg_auth_members
    owner to postgres;

create unique index pg_auth_members_role_member_index
    on pg_catalog.pg_auth_members (roleid, member)
    tablespace pg_global;

create unique index pg_auth_members_member_role_index
    on pg_catalog.pg_auth_members (member, roleid)
    tablespace pg_global;

grant select on pg_catalog.pg_auth_members to public;

create table pg_catalog.pg_database
(
    oid           oid     not null,
    datname       name    not null,
    datdba        oid     not null,
    encoding      integer not null,
    datcollate    name    not null,
    datctype      name    not null,
    datistemplate boolean not null,
    datallowconn  boolean not null,
    datconnlimit  integer not null,
    datlastsysoid oid     not null,
    datfrozenxid  xid     not null,
    datminmxid    xid     not null,
    dattablespace oid     not null,
    datacl        aclitem[]
)
    tablespace pg_global;

alter table pg_catalog.pg_database
    owner to postgres;

create unique index pg_database_datname_index
    on pg_catalog.pg_database (datname collate "C")
    tablespace pg_global;

create unique index pg_database_oid_index
    on pg_catalog.pg_database (oid)
    tablespace pg_global;

grant select on pg_catalog.pg_database to public;

create table pg_catalog.pg_foreign_server
(
    oid        oid  not null,
    srvname    name not null,
    srvowner   oid  not null,
    srvfdw     oid  not null,
    srvtype    text,
    srvversion text,
    srvacl     aclitem[],
    srvoptions text[]
);

alter table pg_catalog.pg_foreign_server
    owner to postgres;

create unique index pg_foreign_server_oid_index
    on pg_catalog.pg_foreign_server (oid);

create unique index pg_foreign_server_name_index
    on pg_catalog.pg_foreign_server (srvname collate "C");

grant select on pg_catalog.pg_foreign_server to public;

create table pg_catalog.pg_user_mapping
(
    oid       oid not null,
    umuser    oid not null,
    umserver  oid not null,
    umoptions text[]
);

alter table pg_catalog.pg_user_mapping
    owner to postgres;

create unique index pg_user_mapping_oid_index
    on pg_catalog.pg_user_mapping (oid);

create unique index pg_user_mapping_user_server_index
    on pg_catalog.pg_user_mapping (umuser, umserver);

create table pg_catalog.pg_sequence
(
    seqrelid     oid     not null,
    seqtypid     oid     not null,
    seqstart     bigint  not null,
    seqincrement bigint  not null,
    seqmax       bigint  not null,
    seqmin       bigint  not null,
    seqcache     bigint  not null,
    seqcycle     boolean not null
);

alter table pg_catalog.pg_sequence
    owner to postgres;

create unique index pg_sequence_seqrelid_index
    on pg_catalog.pg_sequence (seqrelid);

grant select on pg_catalog.pg_sequence to public;

create table pg_catalog.pg_foreign_data_wrapper
(
    oid          oid  not null,
    fdwname      name not null,
    fdwowner     oid  not null,
    fdwhandler   oid  not null,
    fdwvalidator oid  not null,
    fdwacl       aclitem[],
    fdwoptions   text[]
);

alter table pg_catalog.pg_foreign_data_wrapper
    owner to postgres;

create unique index pg_foreign_data_wrapper_oid_index
    on pg_catalog.pg_foreign_data_wrapper (oid);

create unique index pg_foreign_data_wrapper_name_index
    on pg_catalog.pg_foreign_data_wrapper (fdwname collate "C");

grant select on pg_catalog.pg_foreign_data_wrapper to public;

create table pg_catalog.pg_shdescription
(
    objoid      oid  not null,
    classoid    oid  not null,
    description text not null
)
    tablespace pg_global;

alter table pg_catalog.pg_shdescription
    owner to postgres;

create unique index pg_shdescription_o_c_index
    on pg_catalog.pg_shdescription (objoid, classoid)
    tablespace pg_global;

grant select on pg_catalog.pg_shdescription to public;

create table pg_catalog.pg_aggregate
(
    aggfnoid         regproc  not null,
    aggkind          "char"   not null,
    aggnumdirectargs smallint not null,
    aggtransfn       regproc  not null,
    aggfinalfn       regproc  not null,
    aggcombinefn     regproc  not null,
    aggserialfn      regproc  not null,
    aggdeserialfn    regproc  not null,
    aggmtransfn      regproc  not null,
    aggminvtransfn   regproc  not null,
    aggmfinalfn      regproc  not null,
    aggfinalextra    boolean  not null,
    aggmfinalextra   boolean  not null,
    aggfinalmodify   "char"   not null,
    aggmfinalmodify  "char"   not null,
    aggsortop        oid      not null,
    aggtranstype     oid      not null,
    aggtransspace    integer  not null,
    aggmtranstype    oid      not null,
    aggmtransspace   integer  not null,
    agginitval       text,
    aggminitval      text
);

alter table pg_catalog.pg_aggregate
    owner to postgres;

create unique index pg_aggregate_fnoid_index
    on pg_catalog.pg_aggregate (aggfnoid);

grant select on pg_catalog.pg_aggregate to public;

create table pg_catalog.pg_am
(
    oid       oid     not null,
    amname    name    not null,
    amhandler regproc not null,
    amtype    "char"  not null
);

alter table pg_catalog.pg_am
    owner to postgres;

create unique index pg_am_name_index
    on pg_catalog.pg_am (amname collate "C");

create unique index pg_am_oid_index
    on pg_catalog.pg_am (oid);

grant select on pg_catalog.pg_am to public;

create table pg_catalog.pg_amop
(
    oid            oid      not null,
    amopfamily     oid      not null,
    amoplefttype   oid      not null,
    amoprighttype  oid      not null,
    amopstrategy   smallint not null,
    amoppurpose    "char"   not null,
    amopopr        oid      not null,
    amopmethod     oid      not null,
    amopsortfamily oid      not null
);

alter table pg_catalog.pg_amop
    owner to postgres;

create unique index pg_amop_fam_strat_index
    on pg_catalog.pg_amop (amopfamily, amoplefttype, amoprighttype, amopstrategy);

create unique index pg_amop_opr_fam_index
    on pg_catalog.pg_amop (amopopr, amoppurpose, amopfamily);

create unique index pg_amop_oid_index
    on pg_catalog.pg_amop (oid);

grant select on pg_catalog.pg_amop to public;

create table pg_catalog.pg_amproc
(
    oid             oid      not null,
    amprocfamily    oid      not null,
    amproclefttype  oid      not null,
    amprocrighttype oid      not null,
    amprocnum       smallint not null,
    amproc          regproc  not null
);

alter table pg_catalog.pg_amproc
    owner to postgres;

create unique index pg_amproc_fam_proc_index
    on pg_catalog.pg_amproc (amprocfamily, amproclefttype, amprocrighttype, amprocnum);

create unique index pg_amproc_oid_index
    on pg_catalog.pg_amproc (oid);

grant select on pg_catalog.pg_amproc to public;

create table pg_catalog.pg_attrdef
(
    oid     oid          not null,
    adrelid oid          not null,
    adnum   smallint     not null,
    adbin   pg_node_tree not null
);

alter table pg_catalog.pg_attrdef
    owner to postgres;

create unique index pg_attrdef_adrelid_adnum_index
    on pg_catalog.pg_attrdef (adrelid, adnum);

create unique index pg_attrdef_oid_index
    on pg_catalog.pg_attrdef (oid);

grant select on pg_catalog.pg_attrdef to public;

create table pg_catalog.pg_cast
(
    oid         oid    not null,
    castsource  oid    not null,
    casttarget  oid    not null,
    castfunc    oid    not null,
    castcontext "char" not null,
    castmethod  "char" not null
);

alter table pg_catalog.pg_cast
    owner to postgres;

create unique index pg_cast_oid_index
    on pg_catalog.pg_cast (oid);

create unique index pg_cast_source_target_index
    on pg_catalog.pg_cast (castsource, casttarget);

grant select on pg_catalog.pg_cast to public;

create table pg_catalog.pg_constraint
(
    oid           oid     not null,
    conname       name    not null,
    connamespace  oid     not null,
    contype       "char"  not null,
    condeferrable boolean not null,
    condeferred   boolean not null,
    convalidated  boolean not null,
    conrelid      oid     not null,
    contypid      oid     not null,
    conindid      oid     not null,
    conparentid   oid     not null,
    confrelid     oid     not null,
    confupdtype   "char"  not null,
    confdeltype   "char"  not null,
    confmatchtype "char"  not null,
    conislocal    boolean not null,
    coninhcount   integer not null,
    connoinherit  boolean not null,
    conkey        smallint[],
    confkey       smallint[],
    conpfeqop     oid[],
    conppeqop     oid[],
    conffeqop     oid[],
    conexclop     oid[],
    conbin        pg_node_tree
);

alter table pg_catalog.pg_constraint
    owner to postgres;

create index pg_constraint_conparentid_index
    on pg_catalog.pg_constraint (conparentid);

create index pg_constraint_conname_nsp_index
    on pg_catalog.pg_constraint (conname collate "C", connamespace);

create unique index pg_constraint_conrelid_contypid_conname_index
    on pg_catalog.pg_constraint (conrelid, contypid, conname collate "C");

create index pg_constraint_contypid_index
    on pg_catalog.pg_constraint (contypid);

create unique index pg_constraint_oid_index
    on pg_catalog.pg_constraint (oid);

grant select on pg_catalog.pg_constraint to public;

create table pg_catalog.pg_conversion
(
    oid            oid     not null,
    conname        name    not null,
    connamespace   oid     not null,
    conowner       oid     not null,
    conforencoding integer not null,
    contoencoding  integer not null,
    conproc        regproc not null,
    condefault     boolean not null
);

alter table pg_catalog.pg_conversion
    owner to postgres;

create unique index pg_conversion_default_index
    on pg_catalog.pg_conversion (connamespace, conforencoding, contoencoding, oid);

create unique index pg_conversion_name_nsp_index
    on pg_catalog.pg_conversion (conname collate "C", connamespace);

create unique index pg_conversion_oid_index
    on pg_catalog.pg_conversion (oid);

grant select on pg_catalog.pg_conversion to public;

create table pg_catalog.pg_depend
(
    classid     oid     not null,
    objid       oid     not null,
    objsubid    integer not null,
    refclassid  oid     not null,
    refobjid    oid     not null,
    refobjsubid integer not null,
    deptype     "char"  not null
);

alter table pg_catalog.pg_depend
    owner to postgres;

create index pg_depend_depender_index
    on pg_catalog.pg_depend (classid, objid, objsubid);

create index pg_depend_reference_index
    on pg_catalog.pg_depend (refclassid, refobjid, refobjsubid);

grant select on pg_catalog.pg_depend to public;

create table pg_catalog.pg_description
(
    objoid      oid     not null,
    classoid    oid     not null,
    objsubid    integer not null,
    description text    not null
);

alter table pg_catalog.pg_description
    owner to postgres;

create unique index pg_description_o_c_o_index
    on pg_catalog.pg_description (objoid, classoid, objsubid);

grant select on pg_catalog.pg_description to public;

create table pg_catalog.pg_index
(
    indexrelid     oid        not null,
    indrelid       oid        not null,
    indnatts       smallint   not null,
    indnkeyatts    smallint   not null,
    indisunique    boolean    not null,
    indisprimary   boolean    not null,
    indisexclusion boolean    not null,
    indimmediate   boolean    not null,
    indisclustered boolean    not null,
    indisvalid     boolean    not null,
    indcheckxmin   boolean    not null,
    indisready     boolean    not null,
    indislive      boolean    not null,
    indisreplident boolean    not null,
    indkey         int2vector not null,
    indcollation   oidvector  not null,
    indclass       oidvector  not null,
    indoption      int2vector not null,
    indexprs       pg_node_tree,
    indpred        pg_node_tree
);

alter table pg_catalog.pg_index
    owner to postgres;

create index pg_index_indrelid_index
    on pg_catalog.pg_index (indrelid);

create unique index pg_index_indexrelid_index
    on pg_catalog.pg_index (indexrelid);

grant select on pg_catalog.pg_index to public;

create table pg_catalog.pg_inherits
(
    inhrelid  oid     not null,
    inhparent oid     not null,
    inhseqno  integer not null
);

alter table pg_catalog.pg_inherits
    owner to postgres;

create index pg_inherits_parent_index
    on pg_catalog.pg_inherits (inhparent);

create unique index pg_inherits_relid_seqno_index
    on pg_catalog.pg_inherits (inhrelid, inhseqno);

grant select on pg_catalog.pg_inherits to public;

create table pg_catalog.pg_language
(
    oid           oid     not null,
    lanname       name    not null,
    lanowner      oid     not null,
    lanispl       boolean not null,
    lanpltrusted  boolean not null,
    lanplcallfoid oid     not null,
    laninline     oid     not null,
    lanvalidator  oid     not null,
    lanacl        aclitem[]
);

alter table pg_catalog.pg_language
    owner to postgres;

create unique index pg_language_name_index
    on pg_catalog.pg_language (lanname collate "C");

create unique index pg_language_oid_index
    on pg_catalog.pg_language (oid);

grant select on pg_catalog.pg_language to public;

create table pg_catalog.pg_largeobject
(
    loid   oid     not null,
    pageno integer not null,
    data   bytea   not null
);

alter table pg_catalog.pg_largeobject
    owner to postgres;

create unique index pg_largeobject_loid_pn_index
    on pg_catalog.pg_largeobject (loid, pageno);

create table pg_catalog.pg_namespace
(
    oid      oid  not null,
    nspname  name not null,
    nspowner oid  not null,
    nspacl   aclitem[]
);

alter table pg_catalog.pg_namespace
    owner to postgres;

create unique index pg_namespace_nspname_index
    on pg_catalog.pg_namespace (nspname collate "C");

create unique index pg_namespace_oid_index
    on pg_catalog.pg_namespace (oid);

grant select on pg_catalog.pg_namespace to public;

create table pg_catalog.pg_opclass
(
    oid          oid     not null,
    opcmethod    oid     not null,
    opcname      name    not null,
    opcnamespace oid     not null,
    opcowner     oid     not null,
    opcfamily    oid     not null,
    opcintype    oid     not null,
    opcdefault   boolean not null,
    opckeytype   oid     not null
);

alter table pg_catalog.pg_opclass
    owner to postgres;

create unique index pg_opclass_am_name_nsp_index
    on pg_catalog.pg_opclass (opcmethod, opcname collate "C", opcnamespace);

create unique index pg_opclass_oid_index
    on pg_catalog.pg_opclass (oid);

grant select on pg_catalog.pg_opclass to public;

create table pg_catalog.pg_operator
(
    oid          oid     not null,
    oprname      name    not null,
    oprnamespace oid     not null,
    oprowner     oid     not null,
    oprkind      "char"  not null,
    oprcanmerge  boolean not null,
    oprcanhash   boolean not null,
    oprleft      oid     not null,
    oprright     oid     not null,
    oprresult    oid     not null,
    oprcom       oid     not null,
    oprnegate    oid     not null,
    oprcode      regproc not null,
    oprrest      regproc not null,
    oprjoin      regproc not null
);

alter table pg_catalog.pg_operator
    owner to postgres;

create unique index pg_operator_oid_index
    on pg_catalog.pg_operator (oid);

create unique index pg_operator_oprname_l_r_n_index
    on pg_catalog.pg_operator (oprname collate "C", oprleft, oprright, oprnamespace);

grant select on pg_catalog.pg_operator to public;

create table pg_catalog.pg_rewrite
(
    oid        oid          not null,
    rulename   name         not null,
    ev_class   oid          not null,
    ev_type    "char"       not null,
    ev_enabled "char"       not null,
    is_instead boolean      not null,
    ev_qual    pg_node_tree not null,
    ev_action  pg_node_tree not null
);

alter table pg_catalog.pg_rewrite
    owner to postgres;

create unique index pg_rewrite_oid_index
    on pg_catalog.pg_rewrite (oid);

create unique index pg_rewrite_rel_rulename_index
    on pg_catalog.pg_rewrite (ev_class, rulename collate "C");

grant select on pg_catalog.pg_rewrite to public;

create table pg_catalog.pg_statistic
(
    starelid    oid      not null,
    staattnum   smallint not null,
    stainherit  boolean  not null,
    stanullfrac real     not null,
    stawidth    integer  not null,
    stadistinct real     not null,
    stakind1    smallint not null,
    stakind2    smallint not null,
    stakind3    smallint not null,
    stakind4    smallint not null,
    stakind5    smallint not null,
    staop1      oid      not null,
    staop2      oid      not null,
    staop3      oid      not null,
    staop4      oid      not null,
    staop5      oid      not null,
    stacoll1    oid      not null,
    stacoll2    oid      not null,
    stacoll3    oid      not null,
    stacoll4    oid      not null,
    stacoll5    oid      not null,
    stanumbers1 real[],
    stanumbers2 real[],
    stanumbers3 real[],
    stanumbers4 real[],
    stanumbers5 real[],
    stavalues1  anyarray,
    stavalues2  anyarray,
    stavalues3  anyarray,
    stavalues4  anyarray,
    stavalues5  anyarray
);

alter table pg_catalog.pg_statistic
    owner to postgres;

create unique index pg_statistic_relid_att_inh_index
    on pg_catalog.pg_statistic (starelid, staattnum, stainherit);

create table pg_catalog.pg_trigger
(
    oid            oid        not null,
    tgrelid        oid        not null,
    tgname         name       not null,
    tgfoid         oid        not null,
    tgtype         smallint   not null,
    tgenabled      "char"     not null,
    tgisinternal   boolean    not null,
    tgconstrrelid  oid        not null,
    tgconstrindid  oid        not null,
    tgconstraint   oid        not null,
    tgdeferrable   boolean    not null,
    tginitdeferred boolean    not null,
    tgnargs        smallint   not null,
    tgattr         int2vector not null,
    tgargs         bytea      not null,
    tgqual         pg_node_tree,
    tgoldtable     name,
    tgnewtable     name
);

alter table pg_catalog.pg_trigger
    owner to postgres;

create index pg_trigger_tgconstraint_index
    on pg_catalog.pg_trigger (tgconstraint);

create unique index pg_trigger_tgrelid_tgname_index
    on pg_catalog.pg_trigger (tgrelid, tgname collate "C");

create unique index pg_trigger_oid_index
    on pg_catalog.pg_trigger (oid);

grant select on pg_catalog.pg_trigger to public;

create table pg_catalog.pg_opfamily
(
    oid          oid  not null,
    opfmethod    oid  not null,
    opfname      name not null,
    opfnamespace oid  not null,
    opfowner     oid  not null
);

alter table pg_catalog.pg_opfamily
    owner to postgres;

create unique index pg_opfamily_am_name_nsp_index
    on pg_catalog.pg_opfamily (opfmethod, opfname collate "C", opfnamespace);

create unique index pg_opfamily_oid_index
    on pg_catalog.pg_opfamily (oid);

grant select on pg_catalog.pg_opfamily to public;

create table pg_catalog.pg_db_role_setting
(
    setdatabase oid not null,
    setrole     oid not null,
    setconfig   text[]
)
    tablespace pg_global;

alter table pg_catalog.pg_db_role_setting
    owner to postgres;

create unique index pg_db_role_setting_databaseid_rol_index
    on pg_catalog.pg_db_role_setting (setdatabase, setrole)
    tablespace pg_global;

grant select on pg_catalog.pg_db_role_setting to public;

create table pg_catalog.pg_largeobject_metadata
(
    oid      oid not null,
    lomowner oid not null,
    lomacl   aclitem[]
);

alter table pg_catalog.pg_largeobject_metadata
    owner to postgres;

create unique index pg_largeobject_metadata_oid_index
    on pg_catalog.pg_largeobject_metadata (oid);

grant select on pg_catalog.pg_largeobject_metadata to public;

create table pg_catalog.pg_extension
(
    oid            oid     not null,
    extname        name    not null,
    extowner       oid     not null,
    extnamespace   oid     not null,
    extrelocatable boolean not null,
    extversion     text    not null,
    extconfig      oid[],
    extcondition   text[]
);

alter table pg_catalog.pg_extension
    owner to postgres;

create unique index pg_extension_oid_index
    on pg_catalog.pg_extension (oid);

create unique index pg_extension_name_index
    on pg_catalog.pg_extension (extname collate "C");

grant select on pg_catalog.pg_extension to public;

create table pg_catalog.pg_foreign_table
(
    ftrelid   oid not null,
    ftserver  oid not null,
    ftoptions text[]
);

alter table pg_catalog.pg_foreign_table
    owner to postgres;

create unique index pg_foreign_table_relid_index
    on pg_catalog.pg_foreign_table (ftrelid);

grant select on pg_catalog.pg_foreign_table to public;

create table pg_catalog.pg_policy
(
    oid           oid     not null,
    polname       name    not null,
    polrelid      oid     not null,
    polcmd        "char"  not null,
    polpermissive boolean not null,
    polroles      oid[]   not null,
    polqual       pg_node_tree,
    polwithcheck  pg_node_tree
);

alter table pg_catalog.pg_policy
    owner to postgres;

create unique index pg_policy_oid_index
    on pg_catalog.pg_policy (oid);

create unique index pg_policy_polrelid_polname_index
    on pg_catalog.pg_policy (polrelid, polname collate "C");

grant select on pg_catalog.pg_policy to public;

create table pg_catalog.pg_partitioned_table
(
    partrelid     oid        not null,
    partstrat     "char"     not null,
    partnatts     smallint   not null,
    partdefid     oid        not null,
    partattrs     int2vector not null,
    partclass     oidvector  not null,
    partcollation oidvector  not null,
    partexprs     pg_node_tree
);

alter table pg_catalog.pg_partitioned_table
    owner to postgres;

create unique index pg_partitioned_table_partrelid_index
    on pg_catalog.pg_partitioned_table (partrelid);

grant select on pg_catalog.pg_partitioned_table to public;

create table pg_catalog.pg_statistic_ext
(
    oid          oid        not null,
    stxrelid     oid        not null,
    stxname      name       not null,
    stxnamespace oid        not null,
    stxowner     oid        not null,
    stxkeys      int2vector not null,
    stxkind      "char"[]   not null
);

alter table pg_catalog.pg_statistic_ext
    owner to postgres;

create index pg_statistic_ext_relid_index
    on pg_catalog.pg_statistic_ext (stxrelid);

create unique index pg_statistic_ext_oid_index
    on pg_catalog.pg_statistic_ext (oid);

create unique index pg_statistic_ext_name_index
    on pg_catalog.pg_statistic_ext (stxname collate "C", stxnamespace);

grant select on pg_catalog.pg_statistic_ext to public;

create table pg_catalog.pg_init_privs
(
    objoid    oid       not null,
    classoid  oid       not null,
    objsubid  integer   not null,
    privtype  "char"    not null,
    initprivs aclitem[] not null
);

alter table pg_catalog.pg_init_privs
    owner to postgres;

create unique index pg_init_privs_o_c_o_index
    on pg_catalog.pg_init_privs (objoid, classoid, objsubid);

grant select on pg_catalog.pg_init_privs to public;

create table pg_catalog.pg_statistic_ext_data
(
    stxoid           oid not null,
    stxdndistinct    pg_ndistinct,
    stxddependencies pg_dependencies,
    stxdmcv          pg_mcv_list
);

alter table pg_catalog.pg_statistic_ext_data
    owner to postgres;

create unique index pg_statistic_ext_data_stxoid_index
    on pg_catalog.pg_statistic_ext_data (stxoid);

create table pg_catalog.pg_collation
(
    oid                 oid     not null,
    collname            name    not null,
    collnamespace       oid     not null,
    collowner           oid     not null,
    collprovider        "char"  not null,
    collisdeterministic boolean not null,
    collencoding        integer not null,
    collcollate         name    not null,
    collctype           name    not null,
    collversion         text
);

alter table pg_catalog.pg_collation
    owner to postgres;

create unique index pg_collation_oid_index
    on pg_catalog.pg_collation (oid);

create unique index pg_collation_name_enc_nsp_index
    on pg_catalog.pg_collation (collname collate "C", collencoding, collnamespace);

grant select on pg_catalog.pg_collation to public;

create table pg_catalog.pg_event_trigger
(
    oid        oid    not null,
    evtname    name   not null,
    evtevent   name   not null,
    evtowner   oid    not null,
    evtfoid    oid    not null,
    evtenabled "char" not null,
    evttags    text[]
);

alter table pg_catalog.pg_event_trigger
    owner to postgres;

create unique index pg_event_trigger_evtname_index
    on pg_catalog.pg_event_trigger (evtname collate "C");

create unique index pg_event_trigger_oid_index
    on pg_catalog.pg_event_trigger (oid);

grant select on pg_catalog.pg_event_trigger to public;

create table pg_catalog.pg_enum
(
    oid           oid  not null,
    enumtypid     oid  not null,
    enumsortorder real not null,
    enumlabel     name not null
);

alter table pg_catalog.pg_enum
    owner to postgres;

create unique index pg_enum_oid_index
    on pg_catalog.pg_enum (oid);

create unique index pg_enum_typid_label_index
    on pg_catalog.pg_enum (enumtypid, enumlabel collate "C");

create unique index pg_enum_typid_sortorder_index
    on pg_catalog.pg_enum (enumtypid, enumsortorder);

grant select on pg_catalog.pg_enum to public;

create table pg_catalog.pg_range
(
    rngtypid     oid     not null,
    rngsubtype   oid     not null,
    rngcollation oid     not null,
    rngsubopc    oid     not null,
    rngcanonical regproc not null,
    rngsubdiff   regproc not null
);

alter table pg_catalog.pg_range
    owner to postgres;

create unique index pg_range_rngtypid_index
    on pg_catalog.pg_range (rngtypid);

grant select on pg_catalog.pg_range to public;

create table pg_catalog.pg_transform
(
    oid        oid     not null,
    trftype    oid     not null,
    trflang    oid     not null,
    trffromsql regproc not null,
    trftosql   regproc not null
);

alter table pg_catalog.pg_transform
    owner to postgres;

create unique index pg_transform_oid_index
    on pg_catalog.pg_transform (oid);

create unique index pg_transform_type_lang_index
    on pg_catalog.pg_transform (trftype, trflang);

grant select on pg_catalog.pg_transform to public;

create table pg_catalog.pg_shseclabel
(
    objoid   oid  not null,
    classoid oid  not null,
    provider text not null,
    label    text not null
)
    tablespace pg_global;

alter table pg_catalog.pg_shseclabel
    owner to postgres;

create unique index pg_shseclabel_object_index
    on pg_catalog.pg_shseclabel (objoid, classoid, provider collate "C")
    tablespace pg_global;

grant select on pg_catalog.pg_shseclabel to public;

create table pg_catalog.pg_seclabel
(
    objoid   oid     not null,
    classoid oid     not null,
    objsubid integer not null,
    provider text    not null,
    label    text    not null
);

alter table pg_catalog.pg_seclabel
    owner to postgres;

create unique index pg_seclabel_object_index
    on pg_catalog.pg_seclabel (objoid, classoid, objsubid, provider collate "C");

grant select on pg_catalog.pg_seclabel to public;

create table pg_catalog.pg_ts_dict
(
    oid            oid  not null,
    dictname       name not null,
    dictnamespace  oid  not null,
    dictowner      oid  not null,
    dicttemplate   oid  not null,
    dictinitoption text
);

alter table pg_catalog.pg_ts_dict
    owner to postgres;

create unique index pg_ts_dict_dictname_index
    on pg_catalog.pg_ts_dict (dictname collate "C", dictnamespace);

create unique index pg_ts_dict_oid_index
    on pg_catalog.pg_ts_dict (oid);

grant select on pg_catalog.pg_ts_dict to public;

create table pg_catalog.pg_ts_parser
(
    oid          oid     not null,
    prsname      name    not null,
    prsnamespace oid     not null,
    prsstart     regproc not null,
    prstoken     regproc not null,
    prsend       regproc not null,
    prsheadline  regproc not null,
    prslextype   regproc not null
);

alter table pg_catalog.pg_ts_parser
    owner to postgres;

create unique index pg_ts_parser_prsname_index
    on pg_catalog.pg_ts_parser (prsname collate "C", prsnamespace);

create unique index pg_ts_parser_oid_index
    on pg_catalog.pg_ts_parser (oid);

grant select on pg_catalog.pg_ts_parser to public;

create table pg_catalog.pg_ts_config
(
    oid          oid  not null,
    cfgname      name not null,
    cfgnamespace oid  not null,
    cfgowner     oid  not null,
    cfgparser    oid  not null
);

alter table pg_catalog.pg_ts_config
    owner to postgres;

create unique index pg_ts_config_cfgname_index
    on pg_catalog.pg_ts_config (cfgname collate "C", cfgnamespace);

create unique index pg_ts_config_oid_index
    on pg_catalog.pg_ts_config (oid);

grant select on pg_catalog.pg_ts_config to public;

create table pg_catalog.pg_ts_config_map
(
    mapcfg       oid     not null,
    maptokentype integer not null,
    mapseqno     integer not null,
    mapdict      oid     not null
);

alter table pg_catalog.pg_ts_config_map
    owner to postgres;

create unique index pg_ts_config_map_index
    on pg_catalog.pg_ts_config_map (mapcfg, maptokentype, mapseqno);

grant select on pg_catalog.pg_ts_config_map to public;

create table pg_catalog.pg_ts_template
(
    oid           oid     not null,
    tmplname      name    not null,
    tmplnamespace oid     not null,
    tmplinit      regproc not null,
    tmpllexize    regproc not null
);

alter table pg_catalog.pg_ts_template
    owner to postgres;

create unique index pg_ts_template_tmplname_index
    on pg_catalog.pg_ts_template (tmplname collate "C", tmplnamespace);

create unique index pg_ts_template_oid_index
    on pg_catalog.pg_ts_template (oid);

grant select on pg_catalog.pg_ts_template to public;

create table pg_catalog.pg_replication_origin
(
    roident oid  not null,
    roname  text not null
)
    tablespace pg_global;

alter table pg_catalog.pg_replication_origin
    owner to postgres;

create unique index pg_replication_origin_roiident_index
    on pg_catalog.pg_replication_origin (roident)
    tablespace pg_global;

create unique index pg_replication_origin_roname_index
    on pg_catalog.pg_replication_origin (roname collate "C")
    tablespace pg_global;

grant select on pg_catalog.pg_replication_origin to public;

create table pg_catalog.pg_subscription
(
    oid             oid     not null,
    subdbid         oid     not null,
    subname         name    not null,
    subowner        oid     not null,
    subenabled      boolean not null,
    subconninfo     text    not null,
    subslotname     name    not null,
    subsynccommit   text    not null,
    subpublications text[]  not null
)
    tablespace pg_global;

alter table pg_catalog.pg_subscription
    owner to postgres;

create unique index pg_subscription_oid_index
    on pg_catalog.pg_subscription (oid)
    tablespace pg_global;

create unique index pg_subscription_subname_index
    on pg_catalog.pg_subscription (subdbid, subname collate "C")
    tablespace pg_global;

grant select (subdbid, subname, subowner, subenabled, subslotname, subpublications) on pg_catalog.pg_subscription to public;

create table pg_catalog.pg_subscription_rel
(
    srsubid    oid    not null,
    srrelid    oid    not null,
    srsubstate "char" not null,
    srsublsn   pg_lsn not null
);

alter table pg_catalog.pg_subscription_rel
    owner to postgres;

create unique index pg_subscription_rel_srrelid_srsubid_index
    on pg_catalog.pg_subscription_rel (srrelid, srsubid);

grant select on pg_catalog.pg_subscription_rel to public;

create table pg_catalog.pg_publication
(
    oid          oid     not null,
    pubname      name    not null,
    pubowner     oid     not null,
    puballtables boolean not null,
    pubinsert    boolean not null,
    pubupdate    boolean not null,
    pubdelete    boolean not null,
    pubtruncate  boolean not null
);

alter table pg_catalog.pg_publication
    owner to postgres;

create unique index pg_publication_oid_index
    on pg_catalog.pg_publication (oid);

create unique index pg_publication_pubname_index
    on pg_catalog.pg_publication (pubname collate "C");

grant select on pg_catalog.pg_publication to public;

create table pg_catalog.pg_publication_rel
(
    oid     oid not null,
    prpubid oid not null,
    prrelid oid not null
);

alter table pg_catalog.pg_publication_rel
    owner to postgres;

create unique index pg_publication_rel_oid_index
    on pg_catalog.pg_publication_rel (oid);

create unique index pg_publication_rel_prrelid_prpubid_index
    on pg_catalog.pg_publication_rel (prrelid, prpubid);

grant select on pg_catalog.pg_publication_rel to public;

create table information_schema.sql_features
(
    feature_id       information_schema.character_data,
    feature_name     information_schema.character_data,
    sub_feature_id   information_schema.character_data,
    sub_feature_name information_schema.character_data,
    is_supported     information_schema.yes_or_no,
    is_verified_by   information_schema.character_data,
    comments         information_schema.character_data
);

alter table information_schema.sql_features
    owner to postgres;

grant select on information_schema.sql_features to public;

create table information_schema.sql_implementation_info
(
    implementation_info_id   information_schema.character_data,
    implementation_info_name information_schema.character_data,
    integer_value            information_schema.cardinal_number,
    character_value          information_schema.character_data,
    comments                 information_schema.character_data
);

alter table information_schema.sql_implementation_info
    owner to postgres;

grant select on information_schema.sql_implementation_info to public;

create table information_schema.sql_languages
(
    sql_language_source               information_schema.character_data,
    sql_language_year                 information_schema.character_data,
    sql_language_conformance          information_schema.character_data,
    sql_language_integrity            information_schema.character_data,
    sql_language_implementation       information_schema.character_data,
    sql_language_binding_style        information_schema.character_data,
    sql_language_programming_language information_schema.character_data
);

alter table information_schema.sql_languages
    owner to postgres;

grant select on information_schema.sql_languages to public;

create table information_schema.sql_packages
(
    feature_id     information_schema.character_data,
    feature_name   information_schema.character_data,
    is_supported   information_schema.yes_or_no,
    is_verified_by information_schema.character_data,
    comments       information_schema.character_data
);

alter table information_schema.sql_packages
    owner to postgres;

grant select on information_schema.sql_packages to public;

create table information_schema.sql_parts
(
    feature_id     information_schema.character_data,
    feature_name   information_schema.character_data,
    is_supported   information_schema.yes_or_no,
    is_verified_by information_schema.character_data,
    comments       information_schema.character_data
);

alter table information_schema.sql_parts
    owner to postgres;

create table information_schema.sql_sizing
(
    sizing_id       information_schema.cardinal_number,
    sizing_name     information_schema.character_data,
    supported_value information_schema.cardinal_number,
    comments        information_schema.character_data
);

alter table information_schema.sql_sizing
    owner to postgres;

grant select on information_schema.sql_sizing to public;

create table information_schema.sql_sizing_profiles
(
    sizing_id      information_schema.cardinal_number,
    sizing_name    information_schema.character_data,
    profile_id     information_schema.character_data,
    required_value information_schema.cardinal_number,
    comments       information_schema.character_data
);

alter table information_schema.sql_sizing_profiles
    owner to postgres;

grant select on information_schema.sql_sizing_profiles to public;

create table member
(
    id    integer generated by default as identity
        primary key,
    email varchar(255),
    name  varchar(255)
);

alter table member
    owner to b105;

create table article
(
    id          integer generated by default as identity
        primary key,
    create_date timestamp,
    user_id     integer
        constraint fke2462tfh2jo2rts5g1lo9h0j
            references member
);

alter table article
    owner to b105;

create table answer
(
    id          integer generated by default as identity
        primary key,
    contents    varchar(255),
    img_url     varchar(255),
    question_id integer,
    state       varchar(255),
    article_id  integer
        constraint fkaqi89q0du4f7gbxt5fss0mqg2
            references article
);

alter table answer
    owner to b105;

create table authority
(
    id      integer generated by default as identity
        primary key,
    role    varchar(255),
    user_id integer
        constraint fktolshwvsxao34bc5frmbhj5hp
            references member
);

alter table authority
    owner to b105;

create table is_like
(
    id        integer generated by default as identity
        primary key,
    answer_id integer
        constraint fk4wjjq19ecrxwo9d4rnod88yt2
            references answer,
    user_id   integer
        constraint fk7j0modimpt629qjoy1b2jw9e6
            references member
);

alter table is_like
    owner to b105;

create table refresh_token
(
    id      integer      not null
        primary key,
    token   varchar(255) not null,
    user_id integer      not null
);

alter table refresh_token
    owner to b105;

create view pg_catalog.pg_roles
            (rolname, rolsuper, rolinherit, rolcreaterole, rolcreatedb, rolcanlogin, rolreplication, rolconnlimit,
             rolpassword, rolvaliduntil, rolbypassrls, rolconfig, oid)
as
SELECT pg_authid.rolname,
       pg_authid.rolsuper,
       pg_authid.rolinherit,
       pg_authid.rolcreaterole,
       pg_authid.rolcreatedb,
       pg_authid.rolcanlogin,
       pg_authid.rolreplication,
       pg_authid.rolconnlimit,
       '********'::text AS rolpassword,
       pg_authid.rolvaliduntil,
       pg_authid.rolbypassrls,
       s.setconfig      AS rolconfig,
       pg_authid.oid
FROM pg_authid
         LEFT JOIN pg_db_role_setting s ON pg_authid.oid = s.setrole AND s.setdatabase = 0::oid;

alter table pg_catalog.pg_roles
    owner to postgres;

grant select on pg_catalog.pg_roles to public;

create view pg_catalog.pg_shadow
            (usename, usesysid, usecreatedb, usesuper, userepl, usebypassrls, passwd, valuntil, useconfig) as
SELECT pg_authid.rolname        AS usename,
       pg_authid.oid            AS usesysid,
       pg_authid.rolcreatedb    AS usecreatedb,
       pg_authid.rolsuper       AS usesuper,
       pg_authid.rolreplication AS userepl,
       pg_authid.rolbypassrls   AS usebypassrls,
       pg_authid.rolpassword    AS passwd,
       pg_authid.rolvaliduntil  AS valuntil,
       s.setconfig              AS useconfig
FROM pg_authid
         LEFT JOIN pg_db_role_setting s ON pg_authid.oid = s.setrole AND s.setdatabase = 0::oid
WHERE pg_authid.rolcanlogin;

alter table pg_catalog.pg_shadow
    owner to postgres;

create view pg_catalog.pg_group(groname, grosysid, grolist) as
SELECT pg_authid.rolname                                   AS groname,
       pg_authid.oid                                       AS grosysid,
       ARRAY(SELECT pg_auth_members.member
             FROM pg_auth_members
             WHERE pg_auth_members.roleid = pg_authid.oid) AS grolist
FROM pg_authid
WHERE NOT pg_authid.rolcanlogin;

alter table pg_catalog.pg_group
    owner to postgres;

grant select on pg_catalog.pg_group to public;

create view pg_catalog.pg_user
            (usename, usesysid, usecreatedb, usesuper, userepl, usebypassrls, passwd, valuntil, useconfig) as
SELECT pg_shadow.usename,
       pg_shadow.usesysid,
       pg_shadow.usecreatedb,
       pg_shadow.usesuper,
       pg_shadow.userepl,
       pg_shadow.usebypassrls,
       '********'::text AS passwd,
       pg_shadow.valuntil,
       pg_shadow.useconfig
FROM pg_shadow;

alter table pg_catalog.pg_user
    owner to postgres;

grant select on pg_catalog.pg_user to public;

create view pg_catalog.pg_policies (schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check) as
SELECT n.nspname                                   AS schemaname,
       c.relname                                   AS tablename,
       pol.polname                                 AS policyname,
       CASE
           WHEN pol.polpermissive THEN 'PERMISSIVE'::text
           ELSE 'RESTRICTIVE'::text
           END                                     AS permissive,
       CASE
           WHEN pol.polroles = '{0}'::oid[] THEN string_to_array('public'::text, ''::text)::name[]
           ELSE ARRAY(SELECT pg_authid.rolname
                      FROM pg_authid
                      WHERE pg_authid.oid = ANY (pol.polroles)
                      ORDER BY pg_authid.rolname)
           END                                     AS roles,
       CASE pol.polcmd
           WHEN 'r'::"char" THEN 'SELECT'::text
           WHEN 'a'::"char" THEN 'INSERT'::text
           WHEN 'w'::"char" THEN 'UPDATE'::text
           WHEN 'd'::"char" THEN 'DELETE'::text
           WHEN '*'::"char" THEN 'ALL'::text
           ELSE NULL::text
           END                                     AS cmd,
       pg_get_expr(pol.polqual, pol.polrelid)      AS qual,
       pg_get_expr(pol.polwithcheck, pol.polrelid) AS with_check
FROM pg_policy pol
         JOIN pg_class c ON c.oid = pol.polrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace;

alter table pg_catalog.pg_policies
    owner to postgres;

grant select on pg_catalog.pg_policies to public;

create view pg_catalog.pg_rules(schemaname, tablename, rulename, definition) as
SELECT n.nspname             AS schemaname,
       c.relname             AS tablename,
       r.rulename,
       pg_get_ruledef(r.oid) AS definition
FROM pg_rewrite r
         JOIN pg_class c ON c.oid = r.ev_class
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE r.rulename <> '_RETURN'::name;

alter table pg_catalog.pg_rules
    owner to postgres;

grant select on pg_catalog.pg_rules to public;

create view pg_catalog.pg_views(schemaname, viewname, viewowner, definition) as
SELECT n.nspname                   AS schemaname,
       c.relname                   AS viewname,
       pg_get_userbyid(c.relowner) AS viewowner,
       pg_get_viewdef(c.oid)       AS definition
FROM pg_class c
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = 'v'::"char";

alter table pg_catalog.pg_views
    owner to postgres;

grant select on pg_catalog.pg_views to public;

create view pg_catalog.pg_tables
            (schemaname, tablename, tableowner, tablespace, hasindexes, hasrules, hastriggers, rowsecurity) as
SELECT n.nspname                   AS schemaname,
       c.relname                   AS tablename,
       pg_get_userbyid(c.relowner) AS tableowner,
       t.spcname                   AS tablespace,
       c.relhasindex               AS hasindexes,
       c.relhasrules               AS hasrules,
       c.relhastriggers            AS hastriggers,
       c.relrowsecurity            AS rowsecurity
FROM pg_class c
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
         LEFT JOIN pg_tablespace t ON t.oid = c.reltablespace
WHERE c.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]);

alter table pg_catalog.pg_tables
    owner to postgres;

grant select on pg_catalog.pg_tables to public;

create view pg_catalog.pg_matviews
            (schemaname, matviewname, matviewowner, tablespace, hasindexes, ispopulated, definition) as
SELECT n.nspname                   AS schemaname,
       c.relname                   AS matviewname,
       pg_get_userbyid(c.relowner) AS matviewowner,
       t.spcname                   AS tablespace,
       c.relhasindex               AS hasindexes,
       c.relispopulated            AS ispopulated,
       pg_get_viewdef(c.oid)       AS definition
FROM pg_class c
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
         LEFT JOIN pg_tablespace t ON t.oid = c.reltablespace
WHERE c.relkind = 'm'::"char";

alter table pg_catalog.pg_matviews
    owner to postgres;

grant select on pg_catalog.pg_matviews to public;

create view pg_catalog.pg_indexes(schemaname, tablename, indexname, tablespace, indexdef) as
SELECT n.nspname              AS schemaname,
       c.relname              AS tablename,
       i.relname              AS indexname,
       t.spcname              AS tablespace,
       pg_get_indexdef(i.oid) AS indexdef
FROM pg_index x
         JOIN pg_class c ON c.oid = x.indrelid
         JOIN pg_class i ON i.oid = x.indexrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
         LEFT JOIN pg_tablespace t ON t.oid = i.reltablespace
WHERE (c.relkind = ANY (ARRAY ['r'::"char", 'm'::"char", 'p'::"char"]))
  AND (i.relkind = ANY (ARRAY ['i'::"char", 'I'::"char"]));

alter table pg_catalog.pg_indexes
    owner to postgres;

grant select on pg_catalog.pg_indexes to public;

create view pg_catalog.pg_sequences
            (schemaname, sequencename, sequenceowner, data_type, start_value, min_value, max_value, increment_by, cycle,
             cache_size, last_value)
as
SELECT n.nspname                   AS schemaname,
       c.relname                   AS sequencename,
       pg_get_userbyid(c.relowner) AS sequenceowner,
       s.seqtypid::regtype         AS data_type,
       s.seqstart                  AS start_value,
       s.seqmin                    AS min_value,
       s.seqmax                    AS max_value,
       s.seqincrement              AS increment_by,
       s.seqcycle                  AS cycle,
       s.seqcache                  AS cache_size,
       CASE
           WHEN has_sequence_privilege(c.oid, 'SELECT,USAGE'::text) THEN pg_sequence_last_value(c.oid::regclass)
           ELSE NULL::bigint
           END                     AS last_value
FROM pg_sequence s
         JOIN pg_class c ON c.oid = s.seqrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE NOT pg_is_other_temp_schema(n.oid)
  AND c.relkind = 'S'::"char";

alter table pg_catalog.pg_sequences
    owner to postgres;

grant select on pg_catalog.pg_sequences to public;

create view pg_catalog.pg_stats
            (schemaname, tablename, attname, inherited, null_frac, avg_width, n_distinct, most_common_vals,
             most_common_freqs, histogram_bounds, correlation, most_common_elems, most_common_elem_freqs,
             elem_count_histogram)
as
SELECT n.nspname     AS schemaname,
       c.relname     AS tablename,
       a.attname,
       s.stainherit  AS inherited,
       s.stanullfrac AS null_frac,
       s.stawidth    AS avg_width,
       s.stadistinct AS n_distinct,
       CASE
           WHEN s.stakind1 = 1 THEN s.stavalues1
           WHEN s.stakind2 = 1 THEN s.stavalues2
           WHEN s.stakind3 = 1 THEN s.stavalues3
           WHEN s.stakind4 = 1 THEN s.stavalues4
           WHEN s.stakind5 = 1 THEN s.stavalues5
           ELSE NULL::anyarray
           END       AS most_common_vals,
       CASE
           WHEN s.stakind1 = 1 THEN s.stanumbers1
           WHEN s.stakind2 = 1 THEN s.stanumbers2
           WHEN s.stakind3 = 1 THEN s.stanumbers3
           WHEN s.stakind4 = 1 THEN s.stanumbers4
           WHEN s.stakind5 = 1 THEN s.stanumbers5
           ELSE NULL::real[]
           END       AS most_common_freqs,
       CASE
           WHEN s.stakind1 = 2 THEN s.stavalues1
           WHEN s.stakind2 = 2 THEN s.stavalues2
           WHEN s.stakind3 = 2 THEN s.stavalues3
           WHEN s.stakind4 = 2 THEN s.stavalues4
           WHEN s.stakind5 = 2 THEN s.stavalues5
           ELSE NULL::anyarray
           END       AS histogram_bounds,
       CASE
           WHEN s.stakind1 = 3 THEN s.stanumbers1[1]
           WHEN s.stakind2 = 3 THEN s.stanumbers2[1]
           WHEN s.stakind3 = 3 THEN s.stanumbers3[1]
           WHEN s.stakind4 = 3 THEN s.stanumbers4[1]
           WHEN s.stakind5 = 3 THEN s.stanumbers5[1]
           ELSE NULL::real
           END       AS correlation,
       CASE
           WHEN s.stakind1 = 4 THEN s.stavalues1
           WHEN s.stakind2 = 4 THEN s.stavalues2
           WHEN s.stakind3 = 4 THEN s.stavalues3
           WHEN s.stakind4 = 4 THEN s.stavalues4
           WHEN s.stakind5 = 4 THEN s.stavalues5
           ELSE NULL::anyarray
           END       AS most_common_elems,
       CASE
           WHEN s.stakind1 = 4 THEN s.stanumbers1
           WHEN s.stakind2 = 4 THEN s.stanumbers2
           WHEN s.stakind3 = 4 THEN s.stanumbers3
           WHEN s.stakind4 = 4 THEN s.stanumbers4
           WHEN s.stakind5 = 4 THEN s.stanumbers5
           ELSE NULL::real[]
           END       AS most_common_elem_freqs,
       CASE
           WHEN s.stakind1 = 5 THEN s.stanumbers1
           WHEN s.stakind2 = 5 THEN s.stanumbers2
           WHEN s.stakind3 = 5 THEN s.stanumbers3
           WHEN s.stakind4 = 5 THEN s.stanumbers4
           WHEN s.stakind5 = 5 THEN s.stanumbers5
           ELSE NULL::real[]
           END       AS elem_count_histogram
FROM pg_statistic s
         JOIN pg_class c ON c.oid = s.starelid
         JOIN pg_attribute a ON c.oid = a.attrelid AND a.attnum = s.staattnum
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE NOT a.attisdropped
  AND has_column_privilege(c.oid, a.attnum, 'select'::text)
  AND (c.relrowsecurity = false OR NOT row_security_active(c.oid));

alter table pg_catalog.pg_stats
    owner to postgres;

grant select on pg_catalog.pg_stats to public;

create view pg_catalog.pg_stats_ext
            (schemaname, tablename, statistics_schemaname, statistics_name, statistics_owner, attnames, kinds,
             n_distinct, dependencies, most_common_vals, most_common_val_nulls, most_common_freqs,
             most_common_base_freqs)
as
SELECT cn.nspname                                                                   AS schemaname,
       c.relname                                                                    AS tablename,
       sn.nspname                                                                   AS statistics_schemaname,
       s.stxname                                                                    AS statistics_name,
       pg_get_userbyid(s.stxowner)                                                  AS statistics_owner,
       (SELECT array_agg(a.attname ORDER BY a.attnum) AS array_agg
        FROM unnest(s.stxkeys) k(k)
                 JOIN pg_attribute a ON a.attrelid = s.stxrelid AND a.attnum = k.k) AS attnames,
       s.stxkind                                                                    AS kinds,
       sd.stxdndistinct                                                             AS n_distinct,
       sd.stxddependencies                                                          AS dependencies,
       m.most_common_vals,
       m.most_common_val_nulls,
       m.most_common_freqs,
       m.most_common_base_freqs
FROM pg_statistic_ext s
         JOIN pg_class c ON c.oid = s.stxrelid
         JOIN pg_statistic_ext_data sd ON s.oid = sd.stxoid
         LEFT JOIN pg_namespace cn ON cn.oid = c.relnamespace
         LEFT JOIN pg_namespace sn ON sn.oid = s.stxnamespace
         LEFT JOIN LATERAL ( SELECT array_agg(pg_mcv_list_items."values")       AS most_common_vals,
                                    array_agg(pg_mcv_list_items.nulls)          AS most_common_val_nulls,
                                    array_agg(pg_mcv_list_items.frequency)      AS most_common_freqs,
                                    array_agg(pg_mcv_list_items.base_frequency) AS most_common_base_freqs
                             FROM pg_mcv_list_items(sd.stxdmcv) pg_mcv_list_items(index, "values", nulls, frequency, base_frequency)) m
                   ON sd.stxdmcv IS NOT NULL
WHERE NOT (EXISTS(SELECT 1
                  FROM unnest(s.stxkeys) k(k)
                           JOIN pg_attribute a ON a.attrelid = s.stxrelid AND a.attnum = k.k
                  WHERE NOT has_column_privilege(c.oid, a.attnum, 'select'::text)))
  AND (c.relrowsecurity = false OR NOT row_security_active(c.oid));

alter table pg_catalog.pg_stats_ext
    owner to postgres;

grant select on pg_catalog.pg_stats_ext to public;

create view pg_catalog.pg_publication_tables(pubname, schemaname, tablename) as
SELECT p.pubname,
       n.nspname AS schemaname,
       c.relname AS tablename
FROM pg_publication p,
     LATERAL pg_get_publication_tables(p.pubname::text) gpt(relid),
     pg_class c
         JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.oid = gpt.relid;

alter table pg_catalog.pg_publication_tables
    owner to postgres;

grant select on pg_catalog.pg_publication_tables to public;

create view pg_catalog.pg_locks
            (locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid,
             virtualtransaction, pid, mode, granted, fastpath)
as
SELECT l.locktype,
       l.database,
       l.relation,
       l.page,
       l.tuple,
       l.virtualxid,
       l.transactionid,
       l.classid,
       l.objid,
       l.objsubid,
       l.virtualtransaction,
       l.pid,
       l.mode,
       l.granted,
       l.fastpath
FROM pg_lock_status() l(locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid,
                        virtualtransaction, pid, mode, granted, fastpath);

alter table pg_catalog.pg_locks
    owner to postgres;

grant select on pg_catalog.pg_locks to public;

create view pg_catalog.pg_cursors(name, statement, is_holdable, is_binary, is_scrollable, creation_time) as
SELECT c.name,
       c.statement,
       c.is_holdable,
       c.is_binary,
       c.is_scrollable,
       c.creation_time
FROM pg_cursor() c(name, statement, is_holdable, is_binary, is_scrollable, creation_time);

alter table pg_catalog.pg_cursors
    owner to postgres;

grant select on pg_catalog.pg_cursors to public;

create view pg_catalog.pg_available_extensions(name, default_version, installed_version, comment) as
SELECT e.name,
       e.default_version,
       x.extversion AS installed_version,
       e.comment
FROM pg_available_extensions() e(name, default_version, comment)
         LEFT JOIN pg_extension x ON e.name = x.extname;

alter table pg_catalog.pg_available_extensions
    owner to postgres;

grant select on pg_catalog.pg_available_extensions to public;

create view pg_catalog.pg_available_extension_versions
            (name, version, installed, superuser, relocatable, schema, requires, comment) as
SELECT e.name,
       e.version,
       x.extname IS NOT NULL AS installed,
       e.superuser,
       e.relocatable,
       e.schema,
       e.requires,
       e.comment
FROM pg_available_extension_versions() e(name, version, superuser, relocatable, schema, requires, comment)
         LEFT JOIN pg_extension x ON e.name = x.extname AND e.version = x.extversion;

alter table pg_catalog.pg_available_extension_versions
    owner to postgres;

grant select on pg_catalog.pg_available_extension_versions to public;

create view pg_catalog.pg_prepared_xacts(transaction, gid, prepared, owner, database) as
SELECT p.transaction,
       p.gid,
       p.prepared,
       u.rolname AS owner,
       d.datname AS database
FROM pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid)
         LEFT JOIN pg_authid u ON p.ownerid = u.oid
         LEFT JOIN pg_database d ON p.dbid = d.oid;

alter table pg_catalog.pg_prepared_xacts
    owner to postgres;

grant select on pg_catalog.pg_prepared_xacts to public;

create view pg_catalog.pg_prepared_statements(name, statement, prepare_time, parameter_types, from_sql) as
SELECT p.name,
       p.statement,
       p.prepare_time,
       p.parameter_types,
       p.from_sql
FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, from_sql);

alter table pg_catalog.pg_prepared_statements
    owner to postgres;

grant select on pg_catalog.pg_prepared_statements to public;

create view pg_catalog.pg_seclabels (objoid, classoid, objsubid, objtype, objnamespace, objname, provider, label) as
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       CASE
           WHEN rel.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]) THEN 'table'::text
           WHEN rel.relkind = 'v'::"char" THEN 'view'::text
           WHEN rel.relkind = 'm'::"char" THEN 'materialized view'::text
           WHEN rel.relkind = 'S'::"char" THEN 'sequence'::text
           WHEN rel.relkind = 'f'::"char" THEN 'foreign table'::text
           ELSE NULL::text
           END          AS objtype,
       rel.relnamespace AS objnamespace,
       CASE
           WHEN pg_table_is_visible(rel.oid) THEN quote_ident(rel.relname::text)
           ELSE (quote_ident(nsp.nspname::text) || '.'::text) || quote_ident(rel.relname::text)
           END          AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_class rel ON l.classoid = rel.tableoid AND l.objoid = rel.oid
         JOIN pg_namespace nsp ON rel.relnamespace = nsp.oid
WHERE l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       'column'::text                                     AS objtype,
       rel.relnamespace                                   AS objnamespace,
       (
               CASE
                   WHEN pg_table_is_visible(rel.oid) THEN quote_ident(rel.relname::text)
                   ELSE (quote_ident(nsp.nspname::text) || '.'::text) || quote_ident(rel.relname::text)
                   END || '.'::text) || att.attname::text AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_class rel ON l.classoid = rel.tableoid AND l.objoid = rel.oid
         JOIN pg_attribute att ON rel.oid = att.attrelid AND l.objsubid = att.attnum
         JOIN pg_namespace nsp ON rel.relnamespace = nsp.oid
WHERE l.objsubid <> 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       CASE pro.prokind
           WHEN 'a'::"char" THEN 'aggregate'::text
           WHEN 'f'::"char" THEN 'function'::text
           WHEN 'p'::"char" THEN 'procedure'::text
           WHEN 'w'::"char" THEN 'window'::text
           ELSE NULL::text
           END                                                                            AS objtype,
       pro.pronamespace                                                                   AS objnamespace,
       ((
                CASE
                    WHEN pg_function_is_visible(pro.oid) THEN quote_ident(pro.proname::text)
                    ELSE (quote_ident(nsp.nspname::text) || '.'::text) || quote_ident(pro.proname::text)
                    END || '('::text) || pg_get_function_arguments(pro.oid)) || ')'::text AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_proc pro ON l.classoid = pro.tableoid AND l.objoid = pro.oid
         JOIN pg_namespace nsp ON pro.pronamespace = nsp.oid
WHERE l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       CASE
           WHEN typ.typtype = 'd'::"char" THEN 'domain'::text
           ELSE 'type'::text
           END          AS objtype,
       typ.typnamespace AS objnamespace,
       CASE
           WHEN pg_type_is_visible(typ.oid) THEN quote_ident(typ.typname::text)
           ELSE (quote_ident(nsp.nspname::text) || '.'::text) || quote_ident(typ.typname::text)
           END          AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_type typ ON l.classoid = typ.tableoid AND l.objoid = typ.oid
         JOIN pg_namespace nsp ON typ.typnamespace = nsp.oid
WHERE l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       'large object'::text AS objtype,
       NULL::oid            AS objnamespace,
       l.objoid::text       AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_largeobject_metadata lom ON l.objoid = lom.oid
WHERE l.classoid = 'pg_largeobject'::regclass::oid
  AND l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       'language'::text               AS objtype,
       NULL::oid                      AS objnamespace,
       quote_ident(lan.lanname::text) AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_language lan ON l.classoid = lan.tableoid AND l.objoid = lan.oid
WHERE l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       'schema'::text                 AS objtype,
       nsp.oid                        AS objnamespace,
       quote_ident(nsp.nspname::text) AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_namespace nsp ON l.classoid = nsp.tableoid AND l.objoid = nsp.oid
WHERE l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       'event trigger'::text          AS objtype,
       NULL::oid                      AS objnamespace,
       quote_ident(evt.evtname::text) AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_event_trigger evt ON l.classoid = evt.tableoid AND l.objoid = evt.oid
WHERE l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       'publication'::text          AS objtype,
       NULL::oid                    AS objnamespace,
       quote_ident(p.pubname::text) AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_publication p ON l.classoid = p.tableoid AND l.objoid = p.oid
WHERE l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       0                            AS objsubid,
       'subscription'::text         AS objtype,
       NULL::oid                    AS objnamespace,
       quote_ident(s.subname::text) AS objname,
       l.provider,
       l.label
FROM pg_shseclabel l
         JOIN pg_subscription s ON l.classoid = s.tableoid AND l.objoid = s.oid
UNION ALL
SELECT l.objoid,
       l.classoid,
       0                              AS objsubid,
       'database'::text               AS objtype,
       NULL::oid                      AS objnamespace,
       quote_ident(dat.datname::text) AS objname,
       l.provider,
       l.label
FROM pg_shseclabel l
         JOIN pg_database dat ON l.classoid = dat.tableoid AND l.objoid = dat.oid
UNION ALL
SELECT l.objoid,
       l.classoid,
       0                              AS objsubid,
       'tablespace'::text             AS objtype,
       NULL::oid                      AS objnamespace,
       quote_ident(spc.spcname::text) AS objname,
       l.provider,
       l.label
FROM pg_shseclabel l
         JOIN pg_tablespace spc ON l.classoid = spc.tableoid AND l.objoid = spc.oid
UNION ALL
SELECT l.objoid,
       l.classoid,
       0                              AS objsubid,
       'role'::text                   AS objtype,
       NULL::oid                      AS objnamespace,
       quote_ident(rol.rolname::text) AS objname,
       l.provider,
       l.label
FROM pg_shseclabel l
         JOIN pg_authid rol ON l.classoid = rol.tableoid AND l.objoid = rol.oid;

alter table pg_catalog.pg_seclabels
    owner to postgres;

grant select on pg_catalog.pg_seclabels to public;

create view pg_catalog.pg_settings
            (name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val, max_val,
             enumvals, boot_val, reset_val, sourcefile, sourceline, pending_restart)
as
SELECT a.name,
       a.setting,
       a.unit,
       a.category,
       a.short_desc,
       a.extra_desc,
       a.context,
       a.vartype,
       a.source,
       a.min_val,
       a.max_val,
       a.enumvals,
       a.boot_val,
       a.reset_val,
       a.sourcefile,
       a.sourceline,
       a.pending_restart
FROM pg_show_all_settings() a(name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val,
                              max_val, enumvals, boot_val, reset_val, sourcefile, sourceline, pending_restart);

alter table pg_catalog.pg_settings
    owner to postgres;

CREATE RULE pg_settings_u AS
    ON UPDATE TO pg_settings
   WHERE new.name = old.name DO  SELECT set_config(old.name, new.setting, false) AS set_config;

CREATE RULE pg_settings_n AS
    ON UPDATE TO pg_settings DO INSTEAD NOTHING;

grant select, update on pg_catalog.pg_settings to public;

create view pg_catalog.pg_file_settings(sourcefile, sourceline, seqno, name, setting, applied, error) as
SELECT a.sourcefile,
       a.sourceline,
       a.seqno,
       a.name,
       a.setting,
       a.applied,
       a.error
FROM pg_show_all_file_settings() a(sourcefile, sourceline, seqno, name, setting, applied, error);

alter table pg_catalog.pg_file_settings
    owner to postgres;

create view pg_catalog.pg_hba_file_rules
            (line_number, type, database, user_name, address, netmask, auth_method, options, error) as
SELECT a.line_number,
       a.type,
       a.database,
       a.user_name,
       a.address,
       a.netmask,
       a.auth_method,
       a.options,
       a.error
FROM pg_hba_file_rules() a(line_number, type, database, user_name, address, netmask, auth_method, options, error);

alter table pg_catalog.pg_hba_file_rules
    owner to postgres;

create view pg_catalog.pg_timezone_abbrevs(abbrev, utc_offset, is_dst) as
SELECT pg_timezone_abbrevs.abbrev,
       pg_timezone_abbrevs.utc_offset,
       pg_timezone_abbrevs.is_dst
FROM pg_timezone_abbrevs() pg_timezone_abbrevs(abbrev, utc_offset, is_dst);

alter table pg_catalog.pg_timezone_abbrevs
    owner to postgres;

grant select on pg_catalog.pg_timezone_abbrevs to public;

create view pg_catalog.pg_timezone_names(name, abbrev, utc_offset, is_dst) as
SELECT pg_timezone_names.name,
       pg_timezone_names.abbrev,
       pg_timezone_names.utc_offset,
       pg_timezone_names.is_dst
FROM pg_timezone_names() pg_timezone_names(name, abbrev, utc_offset, is_dst);

alter table pg_catalog.pg_timezone_names
    owner to postgres;

grant select on pg_catalog.pg_timezone_names to public;

create view pg_catalog.pg_config(name, setting) as
SELECT pg_config.name,
       pg_config.setting
FROM pg_config() pg_config(name, setting);

alter table pg_catalog.pg_config
    owner to postgres;

create view pg_catalog.pg_stat_all_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, last_vacuum, last_autovacuum,
             last_analyze, last_autoanalyze, vacuum_count, autovacuum_count, analyze_count, autoanalyze_count)
as
SELECT c.oid                                                                                     AS relid,
       n.nspname                                                                                 AS schemaname,
       c.relname,
       pg_stat_get_numscans(c.oid)                                                               AS seq_scan,
       pg_stat_get_tuples_returned(c.oid)                                                        AS seq_tup_read,
       sum(pg_stat_get_numscans(i.indexrelid))::bigint                                           AS idx_scan,
       sum(pg_stat_get_tuples_fetched(i.indexrelid))::bigint + pg_stat_get_tuples_fetched(c.oid) AS idx_tup_fetch,
       pg_stat_get_tuples_inserted(c.oid)                                                        AS n_tup_ins,
       pg_stat_get_tuples_updated(c.oid)                                                         AS n_tup_upd,
       pg_stat_get_tuples_deleted(c.oid)                                                         AS n_tup_del,
       pg_stat_get_tuples_hot_updated(c.oid)                                                     AS n_tup_hot_upd,
       pg_stat_get_live_tuples(c.oid)                                                            AS n_live_tup,
       pg_stat_get_dead_tuples(c.oid)                                                            AS n_dead_tup,
       pg_stat_get_mod_since_analyze(c.oid)                                                      AS n_mod_since_analyze,
       pg_stat_get_last_vacuum_time(c.oid)                                                       AS last_vacuum,
       pg_stat_get_last_autovacuum_time(c.oid)                                                   AS last_autovacuum,
       pg_stat_get_last_analyze_time(c.oid)                                                      AS last_analyze,
       pg_stat_get_last_autoanalyze_time(c.oid)                                                  AS last_autoanalyze,
       pg_stat_get_vacuum_count(c.oid)                                                           AS vacuum_count,
       pg_stat_get_autovacuum_count(c.oid)                                                       AS autovacuum_count,
       pg_stat_get_analyze_count(c.oid)                                                          AS analyze_count,
       pg_stat_get_autoanalyze_count(c.oid)                                                      AS autoanalyze_count
FROM pg_class c
         LEFT JOIN pg_index i ON c.oid = i.indrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char"])
GROUP BY c.oid, n.nspname, c.relname;

alter table pg_catalog.pg_stat_all_tables
    owner to postgres;

grant select on pg_catalog.pg_stat_all_tables to public;

create view pg_catalog.pg_stat_xact_all_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd)
as
SELECT c.oid                                                                                               AS relid,
       n.nspname                                                                                           AS schemaname,
       c.relname,
       pg_stat_get_xact_numscans(c.oid)                                                                    AS seq_scan,
       pg_stat_get_xact_tuples_returned(c.oid)                                                             AS seq_tup_read,
       sum(pg_stat_get_xact_numscans(i.indexrelid))::bigint                                                AS idx_scan,
       sum(pg_stat_get_xact_tuples_fetched(i.indexrelid))::bigint +
       pg_stat_get_xact_tuples_fetched(c.oid)                                                              AS idx_tup_fetch,
       pg_stat_get_xact_tuples_inserted(c.oid)                                                             AS n_tup_ins,
       pg_stat_get_xact_tuples_updated(c.oid)                                                              AS n_tup_upd,
       pg_stat_get_xact_tuples_deleted(c.oid)                                                              AS n_tup_del,
       pg_stat_get_xact_tuples_hot_updated(c.oid)                                                          AS n_tup_hot_upd
FROM pg_class c
         LEFT JOIN pg_index i ON c.oid = i.indrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char"])
GROUP BY c.oid, n.nspname, c.relname;

alter table pg_catalog.pg_stat_xact_all_tables
    owner to postgres;

grant select on pg_catalog.pg_stat_xact_all_tables to public;

create view pg_catalog.pg_stat_sys_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, last_vacuum, last_autovacuum,
             last_analyze, last_autoanalyze, vacuum_count, autovacuum_count, analyze_count, autoanalyze_count)
as
SELECT pg_stat_all_tables.relid,
       pg_stat_all_tables.schemaname,
       pg_stat_all_tables.relname,
       pg_stat_all_tables.seq_scan,
       pg_stat_all_tables.seq_tup_read,
       pg_stat_all_tables.idx_scan,
       pg_stat_all_tables.idx_tup_fetch,
       pg_stat_all_tables.n_tup_ins,
       pg_stat_all_tables.n_tup_upd,
       pg_stat_all_tables.n_tup_del,
       pg_stat_all_tables.n_tup_hot_upd,
       pg_stat_all_tables.n_live_tup,
       pg_stat_all_tables.n_dead_tup,
       pg_stat_all_tables.n_mod_since_analyze,
       pg_stat_all_tables.last_vacuum,
       pg_stat_all_tables.last_autovacuum,
       pg_stat_all_tables.last_analyze,
       pg_stat_all_tables.last_autoanalyze,
       pg_stat_all_tables.vacuum_count,
       pg_stat_all_tables.autovacuum_count,
       pg_stat_all_tables.analyze_count,
       pg_stat_all_tables.autoanalyze_count
FROM pg_stat_all_tables
WHERE (pg_stat_all_tables.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
   OR pg_stat_all_tables.schemaname ~ '^pg_toast'::text;

alter table pg_catalog.pg_stat_sys_tables
    owner to postgres;

grant select on pg_catalog.pg_stat_sys_tables to public;

create view pg_catalog.pg_stat_xact_sys_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd)
as
SELECT pg_stat_xact_all_tables.relid,
       pg_stat_xact_all_tables.schemaname,
       pg_stat_xact_all_tables.relname,
       pg_stat_xact_all_tables.seq_scan,
       pg_stat_xact_all_tables.seq_tup_read,
       pg_stat_xact_all_tables.idx_scan,
       pg_stat_xact_all_tables.idx_tup_fetch,
       pg_stat_xact_all_tables.n_tup_ins,
       pg_stat_xact_all_tables.n_tup_upd,
       pg_stat_xact_all_tables.n_tup_del,
       pg_stat_xact_all_tables.n_tup_hot_upd
FROM pg_stat_xact_all_tables
WHERE (pg_stat_xact_all_tables.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
   OR pg_stat_xact_all_tables.schemaname ~ '^pg_toast'::text;

alter table pg_catalog.pg_stat_xact_sys_tables
    owner to postgres;

grant select on pg_catalog.pg_stat_xact_sys_tables to public;

create view pg_catalog.pg_stat_user_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, last_vacuum, last_autovacuum,
             last_analyze, last_autoanalyze, vacuum_count, autovacuum_count, analyze_count, autoanalyze_count)
as
SELECT pg_stat_all_tables.relid,
       pg_stat_all_tables.schemaname,
       pg_stat_all_tables.relname,
       pg_stat_all_tables.seq_scan,
       pg_stat_all_tables.seq_tup_read,
       pg_stat_all_tables.idx_scan,
       pg_stat_all_tables.idx_tup_fetch,
       pg_stat_all_tables.n_tup_ins,
       pg_stat_all_tables.n_tup_upd,
       pg_stat_all_tables.n_tup_del,
       pg_stat_all_tables.n_tup_hot_upd,
       pg_stat_all_tables.n_live_tup,
       pg_stat_all_tables.n_dead_tup,
       pg_stat_all_tables.n_mod_since_analyze,
       pg_stat_all_tables.last_vacuum,
       pg_stat_all_tables.last_autovacuum,
       pg_stat_all_tables.last_analyze,
       pg_stat_all_tables.last_autoanalyze,
       pg_stat_all_tables.vacuum_count,
       pg_stat_all_tables.autovacuum_count,
       pg_stat_all_tables.analyze_count,
       pg_stat_all_tables.autoanalyze_count
FROM pg_stat_all_tables
WHERE (pg_stat_all_tables.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
  AND pg_stat_all_tables.schemaname !~ '^pg_toast'::text;

alter table pg_catalog.pg_stat_user_tables
    owner to postgres;

grant select on pg_catalog.pg_stat_user_tables to public;

create view pg_catalog.pg_stat_xact_user_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd)
as
SELECT pg_stat_xact_all_tables.relid,
       pg_stat_xact_all_tables.schemaname,
       pg_stat_xact_all_tables.relname,
       pg_stat_xact_all_tables.seq_scan,
       pg_stat_xact_all_tables.seq_tup_read,
       pg_stat_xact_all_tables.idx_scan,
       pg_stat_xact_all_tables.idx_tup_fetch,
       pg_stat_xact_all_tables.n_tup_ins,
       pg_stat_xact_all_tables.n_tup_upd,
       pg_stat_xact_all_tables.n_tup_del,
       pg_stat_xact_all_tables.n_tup_hot_upd
FROM pg_stat_xact_all_tables
WHERE (pg_stat_xact_all_tables.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
  AND pg_stat_xact_all_tables.schemaname !~ '^pg_toast'::text;

alter table pg_catalog.pg_stat_xact_user_tables
    owner to postgres;

grant select on pg_catalog.pg_stat_xact_user_tables to public;

create view pg_catalog.pg_statio_all_tables
            (relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read,
             toast_blks_hit, tidx_blks_read, tidx_blks_hit)
as
SELECT c.oid                                                                                        AS relid,
       n.nspname                                                                                    AS schemaname,
       c.relname,
       pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)                            AS heap_blks_read,
       pg_stat_get_blocks_hit(c.oid)                                                                AS heap_blks_hit,
       sum(pg_stat_get_blocks_fetched(i.indexrelid) - pg_stat_get_blocks_hit(i.indexrelid))::bigint AS idx_blks_read,
       sum(pg_stat_get_blocks_hit(i.indexrelid))::bigint                                            AS idx_blks_hit,
       pg_stat_get_blocks_fetched(t.oid) - pg_stat_get_blocks_hit(t.oid)                            AS toast_blks_read,
       pg_stat_get_blocks_hit(t.oid)                                                                AS toast_blks_hit,
       sum(pg_stat_get_blocks_fetched(x.indexrelid) - pg_stat_get_blocks_hit(x.indexrelid))::bigint AS tidx_blks_read,
       sum(pg_stat_get_blocks_hit(x.indexrelid))::bigint                                            AS tidx_blks_hit
FROM pg_class c
         LEFT JOIN pg_index i ON c.oid = i.indrelid
         LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
         LEFT JOIN pg_index x ON t.oid = x.indrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char"])
GROUP BY c.oid, n.nspname, c.relname, t.oid, x.indrelid;

alter table pg_catalog.pg_statio_all_tables
    owner to postgres;

grant select on pg_catalog.pg_statio_all_tables to public;

create view pg_catalog.pg_statio_sys_tables
            (relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read,
             toast_blks_hit, tidx_blks_read, tidx_blks_hit)
as
SELECT pg_statio_all_tables.relid,
       pg_statio_all_tables.schemaname,
       pg_statio_all_tables.relname,
       pg_statio_all_tables.heap_blks_read,
       pg_statio_all_tables.heap_blks_hit,
       pg_statio_all_tables.idx_blks_read,
       pg_statio_all_tables.idx_blks_hit,
       pg_statio_all_tables.toast_blks_read,
       pg_statio_all_tables.toast_blks_hit,
       pg_statio_all_tables.tidx_blks_read,
       pg_statio_all_tables.tidx_blks_hit
FROM pg_statio_all_tables
WHERE (pg_statio_all_tables.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
   OR pg_statio_all_tables.schemaname ~ '^pg_toast'::text;

alter table pg_catalog.pg_statio_sys_tables
    owner to postgres;

grant select on pg_catalog.pg_statio_sys_tables to public;

create view pg_catalog.pg_statio_user_tables
            (relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read,
             toast_blks_hit, tidx_blks_read, tidx_blks_hit)
as
SELECT pg_statio_all_tables.relid,
       pg_statio_all_tables.schemaname,
       pg_statio_all_tables.relname,
       pg_statio_all_tables.heap_blks_read,
       pg_statio_all_tables.heap_blks_hit,
       pg_statio_all_tables.idx_blks_read,
       pg_statio_all_tables.idx_blks_hit,
       pg_statio_all_tables.toast_blks_read,
       pg_statio_all_tables.toast_blks_hit,
       pg_statio_all_tables.tidx_blks_read,
       pg_statio_all_tables.tidx_blks_hit
FROM pg_statio_all_tables
WHERE (pg_statio_all_tables.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
  AND pg_statio_all_tables.schemaname !~ '^pg_toast'::text;

alter table pg_catalog.pg_statio_user_tables
    owner to postgres;

grant select on pg_catalog.pg_statio_user_tables to public;

create view pg_catalog.pg_stat_all_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch) as
SELECT c.oid                              AS relid,
       i.oid                              AS indexrelid,
       n.nspname                          AS schemaname,
       c.relname,
       i.relname                          AS indexrelname,
       pg_stat_get_numscans(i.oid)        AS idx_scan,
       pg_stat_get_tuples_returned(i.oid) AS idx_tup_read,
       pg_stat_get_tuples_fetched(i.oid)  AS idx_tup_fetch
FROM pg_class c
         JOIN pg_index x ON c.oid = x.indrelid
         JOIN pg_class i ON i.oid = x.indexrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char"]);

alter table pg_catalog.pg_stat_all_indexes
    owner to postgres;

grant select on pg_catalog.pg_stat_all_indexes to public;

create view pg_catalog.pg_stat_sys_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch) as
SELECT pg_stat_all_indexes.relid,
       pg_stat_all_indexes.indexrelid,
       pg_stat_all_indexes.schemaname,
       pg_stat_all_indexes.relname,
       pg_stat_all_indexes.indexrelname,
       pg_stat_all_indexes.idx_scan,
       pg_stat_all_indexes.idx_tup_read,
       pg_stat_all_indexes.idx_tup_fetch
FROM pg_stat_all_indexes
WHERE (pg_stat_all_indexes.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
   OR pg_stat_all_indexes.schemaname ~ '^pg_toast'::text;

alter table pg_catalog.pg_stat_sys_indexes
    owner to postgres;

grant select on pg_catalog.pg_stat_sys_indexes to public;

create view pg_catalog.pg_stat_user_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch) as
SELECT pg_stat_all_indexes.relid,
       pg_stat_all_indexes.indexrelid,
       pg_stat_all_indexes.schemaname,
       pg_stat_all_indexes.relname,
       pg_stat_all_indexes.indexrelname,
       pg_stat_all_indexes.idx_scan,
       pg_stat_all_indexes.idx_tup_read,
       pg_stat_all_indexes.idx_tup_fetch
FROM pg_stat_all_indexes
WHERE (pg_stat_all_indexes.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
  AND pg_stat_all_indexes.schemaname !~ '^pg_toast'::text;

alter table pg_catalog.pg_stat_user_indexes
    owner to postgres;

grant select on pg_catalog.pg_stat_user_indexes to public;

create view pg_catalog.pg_statio_all_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read, idx_blks_hit) as
SELECT c.oid                                                             AS relid,
       i.oid                                                             AS indexrelid,
       n.nspname                                                         AS schemaname,
       c.relname,
       i.relname                                                         AS indexrelname,
       pg_stat_get_blocks_fetched(i.oid) - pg_stat_get_blocks_hit(i.oid) AS idx_blks_read,
       pg_stat_get_blocks_hit(i.oid)                                     AS idx_blks_hit
FROM pg_class c
         JOIN pg_index x ON c.oid = x.indrelid
         JOIN pg_class i ON i.oid = x.indexrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char"]);

alter table pg_catalog.pg_statio_all_indexes
    owner to postgres;

grant select on pg_catalog.pg_statio_all_indexes to public;

create view pg_catalog.pg_statio_sys_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read, idx_blks_hit) as
SELECT pg_statio_all_indexes.relid,
       pg_statio_all_indexes.indexrelid,
       pg_statio_all_indexes.schemaname,
       pg_statio_all_indexes.relname,
       pg_statio_all_indexes.indexrelname,
       pg_statio_all_indexes.idx_blks_read,
       pg_statio_all_indexes.idx_blks_hit
FROM pg_statio_all_indexes
WHERE (pg_statio_all_indexes.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
   OR pg_statio_all_indexes.schemaname ~ '^pg_toast'::text;

alter table pg_catalog.pg_statio_sys_indexes
    owner to postgres;

grant select on pg_catalog.pg_statio_sys_indexes to public;

create view pg_catalog.pg_statio_user_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read, idx_blks_hit) as
SELECT pg_statio_all_indexes.relid,
       pg_statio_all_indexes.indexrelid,
       pg_statio_all_indexes.schemaname,
       pg_statio_all_indexes.relname,
       pg_statio_all_indexes.indexrelname,
       pg_statio_all_indexes.idx_blks_read,
       pg_statio_all_indexes.idx_blks_hit
FROM pg_statio_all_indexes
WHERE (pg_statio_all_indexes.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
  AND pg_statio_all_indexes.schemaname !~ '^pg_toast'::text;

alter table pg_catalog.pg_statio_user_indexes
    owner to postgres;

grant select on pg_catalog.pg_statio_user_indexes to public;

create view pg_catalog.pg_statio_all_sequences(relid, schemaname, relname, blks_read, blks_hit) as
SELECT c.oid                                                             AS relid,
       n.nspname                                                         AS schemaname,
       c.relname,
       pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid) AS blks_read,
       pg_stat_get_blocks_hit(c.oid)                                     AS blks_hit
FROM pg_class c
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = 'S'::"char";

alter table pg_catalog.pg_statio_all_sequences
    owner to postgres;

grant select on pg_catalog.pg_statio_all_sequences to public;

create view pg_catalog.pg_statio_sys_sequences(relid, schemaname, relname, blks_read, blks_hit) as
SELECT pg_statio_all_sequences.relid,
       pg_statio_all_sequences.schemaname,
       pg_statio_all_sequences.relname,
       pg_statio_all_sequences.blks_read,
       pg_statio_all_sequences.blks_hit
FROM pg_statio_all_sequences
WHERE (pg_statio_all_sequences.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
   OR pg_statio_all_sequences.schemaname ~ '^pg_toast'::text;

alter table pg_catalog.pg_statio_sys_sequences
    owner to postgres;

grant select on pg_catalog.pg_statio_sys_sequences to public;

create view pg_catalog.pg_statio_user_sequences(relid, schemaname, relname, blks_read, blks_hit) as
SELECT pg_statio_all_sequences.relid,
       pg_statio_all_sequences.schemaname,
       pg_statio_all_sequences.relname,
       pg_statio_all_sequences.blks_read,
       pg_statio_all_sequences.blks_hit
FROM pg_statio_all_sequences
WHERE (pg_statio_all_sequences.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
  AND pg_statio_all_sequences.schemaname !~ '^pg_toast'::text;

alter table pg_catalog.pg_statio_user_sequences
    owner to postgres;

grant select on pg_catalog.pg_statio_user_sequences to public;

create view pg_catalog.pg_stat_activity
            (datid, datname, pid, usesysid, usename, application_name, client_addr, client_hostname, client_port,
             backend_start, xact_start, query_start, state_change, wait_event_type, wait_event, state, backend_xid,
             backend_xmin, query, backend_type)
as
SELECT s.datid,
       d.datname,
       s.pid,
       s.usesysid,
       u.rolname AS usename,
       s.application_name,
       s.client_addr,
       s.client_hostname,
       s.client_port,
       s.backend_start,
       s.xact_start,
       s.query_start,
       s.state_change,
       s.wait_event_type,
       s.wait_event,
       s.state,
       s.backend_xid,
       s.backend_xmin,
       s.query,
       s.backend_type
FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type,
                                           wait_event, xact_start, query_start, backend_start, state_change,
                                           client_addr, client_hostname, client_port, backend_xid, backend_xmin,
                                           backend_type, ssl, sslversion, sslcipher, sslbits, sslcompression,
                                           ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ,
                                           gss_enc)
         LEFT JOIN pg_database d ON s.datid = d.oid
         LEFT JOIN pg_authid u ON s.usesysid = u.oid;

alter table pg_catalog.pg_stat_activity
    owner to postgres;

grant select on pg_catalog.pg_stat_activity to public;

create view pg_catalog.pg_stat_replication
            (pid, usesysid, usename, application_name, client_addr, client_hostname, client_port, backend_start,
             backend_xmin, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag, flush_lag, replay_lag,
             sync_priority, sync_state, reply_time)
as
SELECT s.pid,
       s.usesysid,
       u.rolname AS usename,
       s.application_name,
       s.client_addr,
       s.client_hostname,
       s.client_port,
       s.backend_start,
       s.backend_xmin,
       w.state,
       w.sent_lsn,
       w.write_lsn,
       w.flush_lsn,
       w.replay_lsn,
       w.write_lag,
       w.flush_lag,
       w.replay_lag,
       w.sync_priority,
       w.sync_state,
       w.reply_time
FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type,
                                           wait_event, xact_start, query_start, backend_start, state_change,
                                           client_addr, client_hostname, client_port, backend_xid, backend_xmin,
                                           backend_type, ssl, sslversion, sslcipher, sslbits, sslcompression,
                                           ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ,
                                           gss_enc)
         JOIN pg_stat_get_wal_senders() w(pid, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag, flush_lag,
                                          replay_lag, sync_priority, sync_state, reply_time) ON s.pid = w.pid
         LEFT JOIN pg_authid u ON s.usesysid = u.oid;

alter table pg_catalog.pg_stat_replication
    owner to postgres;

grant select on pg_catalog.pg_stat_replication to public;

create view pg_catalog.pg_stat_wal_receiver
            (pid, status, receive_start_lsn, receive_start_tli, received_lsn, received_tli, last_msg_send_time,
             last_msg_receipt_time, latest_end_lsn, latest_end_time, slot_name, sender_host, sender_port, conninfo)
as
SELECT s.pid,
       s.status,
       s.receive_start_lsn,
       s.receive_start_tli,
       s.received_lsn,
       s.received_tli,
       s.last_msg_send_time,
       s.last_msg_receipt_time,
       s.latest_end_lsn,
       s.latest_end_time,
       s.slot_name,
       s.sender_host,
       s.sender_port,
       s.conninfo
FROM pg_stat_get_wal_receiver() s(pid, status, receive_start_lsn, receive_start_tli, received_lsn, received_tli,
                                  last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time, slot_name,
                                  sender_host, sender_port, conninfo)
WHERE s.pid IS NOT NULL;

alter table pg_catalog.pg_stat_wal_receiver
    owner to postgres;

grant select on pg_catalog.pg_stat_wal_receiver to public;

create view pg_catalog.pg_stat_subscription
            (subid, subname, pid, relid, received_lsn, last_msg_send_time, last_msg_receipt_time, latest_end_lsn,
             latest_end_time) as
SELECT su.oid AS subid,
       su.subname,
       st.pid,
       st.relid,
       st.received_lsn,
       st.last_msg_send_time,
       st.last_msg_receipt_time,
       st.latest_end_lsn,
       st.latest_end_time
FROM pg_subscription su
         LEFT JOIN pg_stat_get_subscription(NULL::oid) st(subid, relid, pid, received_lsn, last_msg_send_time,
                                                          last_msg_receipt_time, latest_end_lsn, latest_end_time)
                   ON st.subid = su.oid;

alter table pg_catalog.pg_stat_subscription
    owner to postgres;

grant select on pg_catalog.pg_stat_subscription to public;

create view pg_catalog.pg_stat_ssl
            (pid, ssl, version, cipher, bits, compression, client_dn, client_serial, issuer_dn) as
SELECT s.pid,
       s.ssl,
       s.sslversion        AS version,
       s.sslcipher         AS cipher,
       s.sslbits           AS bits,
       s.sslcompression    AS compression,
       s.ssl_client_dn     AS client_dn,
       s.ssl_client_serial AS client_serial,
       s.ssl_issuer_dn     AS issuer_dn
FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type,
                                           wait_event, xact_start, query_start, backend_start, state_change,
                                           client_addr, client_hostname, client_port, backend_xid, backend_xmin,
                                           backend_type, ssl, sslversion, sslcipher, sslbits, sslcompression,
                                           ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ,
                                           gss_enc);

alter table pg_catalog.pg_stat_ssl
    owner to postgres;

grant select on pg_catalog.pg_stat_ssl to public;

create view pg_catalog.pg_stat_gssapi(pid, gss_authenticated, principal, encrypted) as
SELECT s.pid,
       s.gss_auth  AS gss_authenticated,
       s.gss_princ AS principal,
       s.gss_enc   AS encrypted
FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type,
                                           wait_event, xact_start, query_start, backend_start, state_change,
                                           client_addr, client_hostname, client_port, backend_xid, backend_xmin,
                                           backend_type, ssl, sslversion, sslcipher, sslbits, sslcompression,
                                           ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ,
                                           gss_enc);

alter table pg_catalog.pg_stat_gssapi
    owner to postgres;

grant select on pg_catalog.pg_stat_gssapi to public;

create view pg_catalog.pg_replication_slots
            (slot_name, plugin, slot_type, datoid, database, temporary, active, active_pid, xmin, catalog_xmin,
             restart_lsn, confirmed_flush_lsn)
as
SELECT l.slot_name,
       l.plugin,
       l.slot_type,
       l.datoid,
       d.datname AS database,
       l.temporary,
       l.active,
       l.active_pid,
       l.xmin,
       l.catalog_xmin,
       l.restart_lsn,
       l.confirmed_flush_lsn
FROM pg_get_replication_slots() l(slot_name, plugin, slot_type, datoid, temporary, active, active_pid, xmin,
                                  catalog_xmin, restart_lsn, confirmed_flush_lsn)
         LEFT JOIN pg_database d ON l.datoid = d.oid;

alter table pg_catalog.pg_replication_slots
    owner to postgres;

grant select on pg_catalog.pg_replication_slots to public;

create view pg_catalog.pg_stat_database
            (datid, datname, numbackends, xact_commit, xact_rollback, blks_read, blks_hit, tup_returned, tup_fetched,
             tup_inserted, tup_updated, tup_deleted, conflicts, temp_files, temp_bytes, deadlocks, checksum_failures,
             checksum_last_failure, blk_read_time, blk_write_time, stats_reset)
as
SELECT d.oid                                                                   AS datid,
       d.datname,
       CASE
           WHEN d.oid = 0::oid THEN 0
           ELSE pg_stat_get_db_numbackends(d.oid)
           END                                                                 AS numbackends,
       pg_stat_get_db_xact_commit(d.oid)                                       AS xact_commit,
       pg_stat_get_db_xact_rollback(d.oid)                                     AS xact_rollback,
       pg_stat_get_db_blocks_fetched(d.oid) - pg_stat_get_db_blocks_hit(d.oid) AS blks_read,
       pg_stat_get_db_blocks_hit(d.oid)                                        AS blks_hit,
       pg_stat_get_db_tuples_returned(d.oid)                                   AS tup_returned,
       pg_stat_get_db_tuples_fetched(d.oid)                                    AS tup_fetched,
       pg_stat_get_db_tuples_inserted(d.oid)                                   AS tup_inserted,
       pg_stat_get_db_tuples_updated(d.oid)                                    AS tup_updated,
       pg_stat_get_db_tuples_deleted(d.oid)                                    AS tup_deleted,
       pg_stat_get_db_conflict_all(d.oid)                                      AS conflicts,
       pg_stat_get_db_temp_files(d.oid)                                        AS temp_files,
       pg_stat_get_db_temp_bytes(d.oid)                                        AS temp_bytes,
       pg_stat_get_db_deadlocks(d.oid)                                         AS deadlocks,
       pg_stat_get_db_checksum_failures(d.oid)                                 AS checksum_failures,
       pg_stat_get_db_checksum_last_failure(d.oid)                             AS checksum_last_failure,
       pg_stat_get_db_blk_read_time(d.oid)                                     AS blk_read_time,
       pg_stat_get_db_blk_write_time(d.oid)                                    AS blk_write_time,
       pg_stat_get_db_stat_reset_time(d.oid)                                   AS stats_reset
FROM (SELECT 0          AS oid,
             NULL::name AS datname
      UNION ALL
      SELECT pg_database.oid,
             pg_database.datname
      FROM pg_database) d;

alter table pg_catalog.pg_stat_database
    owner to postgres;

grant select on pg_catalog.pg_stat_database to public;

create view pg_catalog.pg_stat_database_conflicts
            (datid, datname, confl_tablespace, confl_lock, confl_snapshot, confl_bufferpin, confl_deadlock) as
SELECT d.oid                                           AS datid,
       d.datname,
       pg_stat_get_db_conflict_tablespace(d.oid)       AS confl_tablespace,
       pg_stat_get_db_conflict_lock(d.oid)             AS confl_lock,
       pg_stat_get_db_conflict_snapshot(d.oid)         AS confl_snapshot,
       pg_stat_get_db_conflict_bufferpin(d.oid)        AS confl_bufferpin,
       pg_stat_get_db_conflict_startup_deadlock(d.oid) AS confl_deadlock
FROM pg_database d;

alter table pg_catalog.pg_stat_database_conflicts
    owner to postgres;

grant select on pg_catalog.pg_stat_database_conflicts to public;

create view pg_catalog.pg_stat_user_functions(funcid, schemaname, funcname, calls, total_time, self_time) as
SELECT p.oid                                  AS funcid,
       n.nspname                              AS schemaname,
       p.proname                              AS funcname,
       pg_stat_get_function_calls(p.oid)      AS calls,
       pg_stat_get_function_total_time(p.oid) AS total_time,
       pg_stat_get_function_self_time(p.oid)  AS self_time
FROM pg_proc p
         LEFT JOIN pg_namespace n ON n.oid = p.pronamespace
WHERE p.prolang <> 12::oid
  AND pg_stat_get_function_calls(p.oid) IS NOT NULL;

alter table pg_catalog.pg_stat_user_functions
    owner to postgres;

grant select on pg_catalog.pg_stat_user_functions to public;

create view pg_catalog.pg_stat_xact_user_functions(funcid, schemaname, funcname, calls, total_time, self_time) as
SELECT p.oid                                       AS funcid,
       n.nspname                                   AS schemaname,
       p.proname                                   AS funcname,
       pg_stat_get_xact_function_calls(p.oid)      AS calls,
       pg_stat_get_xact_function_total_time(p.oid) AS total_time,
       pg_stat_get_xact_function_self_time(p.oid)  AS self_time
FROM pg_proc p
         LEFT JOIN pg_namespace n ON n.oid = p.pronamespace
WHERE p.prolang <> 12::oid
  AND pg_stat_get_xact_function_calls(p.oid) IS NOT NULL;

alter table pg_catalog.pg_stat_xact_user_functions
    owner to postgres;

grant select on pg_catalog.pg_stat_xact_user_functions to public;

create view pg_catalog.pg_stat_archiver
            (archived_count, last_archived_wal, last_archived_time, failed_count, last_failed_wal, last_failed_time,
             stats_reset) as
SELECT s.archived_count,
       s.last_archived_wal,
       s.last_archived_time,
       s.failed_count,
       s.last_failed_wal,
       s.last_failed_time,
       s.stats_reset
FROM pg_stat_get_archiver() s(archived_count, last_archived_wal, last_archived_time, failed_count, last_failed_wal,
                              last_failed_time, stats_reset);

alter table pg_catalog.pg_stat_archiver
    owner to postgres;

grant select on pg_catalog.pg_stat_archiver to public;

create view pg_catalog.pg_stat_bgwriter
            (checkpoints_timed, checkpoints_req, checkpoint_write_time, checkpoint_sync_time, buffers_checkpoint,
             buffers_clean, maxwritten_clean, buffers_backend, buffers_backend_fsync, buffers_alloc, stats_reset)
as
SELECT pg_stat_get_bgwriter_timed_checkpoints()       AS checkpoints_timed,
       pg_stat_get_bgwriter_requested_checkpoints()   AS checkpoints_req,
       pg_stat_get_checkpoint_write_time()            AS checkpoint_write_time,
       pg_stat_get_checkpoint_sync_time()             AS checkpoint_sync_time,
       pg_stat_get_bgwriter_buf_written_checkpoints() AS buffers_checkpoint,
       pg_stat_get_bgwriter_buf_written_clean()       AS buffers_clean,
       pg_stat_get_bgwriter_maxwritten_clean()        AS maxwritten_clean,
       pg_stat_get_buf_written_backend()              AS buffers_backend,
       pg_stat_get_buf_fsync_backend()                AS buffers_backend_fsync,
       pg_stat_get_buf_alloc()                        AS buffers_alloc,
       pg_stat_get_bgwriter_stat_reset_time()         AS stats_reset;

alter table pg_catalog.pg_stat_bgwriter
    owner to postgres;

grant select on pg_catalog.pg_stat_bgwriter to public;

create view pg_catalog.pg_stat_progress_vacuum
            (pid, datid, datname, relid, phase, heap_blks_total, heap_blks_scanned, heap_blks_vacuumed,
             index_vacuum_count, max_dead_tuples, num_dead_tuples)
as
SELECT s.pid,
       s.datid,
       d.datname,
       s.relid,
       CASE s.param1
           WHEN 0 THEN 'initializing'::text
           WHEN 1 THEN 'scanning heap'::text
           WHEN 2 THEN 'vacuuming indexes'::text
           WHEN 3 THEN 'vacuuming heap'::text
           WHEN 4 THEN 'cleaning up indexes'::text
           WHEN 5 THEN 'truncating heap'::text
           WHEN 6 THEN 'performing final cleanup'::text
           ELSE NULL::text
           END  AS phase,
       s.param2 AS heap_blks_total,
       s.param3 AS heap_blks_scanned,
       s.param4 AS heap_blks_vacuumed,
       s.param5 AS index_vacuum_count,
       s.param6 AS max_dead_tuples,
       s.param7 AS num_dead_tuples
FROM pg_stat_get_progress_info('VACUUM'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6,
                                                 param7, param8, param9, param10, param11, param12, param13, param14,
                                                 param15, param16, param17, param18, param19, param20)
         LEFT JOIN pg_database d ON s.datid = d.oid;

alter table pg_catalog.pg_stat_progress_vacuum
    owner to postgres;

grant select on pg_catalog.pg_stat_progress_vacuum to public;

create view pg_catalog.pg_stat_progress_cluster
            (pid, datid, datname, relid, command, phase, cluster_index_relid, heap_tuples_scanned, heap_tuples_written,
             heap_blks_total, heap_blks_scanned, index_rebuild_count)
as
SELECT s.pid,
       s.datid,
       d.datname,
       s.relid,
       CASE s.param1
           WHEN 1 THEN 'CLUSTER'::text
           WHEN 2 THEN 'VACUUM FULL'::text
           ELSE NULL::text
           END       AS command,
       CASE s.param2
           WHEN 0 THEN 'initializing'::text
           WHEN 1 THEN 'seq scanning heap'::text
           WHEN 2 THEN 'index scanning heap'::text
           WHEN 3 THEN 'sorting tuples'::text
           WHEN 4 THEN 'writing new heap'::text
           WHEN 5 THEN 'swapping relation files'::text
           WHEN 6 THEN 'rebuilding index'::text
           WHEN 7 THEN 'performing final cleanup'::text
           ELSE NULL::text
           END       AS phase,
       s.param3::oid AS cluster_index_relid,
       s.param4      AS heap_tuples_scanned,
       s.param5      AS heap_tuples_written,
       s.param6      AS heap_blks_total,
       s.param7      AS heap_blks_scanned,
       s.param8      AS index_rebuild_count
FROM pg_stat_get_progress_info('CLUSTER'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6,
                                                  param7, param8, param9, param10, param11, param12, param13, param14,
                                                  param15, param16, param17, param18, param19, param20)
         LEFT JOIN pg_database d ON s.datid = d.oid;

alter table pg_catalog.pg_stat_progress_cluster
    owner to postgres;

grant select on pg_catalog.pg_stat_progress_cluster to public;

create view pg_catalog.pg_stat_progress_create_index
            (pid, datid, datname, relid, index_relid, command, phase, lockers_total, lockers_done, current_locker_pid,
             blocks_total, blocks_done, tuples_total, tuples_done, partitions_total, partitions_done)
as
SELECT s.pid,
       s.datid,
       d.datname,
       s.relid,
       s.param7::oid AS index_relid,
       CASE s.param1
           WHEN 1 THEN 'CREATE INDEX'::text
           WHEN 2 THEN 'CREATE INDEX CONCURRENTLY'::text
           WHEN 3 THEN 'REINDEX'::text
           WHEN 4 THEN 'REINDEX CONCURRENTLY'::text
           ELSE NULL::text
           END       AS command,
       CASE s.param10
           WHEN 0 THEN 'initializing'::text
           WHEN 1 THEN 'waiting for writers before build'::text
           WHEN 2 THEN 'building index'::text ||
                       COALESCE(': '::text || pg_indexam_progress_phasename(s.param9::oid, s.param11), ''::text)
           WHEN 3 THEN 'waiting for writers before validation'::text
           WHEN 4 THEN 'index validation: scanning index'::text
           WHEN 5 THEN 'index validation: sorting tuples'::text
           WHEN 6 THEN 'index validation: scanning table'::text
           WHEN 7 THEN 'waiting for old snapshots'::text
           WHEN 8 THEN 'waiting for readers before marking dead'::text
           WHEN 9 THEN 'waiting for readers before dropping'::text
           ELSE NULL::text
           END       AS phase,
       s.param4      AS lockers_total,
       s.param5      AS lockers_done,
       s.param6      AS current_locker_pid,
       s.param16     AS blocks_total,
       s.param17     AS blocks_done,
       s.param12     AS tuples_total,
       s.param13     AS tuples_done,
       s.param14     AS partitions_total,
       s.param15     AS partitions_done
FROM pg_stat_get_progress_info('CREATE INDEX'::text) s(pid, datid, relid, param1, param2, param3, param4, param5,
                                                       param6, param7, param8, param9, param10, param11, param12,
                                                       param13, param14, param15, param16, param17, param18, param19,
                                                       param20)
         LEFT JOIN pg_database d ON s.datid = d.oid;

alter table pg_catalog.pg_stat_progress_create_index
    owner to postgres;

grant select on pg_catalog.pg_stat_progress_create_index to public;

create view pg_catalog.pg_user_mappings(umid, srvid, srvname, umuser, usename, umoptions) as
SELECT u.oid   AS umid,
       s.oid   AS srvid,
       s.srvname,
       u.umuser,
       CASE
           WHEN u.umuser = 0::oid THEN 'public'::name
           ELSE a.rolname
           END AS usename,
       CASE
           WHEN u.umuser <> 0::oid AND a.rolname = CURRENT_USER AND
                (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text)) OR
                u.umuser = 0::oid AND pg_has_role(s.srvowner, 'USAGE'::text) OR (SELECT pg_authid.rolsuper
                                                                                 FROM pg_authid
                                                                                 WHERE pg_authid.rolname = CURRENT_USER)
               THEN u.umoptions
           ELSE NULL::text[]
           END AS umoptions
FROM pg_user_mapping u
         JOIN pg_foreign_server s ON u.umserver = s.oid
         LEFT JOIN pg_authid a ON a.oid = u.umuser;

alter table pg_catalog.pg_user_mappings
    owner to postgres;

grant select on pg_catalog.pg_user_mappings to public;

create view pg_catalog.pg_replication_origin_status(local_id, external_id, remote_lsn, local_lsn) as
SELECT pg_show_replication_origin_status.local_id,
       pg_show_replication_origin_status.external_id,
       pg_show_replication_origin_status.remote_lsn,
       pg_show_replication_origin_status.local_lsn
FROM pg_show_replication_origin_status() pg_show_replication_origin_status(local_id, external_id, remote_lsn, local_lsn);

alter table pg_catalog.pg_replication_origin_status
    owner to postgres;

create view information_schema.information_schema_catalog_name(catalog_name) as
SELECT current_database()::information_schema.sql_identifier AS catalog_name;

alter table information_schema.information_schema_catalog_name
    owner to postgres;

grant select on information_schema.information_schema_catalog_name to public;

create view information_schema.applicable_roles(grantee, role_name, is_grantable) as
SELECT a.rolname::information_schema.sql_identifier AS grantee,
       b.rolname::information_schema.sql_identifier AS role_name,
       CASE
           WHEN m.admin_option THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no        AS is_grantable
FROM pg_auth_members m
         JOIN pg_authid a ON m.member = a.oid
         JOIN pg_authid b ON m.roleid = b.oid
WHERE pg_has_role(a.oid, 'USAGE'::text);

alter table information_schema.applicable_roles
    owner to postgres;

grant select on information_schema.applicable_roles to public;

create view information_schema.administrable_role_authorizations(grantee, role_name, is_grantable) as
SELECT applicable_roles.grantee,
       applicable_roles.role_name,
       applicable_roles.is_grantable
FROM information_schema.applicable_roles
WHERE applicable_roles.is_grantable::text = 'YES'::text;

alter table information_schema.administrable_role_authorizations
    owner to postgres;

grant select on information_schema.administrable_role_authorizations to public;

create view information_schema.attributes
            (udt_catalog, udt_schema, udt_name, attribute_name, ordinal_position, attribute_default, is_nullable,
             data_type, character_maximum_length, character_octet_length, character_set_catalog, character_set_schema,
             character_set_name, collation_catalog, collation_schema, collation_name, numeric_precision,
             numeric_precision_radix, numeric_scale, datetime_precision, interval_type, interval_precision,
             attribute_udt_catalog, attribute_udt_schema, attribute_udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier, is_derived_reference_attribute)
as
SELECT current_database()::information_schema.sql_identifier                                                                           AS udt_catalog,
       nc.nspname::information_schema.sql_identifier                                                                                   AS udt_schema,
       c.relname::information_schema.sql_identifier                                                                                    AS udt_name,
       a.attname::information_schema.sql_identifier                                                                                    AS attribute_name,
       a.attnum::information_schema.cardinal_number                                                                                    AS ordinal_position,
       pg_get_expr(ad.adbin, ad.adrelid)::information_schema.character_data                                                            AS attribute_default,
       CASE
           WHEN a.attnotnull OR t.typtype = 'd'::"char" AND t.typnotnull THEN 'NO'::text
           ELSE 'YES'::text
           END::information_schema.yes_or_no                                                                                           AS is_nullable,
       CASE
           WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text
           WHEN nt.nspname = 'pg_catalog'::name THEN format_type(a.atttypid, NULL::integer)
           ELSE 'USER-DEFINED'::text
           END::information_schema.character_data                                                                                      AS data_type,
       information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*),
                                              information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number         AS character_maximum_length,
       information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*),
                                                information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number       AS character_octet_length,
       NULL::name::information_schema.sql_identifier                                                                                   AS character_set_catalog,
       NULL::name::information_schema.sql_identifier                                                                                   AS character_set_schema,
       NULL::name::information_schema.sql_identifier                                                                                   AS character_set_name,
       CASE
           WHEN nco.nspname IS NOT NULL THEN current_database()
           ELSE NULL::name
           END::information_schema.sql_identifier                                                                                      AS collation_catalog,
       nco.nspname::information_schema.sql_identifier                                                                                  AS collation_schema,
       co.collname::information_schema.sql_identifier                                                                                  AS collation_name,
       information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*),
                                                information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number       AS numeric_precision,
       information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*),
                                                      information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_precision_radix,
       information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*),
                                            information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number           AS numeric_scale,
       information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*),
                                                 information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number      AS datetime_precision,
       information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*),
                                            information_schema._pg_truetypmod(a.*, t.*))::information_schema.character_data            AS interval_type,
       NULL::integer::information_schema.cardinal_number                                                                               AS interval_precision,
       current_database()::information_schema.sql_identifier                                                                           AS attribute_udt_catalog,
       nt.nspname::information_schema.sql_identifier                                                                                   AS attribute_udt_schema,
       t.typname::information_schema.sql_identifier                                                                                    AS attribute_udt_name,
       NULL::name::information_schema.sql_identifier                                                                                   AS scope_catalog,
       NULL::name::information_schema.sql_identifier                                                                                   AS scope_schema,
       NULL::name::information_schema.sql_identifier                                                                                   AS scope_name,
       NULL::integer::information_schema.cardinal_number                                                                               AS maximum_cardinality,
       a.attnum::information_schema.sql_identifier                                                                                     AS dtd_identifier,
       'NO'::character varying::information_schema.yes_or_no                                                                           AS is_derived_reference_attribute
FROM pg_attribute a
         LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum
         JOIN (pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid) ON a.attrelid = c.oid
         JOIN (pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON a.atttypid = t.oid
         LEFT JOIN (pg_collation co
    JOIN pg_namespace nco ON co.collnamespace = nco.oid)
                   ON a.attcollation = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)
WHERE a.attnum > 0
  AND NOT a.attisdropped
  AND c.relkind = 'c'::"char"
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_type_privilege(c.reltype, 'USAGE'::text));

alter table information_schema.attributes
    owner to postgres;

grant select on information_schema.attributes to public;

create view information_schema.character_sets
            (character_set_catalog, character_set_schema, character_set_name, character_repertoire, form_of_use,
             default_collate_catalog, default_collate_schema, default_collate_name)
as
SELECT NULL::name::information_schema.sql_identifier            AS character_set_catalog,
       NULL::name::information_schema.sql_identifier            AS character_set_schema,
       getdatabaseencoding()::information_schema.sql_identifier AS character_set_name,
       CASE
           WHEN getdatabaseencoding() = 'UTF8'::name THEN 'UCS'::name
           ELSE getdatabaseencoding()
           END::information_schema.sql_identifier               AS character_repertoire,
       getdatabaseencoding()::information_schema.sql_identifier AS form_of_use,
       current_database()::information_schema.sql_identifier    AS default_collate_catalog,
       nc.nspname::information_schema.sql_identifier            AS default_collate_schema,
       c.collname::information_schema.sql_identifier            AS default_collate_name
FROM pg_database d
         LEFT JOIN (pg_collation c
    JOIN pg_namespace nc ON c.collnamespace = nc.oid) ON d.datcollate = c.collcollate AND d.datctype = c.collctype
WHERE d.datname = current_database()
ORDER BY (char_length(c.collname::text)) DESC, c.collname
LIMIT 1;

alter table information_schema.character_sets
    owner to postgres;

grant select on information_schema.character_sets to public;

create view information_schema.check_constraint_routine_usage
            (constraint_catalog, constraint_schema, constraint_name, specific_catalog, specific_schema,
             specific_name) as
SELECT current_database()::information_schema.sql_identifier              AS constraint_catalog,
       nc.nspname::information_schema.sql_identifier                      AS constraint_schema,
       c.conname::information_schema.sql_identifier                       AS constraint_name,
       current_database()::information_schema.sql_identifier              AS specific_catalog,
       np.nspname::information_schema.sql_identifier                      AS specific_schema,
       nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name
FROM pg_namespace nc,
     pg_constraint c,
     pg_depend d,
     pg_proc p,
     pg_namespace np
WHERE nc.oid = c.connamespace
  AND c.contype = 'c'::"char"
  AND c.oid = d.objid
  AND d.classid = 'pg_constraint'::regclass::oid
  AND d.refobjid = p.oid
  AND d.refclassid = 'pg_proc'::regclass::oid
  AND p.pronamespace = np.oid
  AND pg_has_role(p.proowner, 'USAGE'::text);

alter table information_schema.check_constraint_routine_usage
    owner to postgres;

grant select on information_schema.check_constraint_routine_usage to public;

create view information_schema.check_constraints(constraint_catalog, constraint_schema, constraint_name, check_clause) as
SELECT current_database()::information_schema.sql_identifier                            AS constraint_catalog,
       rs.nspname::information_schema.sql_identifier                                    AS constraint_schema,
       con.conname::information_schema.sql_identifier                                   AS constraint_name,
       "substring"(pg_get_constraintdef(con.oid), 7)::information_schema.character_data AS check_clause
FROM pg_constraint con
         LEFT JOIN pg_namespace rs ON rs.oid = con.connamespace
         LEFT JOIN pg_class c ON c.oid = con.conrelid
         LEFT JOIN pg_type t ON t.oid = con.contypid
WHERE pg_has_role(COALESCE(c.relowner, t.typowner), 'USAGE'::text)
  AND con.contype = 'c'::"char"
UNION
SELECT current_database()::information_schema.sql_identifier                        AS constraint_catalog,
       n.nspname::information_schema.sql_identifier                                 AS constraint_schema,
       (((((n.oid::text || '_'::text) || r.oid::text) || '_'::text) || a.attnum::text) ||
        '_not_null'::text)::information_schema.sql_identifier                       AS constraint_name,
       (a.attname::text || ' IS NOT NULL'::text)::information_schema.character_data AS check_clause
FROM pg_namespace n,
     pg_class r,
     pg_attribute a
WHERE n.oid = r.relnamespace
  AND r.oid = a.attrelid
  AND a.attnum > 0
  AND NOT a.attisdropped
  AND a.attnotnull
  AND (r.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]))
  AND pg_has_role(r.relowner, 'USAGE'::text);

alter table information_schema.check_constraints
    owner to postgres;

grant select on information_schema.check_constraints to public;

create view information_schema.collations(collation_catalog, collation_schema, collation_name, pad_attribute) as
SELECT current_database()::information_schema.sql_identifier          AS collation_catalog,
       nc.nspname::information_schema.sql_identifier                  AS collation_schema,
       c.collname::information_schema.sql_identifier                  AS collation_name,
       'NO PAD'::character varying::information_schema.character_data AS pad_attribute
FROM pg_collation c,
     pg_namespace nc
WHERE c.collnamespace = nc.oid
  AND (c.collencoding = ANY (ARRAY ['-1'::integer, (SELECT pg_database.encoding
                                                    FROM pg_database
                                                    WHERE pg_database.datname = current_database())]));

alter table information_schema.collations
    owner to postgres;

grant select on information_schema.collations to public;

create view information_schema.collation_character_set_applicability
            (collation_catalog, collation_schema, collation_name, character_set_catalog, character_set_schema,
             character_set_name) as
SELECT current_database()::information_schema.sql_identifier    AS collation_catalog,
       nc.nspname::information_schema.sql_identifier            AS collation_schema,
       c.collname::information_schema.sql_identifier            AS collation_name,
       NULL::name::information_schema.sql_identifier            AS character_set_catalog,
       NULL::name::information_schema.sql_identifier            AS character_set_schema,
       getdatabaseencoding()::information_schema.sql_identifier AS character_set_name
FROM pg_collation c,
     pg_namespace nc
WHERE c.collnamespace = nc.oid
  AND (c.collencoding = ANY (ARRAY ['-1'::integer, (SELECT pg_database.encoding
                                                    FROM pg_database
                                                    WHERE pg_database.datname = current_database())]));

alter table information_schema.collation_character_set_applicability
    owner to postgres;

grant select on information_schema.collation_character_set_applicability to public;

create view information_schema.column_column_usage
            (table_catalog, table_schema, table_name, column_name, dependent_column) as
SELECT current_database()::information_schema.sql_identifier AS table_catalog,
       n.nspname::information_schema.sql_identifier          AS table_schema,
       c.relname::information_schema.sql_identifier          AS table_name,
       ac.attname::information_schema.sql_identifier         AS column_name,
       ad.attname::information_schema.sql_identifier         AS dependent_column
FROM pg_namespace n,
     pg_class c,
     pg_depend d,
     pg_attribute ac,
     pg_attribute ad
WHERE n.oid = c.relnamespace
  AND c.oid = ac.attrelid
  AND c.oid = ad.attrelid
  AND d.classid = 'pg_class'::regclass::oid
  AND d.refclassid = 'pg_class'::regclass::oid
  AND d.objid = d.refobjid
  AND c.oid = d.objid
  AND d.objsubid = ad.attnum
  AND d.refobjsubid = ac.attnum
  AND ad.attgenerated <> ''::"char"
  AND pg_has_role(c.relowner, 'USAGE'::text);

alter table information_schema.column_column_usage
    owner to postgres;

grant select on information_schema.column_column_usage to public;

create view information_schema.column_domain_usage
            (domain_catalog, domain_schema, domain_name, table_catalog, table_schema, table_name, column_name) as
SELECT current_database()::information_schema.sql_identifier AS domain_catalog,
       nt.nspname::information_schema.sql_identifier         AS domain_schema,
       t.typname::information_schema.sql_identifier          AS domain_name,
       current_database()::information_schema.sql_identifier AS table_catalog,
       nc.nspname::information_schema.sql_identifier         AS table_schema,
       c.relname::information_schema.sql_identifier          AS table_name,
       a.attname::information_schema.sql_identifier          AS column_name
FROM pg_type t,
     pg_namespace nt,
     pg_class c,
     pg_namespace nc,
     pg_attribute a
WHERE t.typnamespace = nt.oid
  AND c.relnamespace = nc.oid
  AND a.attrelid = c.oid
  AND a.atttypid = t.oid
  AND t.typtype = 'd'::"char"
  AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND a.attnum > 0
  AND NOT a.attisdropped
  AND pg_has_role(t.typowner, 'USAGE'::text);

alter table information_schema.column_domain_usage
    owner to postgres;

grant select on information_schema.column_domain_usage to public;

create view information_schema.column_privileges
            (grantor, grantee, table_catalog, table_schema, table_name, column_name, privilege_type, is_grantable) as
SELECT u_grantor.rolname::information_schema.sql_identifier  AS grantor,
       grantee.rolname::information_schema.sql_identifier    AS grantee,
       current_database()::information_schema.sql_identifier AS table_catalog,
       nc.nspname::information_schema.sql_identifier         AS table_schema,
       x.relname::information_schema.sql_identifier          AS table_name,
       x.attname::information_schema.sql_identifier          AS column_name,
       x.prtype::information_schema.character_data           AS privilege_type,
       CASE
           WHEN pg_has_role(x.grantee, x.relowner, 'USAGE'::text) OR x.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_grantable
FROM (SELECT pr_c.grantor,
             pr_c.grantee,
             a.attname,
             pr_c.relname,
             pr_c.relnamespace,
             pr_c.prtype,
             pr_c.grantable,
             pr_c.relowner
      FROM (SELECT pg_class.oid,
                   pg_class.relname,
                   pg_class.relnamespace,
                   pg_class.relowner,
                   (aclexplode(COALESCE(pg_class.relacl,
                                        acldefault('r'::"char", pg_class.relowner)))).grantor                         AS grantor,
                   (aclexplode(COALESCE(pg_class.relacl,
                                        acldefault('r'::"char", pg_class.relowner)))).grantee                         AS grantee,
                   (aclexplode(COALESCE(pg_class.relacl,
                                        acldefault('r'::"char", pg_class.relowner)))).privilege_type                  AS privilege_type,
                   (aclexplode(COALESCE(pg_class.relacl,
                                        acldefault('r'::"char", pg_class.relowner)))).is_grantable                    AS is_grantable
            FROM pg_class
            WHERE pg_class.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) pr_c(oid,
                                                                                                            relname,
                                                                                                            relnamespace,
                                                                                                            relowner,
                                                                                                            grantor,
                                                                                                            grantee,
                                                                                                            prtype,
                                                                                                            grantable),
           pg_attribute a
      WHERE a.attrelid = pr_c.oid
        AND a.attnum > 0
        AND NOT a.attisdropped
      UNION
      SELECT pr_a.grantor,
             pr_a.grantee,
             pr_a.attname,
             c.relname,
             c.relnamespace,
             pr_a.prtype,
             pr_a.grantable,
             c.relowner
      FROM (SELECT a.attrelid,
                   a.attname,
                   (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).grantor        AS grantor,
                   (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).grantee        AS grantee,
                   (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).privilege_type AS privilege_type,
                   (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).is_grantable   AS is_grantable
            FROM pg_attribute a
                     JOIN pg_class cc ON a.attrelid = cc.oid
            WHERE a.attnum > 0
              AND NOT a.attisdropped) pr_a(attrelid, attname, grantor, grantee, prtype, grantable),
           pg_class c
      WHERE pr_a.attrelid = c.oid
        AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))) x,
     pg_namespace nc,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE x.relnamespace = nc.oid
  AND x.grantee = grantee.oid
  AND x.grantor = u_grantor.oid
  AND (x.prtype = ANY (ARRAY ['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'REFERENCES'::text]))
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name);

alter table information_schema.column_privileges
    owner to postgres;

grant select on information_schema.column_privileges to public;

create view information_schema.column_udt_usage
            (udt_catalog, udt_schema, udt_name, table_catalog, table_schema, table_name, column_name) as
SELECT current_database()::information_schema.sql_identifier                AS udt_catalog,
       COALESCE(nbt.nspname, nt.nspname)::information_schema.sql_identifier AS udt_schema,
       COALESCE(bt.typname, t.typname)::information_schema.sql_identifier   AS udt_name,
       current_database()::information_schema.sql_identifier                AS table_catalog,
       nc.nspname::information_schema.sql_identifier                        AS table_schema,
       c.relname::information_schema.sql_identifier                         AS table_name,
       a.attname::information_schema.sql_identifier                         AS column_name
FROM pg_attribute a,
     pg_class c,
     pg_namespace nc,
     pg_type t
         JOIN pg_namespace nt ON t.typnamespace = nt.oid
         LEFT JOIN (pg_type bt
         JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid) ON t.typtype = 'd'::"char" AND t.typbasetype = bt.oid
WHERE a.attrelid = c.oid
  AND a.atttypid = t.oid
  AND nc.oid = c.relnamespace
  AND a.attnum > 0
  AND NOT a.attisdropped
  AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND pg_has_role(COALESCE(bt.typowner, t.typowner), 'USAGE'::text);

alter table information_schema.column_udt_usage
    owner to postgres;

grant select on information_schema.column_udt_usage to public;

create view information_schema.columns
            (table_catalog, table_schema, table_name, column_name, ordinal_position, column_default, is_nullable,
             data_type, character_maximum_length, character_octet_length, numeric_precision, numeric_precision_radix,
             numeric_scale, datetime_precision, interval_type, interval_precision, character_set_catalog,
             character_set_schema, character_set_name, collation_catalog, collation_schema, collation_name,
             domain_catalog, domain_schema, domain_name, udt_catalog, udt_schema, udt_name, scope_catalog, scope_schema,
             scope_name, maximum_cardinality, dtd_identifier, is_self_referencing, is_identity, identity_generation,
             identity_start, identity_increment, identity_maximum, identity_minimum, identity_cycle, is_generated,
             generation_expression, is_updatable)
as
SELECT current_database()::information_schema.sql_identifier                                                                           AS table_catalog,
       nc.nspname::information_schema.sql_identifier                                                                                   AS table_schema,
       c.relname::information_schema.sql_identifier                                                                                    AS table_name,
       a.attname::information_schema.sql_identifier                                                                                    AS column_name,
       a.attnum::information_schema.cardinal_number                                                                                    AS ordinal_position,
       CASE
           WHEN a.attgenerated = ''::"char" THEN pg_get_expr(ad.adbin, ad.adrelid)
           ELSE NULL::text
           END::information_schema.character_data                                                                                      AS column_default,
       CASE
           WHEN a.attnotnull OR t.typtype = 'd'::"char" AND t.typnotnull THEN 'NO'::text
           ELSE 'YES'::text
           END::information_schema.yes_or_no                                                                                           AS is_nullable,
       CASE
           WHEN t.typtype = 'd'::"char" THEN
               CASE
                   WHEN bt.typelem <> 0::oid AND bt.typlen = '-1'::integer THEN 'ARRAY'::text
                   WHEN nbt.nspname = 'pg_catalog'::name THEN format_type(t.typbasetype, NULL::integer)
                   ELSE 'USER-DEFINED'::text
                   END
           ELSE
               CASE
                   WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text
                   WHEN nt.nspname = 'pg_catalog'::name THEN format_type(a.atttypid, NULL::integer)
                   ELSE 'USER-DEFINED'::text
                   END
           END::information_schema.character_data                                                                                      AS data_type,
       information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*),
                                              information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number         AS character_maximum_length,
       information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*),
                                                information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number       AS character_octet_length,
       information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*),
                                                information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number       AS numeric_precision,
       information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*),
                                                      information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_precision_radix,
       information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*),
                                            information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number           AS numeric_scale,
       information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*),
                                                 information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number      AS datetime_precision,
       information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*),
                                            information_schema._pg_truetypmod(a.*, t.*))::information_schema.character_data            AS interval_type,
       NULL::integer::information_schema.cardinal_number                                                                               AS interval_precision,
       NULL::name::information_schema.sql_identifier                                                                                   AS character_set_catalog,
       NULL::name::information_schema.sql_identifier                                                                                   AS character_set_schema,
       NULL::name::information_schema.sql_identifier                                                                                   AS character_set_name,
       CASE
           WHEN nco.nspname IS NOT NULL THEN current_database()
           ELSE NULL::name
           END::information_schema.sql_identifier                                                                                      AS collation_catalog,
       nco.nspname::information_schema.sql_identifier                                                                                  AS collation_schema,
       co.collname::information_schema.sql_identifier                                                                                  AS collation_name,
       CASE
           WHEN t.typtype = 'd'::"char" THEN current_database()
           ELSE NULL::name
           END::information_schema.sql_identifier                                                                                      AS domain_catalog,
       CASE
           WHEN t.typtype = 'd'::"char" THEN nt.nspname
           ELSE NULL::name
           END::information_schema.sql_identifier                                                                                      AS domain_schema,
       CASE
           WHEN t.typtype = 'd'::"char" THEN t.typname
           ELSE NULL::name
           END::information_schema.sql_identifier                                                                                      AS domain_name,
       current_database()::information_schema.sql_identifier                                                                           AS udt_catalog,
       COALESCE(nbt.nspname, nt.nspname)::information_schema.sql_identifier                                                            AS udt_schema,
       COALESCE(bt.typname, t.typname)::information_schema.sql_identifier                                                              AS udt_name,
       NULL::name::information_schema.sql_identifier                                                                                   AS scope_catalog,
       NULL::name::information_schema.sql_identifier                                                                                   AS scope_schema,
       NULL::name::information_schema.sql_identifier                                                                                   AS scope_name,
       NULL::integer::information_schema.cardinal_number                                                                               AS maximum_cardinality,
       a.attnum::information_schema.sql_identifier                                                                                     AS dtd_identifier,
       'NO'::character varying::information_schema.yes_or_no                                                                           AS is_self_referencing,
       CASE
           WHEN a.attidentity = ANY (ARRAY ['a'::"char", 'd'::"char"]) THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                                                                                           AS is_identity,
       CASE a.attidentity
           WHEN 'a'::"char" THEN 'ALWAYS'::text
           WHEN 'd'::"char" THEN 'BY DEFAULT'::text
           ELSE NULL::text
           END::information_schema.character_data                                                                                      AS identity_generation,
       seq.seqstart::information_schema.character_data                                                                                 AS identity_start,
       seq.seqincrement::information_schema.character_data                                                                             AS identity_increment,
       seq.seqmax::information_schema.character_data                                                                                   AS identity_maximum,
       seq.seqmin::information_schema.character_data                                                                                   AS identity_minimum,
       CASE
           WHEN seq.seqcycle THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                                                                                           AS identity_cycle,
       CASE
           WHEN a.attgenerated <> ''::"char" THEN 'ALWAYS'::text
           ELSE 'NEVER'::text
           END::information_schema.character_data                                                                                      AS is_generated,
       CASE
           WHEN a.attgenerated <> ''::"char" THEN pg_get_expr(ad.adbin, ad.adrelid)
           ELSE NULL::text
           END::information_schema.character_data                                                                                      AS generation_expression,
       CASE
           WHEN (c.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"])) OR
                (c.relkind = ANY (ARRAY ['v'::"char", 'f'::"char"])) AND
                pg_column_is_updatable(c.oid::regclass, a.attnum, false) THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                                                                                           AS is_updatable
FROM pg_attribute a
         LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum
         JOIN (pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid) ON a.attrelid = c.oid
         JOIN (pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON a.atttypid = t.oid
         LEFT JOIN (pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid) ON t.typtype = 'd'::"char" AND t.typbasetype = bt.oid
         LEFT JOIN (pg_collation co
    JOIN pg_namespace nco ON co.collnamespace = nco.oid)
                   ON a.attcollation = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)
         LEFT JOIN (pg_depend dep
    JOIN pg_sequence seq ON dep.classid = 'pg_class'::regclass::oid AND dep.objid = seq.seqrelid AND
                            dep.deptype = 'i'::"char")
                   ON dep.refclassid = 'pg_class'::regclass::oid AND dep.refobjid = c.oid AND dep.refobjsubid = a.attnum
WHERE NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > 0
  AND NOT a.attisdropped
  AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.columns
    owner to postgres;

grant select on information_schema.columns to public;

create view information_schema.constraint_column_usage
            (table_catalog, table_schema, table_name, column_name, constraint_catalog, constraint_schema,
             constraint_name) as
SELECT current_database()::information_schema.sql_identifier AS table_catalog,
       x.tblschema::information_schema.sql_identifier        AS table_schema,
       x.tblname::information_schema.sql_identifier          AS table_name,
       x.colname::information_schema.sql_identifier          AS column_name,
       current_database()::information_schema.sql_identifier AS constraint_catalog,
       x.cstrschema::information_schema.sql_identifier       AS constraint_schema,
       x.cstrname::information_schema.sql_identifier         AS constraint_name
FROM (SELECT DISTINCT nr.nspname,
                      r.relname,
                      r.relowner,
                      a.attname,
                      nc.nspname,
                      c.conname
      FROM pg_namespace nr,
           pg_class r,
           pg_attribute a,
           pg_depend d,
           pg_namespace nc,
           pg_constraint c
      WHERE nr.oid = r.relnamespace
        AND r.oid = a.attrelid
        AND d.refclassid = 'pg_class'::regclass::oid
        AND d.refobjid = r.oid
        AND d.refobjsubid = a.attnum
        AND d.classid = 'pg_constraint'::regclass::oid
        AND d.objid = c.oid
        AND c.connamespace = nc.oid
        AND c.contype = 'c'::"char"
        AND (r.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]))
        AND NOT a.attisdropped
      UNION ALL
      SELECT nr.nspname,
             r.relname,
             r.relowner,
             a.attname,
             nc.nspname,
             c.conname
      FROM pg_namespace nr,
           pg_class r,
           pg_attribute a,
           pg_namespace nc,
           pg_constraint c
      WHERE nr.oid = r.relnamespace
        AND r.oid = a.attrelid
        AND nc.oid = c.connamespace
        AND r.oid =
            CASE c.contype
                WHEN 'f'::"char" THEN c.confrelid
                ELSE c.conrelid
                END
        AND (a.attnum = ANY (
          CASE c.contype
              WHEN 'f'::"char" THEN c.confkey
              ELSE c.conkey
              END))
        AND NOT a.attisdropped
        AND (c.contype = ANY (ARRAY ['p'::"char", 'u'::"char", 'f'::"char"]))
        AND (r.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]))) x(tblschema, tblname, tblowner, colname, cstrschema, cstrname)
WHERE pg_has_role(x.tblowner, 'USAGE'::text);

alter table information_schema.constraint_column_usage
    owner to postgres;

grant select on information_schema.constraint_column_usage to public;

create view information_schema.constraint_table_usage
            (table_catalog, table_schema, table_name, constraint_catalog, constraint_schema, constraint_name) as
SELECT current_database()::information_schema.sql_identifier AS table_catalog,
       nr.nspname::information_schema.sql_identifier         AS table_schema,
       r.relname::information_schema.sql_identifier          AS table_name,
       current_database()::information_schema.sql_identifier AS constraint_catalog,
       nc.nspname::information_schema.sql_identifier         AS constraint_schema,
       c.conname::information_schema.sql_identifier          AS constraint_name
FROM pg_constraint c,
     pg_namespace nc,
     pg_class r,
     pg_namespace nr
WHERE c.connamespace = nc.oid
  AND r.relnamespace = nr.oid
  AND (c.contype = 'f'::"char" AND c.confrelid = r.oid OR
       (c.contype = ANY (ARRAY ['p'::"char", 'u'::"char"])) AND c.conrelid = r.oid)
  AND (r.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]))
  AND pg_has_role(r.relowner, 'USAGE'::text);

alter table information_schema.constraint_table_usage
    owner to postgres;

grant select on information_schema.constraint_table_usage to public;

create view information_schema.domain_constraints
            (constraint_catalog, constraint_schema, constraint_name, domain_catalog, domain_schema, domain_name,
             is_deferrable, initially_deferred)
as
SELECT current_database()::information_schema.sql_identifier AS constraint_catalog,
       rs.nspname::information_schema.sql_identifier         AS constraint_schema,
       con.conname::information_schema.sql_identifier        AS constraint_name,
       current_database()::information_schema.sql_identifier AS domain_catalog,
       n.nspname::information_schema.sql_identifier          AS domain_schema,
       t.typname::information_schema.sql_identifier          AS domain_name,
       CASE
           WHEN con.condeferrable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_deferrable,
       CASE
           WHEN con.condeferred THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS initially_deferred
FROM pg_namespace rs,
     pg_namespace n,
     pg_constraint con,
     pg_type t
WHERE rs.oid = con.connamespace
  AND n.oid = t.typnamespace
  AND t.oid = con.contypid
  AND (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text));

alter table information_schema.domain_constraints
    owner to postgres;

grant select on information_schema.domain_constraints to public;

create view information_schema.domain_udt_usage
            (udt_catalog, udt_schema, udt_name, domain_catalog, domain_schema, domain_name) as
SELECT current_database()::information_schema.sql_identifier AS udt_catalog,
       nbt.nspname::information_schema.sql_identifier        AS udt_schema,
       bt.typname::information_schema.sql_identifier         AS udt_name,
       current_database()::information_schema.sql_identifier AS domain_catalog,
       nt.nspname::information_schema.sql_identifier         AS domain_schema,
       t.typname::information_schema.sql_identifier          AS domain_name
FROM pg_type t,
     pg_namespace nt,
     pg_type bt,
     pg_namespace nbt
WHERE t.typnamespace = nt.oid
  AND t.typbasetype = bt.oid
  AND bt.typnamespace = nbt.oid
  AND t.typtype = 'd'::"char"
  AND pg_has_role(bt.typowner, 'USAGE'::text);

alter table information_schema.domain_udt_usage
    owner to postgres;

grant select on information_schema.domain_udt_usage to public;

create view information_schema.domains
            (domain_catalog, domain_schema, domain_name, data_type, character_maximum_length, character_octet_length,
             character_set_catalog, character_set_schema, character_set_name, collation_catalog, collation_schema,
             collation_name, numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision,
             interval_type, interval_precision, domain_default, udt_catalog, udt_schema, udt_name, scope_catalog,
             scope_schema, scope_name, maximum_cardinality, dtd_identifier)
as
SELECT current_database()::information_schema.sql_identifier                                                          AS domain_catalog,
       nt.nspname::information_schema.sql_identifier                                                                  AS domain_schema,
       t.typname::information_schema.sql_identifier                                                                   AS domain_name,
       CASE
           WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text
           WHEN nbt.nspname = 'pg_catalog'::name THEN format_type(t.typbasetype, NULL::integer)
           ELSE 'USER-DEFINED'::text
           END::information_schema.character_data                                                                     AS data_type,
       information_schema._pg_char_max_length(t.typbasetype, t.typtypmod)::information_schema.cardinal_number         AS character_maximum_length,
       information_schema._pg_char_octet_length(t.typbasetype,
                                                t.typtypmod)::information_schema.cardinal_number                      AS character_octet_length,
       NULL::name::information_schema.sql_identifier                                                                  AS character_set_catalog,
       NULL::name::information_schema.sql_identifier                                                                  AS character_set_schema,
       NULL::name::information_schema.sql_identifier                                                                  AS character_set_name,
       CASE
           WHEN nco.nspname IS NOT NULL THEN current_database()
           ELSE NULL::name
           END::information_schema.sql_identifier                                                                     AS collation_catalog,
       nco.nspname::information_schema.sql_identifier                                                                 AS collation_schema,
       co.collname::information_schema.sql_identifier                                                                 AS collation_name,
       information_schema._pg_numeric_precision(t.typbasetype,
                                                t.typtypmod)::information_schema.cardinal_number                      AS numeric_precision,
       information_schema._pg_numeric_precision_radix(t.typbasetype,
                                                      t.typtypmod)::information_schema.cardinal_number                AS numeric_precision_radix,
       information_schema._pg_numeric_scale(t.typbasetype, t.typtypmod)::information_schema.cardinal_number           AS numeric_scale,
       information_schema._pg_datetime_precision(t.typbasetype,
                                                 t.typtypmod)::information_schema.cardinal_number                     AS datetime_precision,
       information_schema._pg_interval_type(t.typbasetype, t.typtypmod)::information_schema.character_data            AS interval_type,
       NULL::integer::information_schema.cardinal_number                                                              AS interval_precision,
       t.typdefault::information_schema.character_data                                                                AS domain_default,
       current_database()::information_schema.sql_identifier                                                          AS udt_catalog,
       nbt.nspname::information_schema.sql_identifier                                                                 AS udt_schema,
       bt.typname::information_schema.sql_identifier                                                                  AS udt_name,
       NULL::name::information_schema.sql_identifier                                                                  AS scope_catalog,
       NULL::name::information_schema.sql_identifier                                                                  AS scope_schema,
       NULL::name::information_schema.sql_identifier                                                                  AS scope_name,
       NULL::integer::information_schema.cardinal_number                                                              AS maximum_cardinality,
       1::information_schema.sql_identifier                                                                           AS dtd_identifier
FROM pg_type t
         JOIN pg_namespace nt ON t.typnamespace = nt.oid
         JOIN (pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid) ON t.typbasetype = bt.oid AND t.typtype = 'd'::"char"
         LEFT JOIN (pg_collation co
    JOIN pg_namespace nco ON co.collnamespace = nco.oid)
                   ON t.typcollation = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)
WHERE pg_has_role(t.typowner, 'USAGE'::text)
   OR has_type_privilege(t.oid, 'USAGE'::text);

alter table information_schema.domains
    owner to postgres;

grant select on information_schema.domains to public;

create view information_schema.enabled_roles(role_name) as
SELECT a.rolname::information_schema.sql_identifier AS role_name
FROM pg_authid a
WHERE pg_has_role(a.oid, 'USAGE'::text);

alter table information_schema.enabled_roles
    owner to postgres;

grant select on information_schema.enabled_roles to public;

create view information_schema.key_column_usage
            (constraint_catalog, constraint_schema, constraint_name, table_catalog, table_schema, table_name,
             column_name, ordinal_position, position_in_unique_constraint)
as
SELECT current_database()::information_schema.sql_identifier AS constraint_catalog,
       ss.nc_nspname::information_schema.sql_identifier      AS constraint_schema,
       ss.conname::information_schema.sql_identifier         AS constraint_name,
       current_database()::information_schema.sql_identifier AS table_catalog,
       ss.nr_nspname::information_schema.sql_identifier      AS table_schema,
       ss.relname::information_schema.sql_identifier         AS table_name,
       a.attname::information_schema.sql_identifier          AS column_name,
       (ss.x).n::information_schema.cardinal_number          AS ordinal_position,
       CASE
           WHEN ss.contype = 'f'::"char" THEN information_schema._pg_index_position(ss.conindid, ss.confkey[(ss.x).n])
           ELSE NULL::integer
           END::information_schema.cardinal_number           AS position_in_unique_constraint
FROM pg_attribute a,
     (SELECT r.oid                                        AS roid,
             r.relname,
             r.relowner,
             nc.nspname                                   AS nc_nspname,
             nr.nspname                                   AS nr_nspname,
             c.oid                                        AS coid,
             c.conname,
             c.contype,
             c.conindid,
             c.confkey,
             c.confrelid,
             information_schema._pg_expandarray(c.conkey) AS x
      FROM pg_namespace nr,
           pg_class r,
           pg_namespace nc,
           pg_constraint c
      WHERE nr.oid = r.relnamespace
        AND r.oid = c.conrelid
        AND nc.oid = c.connamespace
        AND (c.contype = ANY (ARRAY ['p'::"char", 'u'::"char", 'f'::"char"]))
        AND (r.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]))
        AND NOT pg_is_other_temp_schema(nr.oid)) ss
WHERE ss.roid = a.attrelid
  AND a.attnum = (ss.x).x
  AND NOT a.attisdropped
  AND (pg_has_role(ss.relowner, 'USAGE'::text) OR
       has_column_privilege(ss.roid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.key_column_usage
    owner to postgres;

grant select on information_schema.key_column_usage to public;

create view information_schema.parameters
            (specific_catalog, specific_schema, specific_name, ordinal_position, parameter_mode, is_result, as_locator,
             parameter_name, data_type, character_maximum_length, character_octet_length, character_set_catalog,
             character_set_schema, character_set_name, collation_catalog, collation_schema, collation_name,
             numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision, interval_type,
             interval_precision, udt_catalog, udt_schema, udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier, parameter_default)
as
SELECT current_database()::information_schema.sql_identifier                         AS specific_catalog,
       ss.n_nspname::information_schema.sql_identifier                               AS specific_schema,
       nameconcatoid(ss.proname, ss.p_oid)::information_schema.sql_identifier        AS specific_name,
       (ss.x).n::information_schema.cardinal_number                                  AS ordinal_position,
       CASE
           WHEN ss.proargmodes IS NULL THEN 'IN'::text
           WHEN ss.proargmodes[(ss.x).n] = 'i'::"char" THEN 'IN'::text
           WHEN ss.proargmodes[(ss.x).n] = 'o'::"char" THEN 'OUT'::text
           WHEN ss.proargmodes[(ss.x).n] = 'b'::"char" THEN 'INOUT'::text
           WHEN ss.proargmodes[(ss.x).n] = 'v'::"char" THEN 'IN'::text
           WHEN ss.proargmodes[(ss.x).n] = 't'::"char" THEN 'OUT'::text
           ELSE NULL::text
           END::information_schema.character_data                                    AS parameter_mode,
       'NO'::character varying::information_schema.yes_or_no                         AS is_result,
       'NO'::character varying::information_schema.yes_or_no                         AS as_locator,
       NULLIF(ss.proargnames[(ss.x).n], ''::text)::information_schema.sql_identifier AS parameter_name,
       CASE
           WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text
           WHEN nt.nspname = 'pg_catalog'::name THEN format_type(t.oid, NULL::integer)
           ELSE 'USER-DEFINED'::text
           END::information_schema.character_data                                    AS data_type,
       NULL::integer::information_schema.cardinal_number                             AS character_maximum_length,
       NULL::integer::information_schema.cardinal_number                             AS character_octet_length,
       NULL::name::information_schema.sql_identifier                                 AS character_set_catalog,
       NULL::name::information_schema.sql_identifier                                 AS character_set_schema,
       NULL::name::information_schema.sql_identifier                                 AS character_set_name,
       NULL::name::information_schema.sql_identifier                                 AS collation_catalog,
       NULL::name::information_schema.sql_identifier                                 AS collation_schema,
       NULL::name::information_schema.sql_identifier                                 AS collation_name,
       NULL::integer::information_schema.cardinal_number                             AS numeric_precision,
       NULL::integer::information_schema.cardinal_number                             AS numeric_precision_radix,
       NULL::integer::information_schema.cardinal_number                             AS numeric_scale,
       NULL::integer::information_schema.cardinal_number                             AS datetime_precision,
       NULL::character varying::information_schema.character_data                    AS interval_type,
       NULL::integer::information_schema.cardinal_number                             AS interval_precision,
       current_database()::information_schema.sql_identifier                         AS udt_catalog,
       nt.nspname::information_schema.sql_identifier                                 AS udt_schema,
       t.typname::information_schema.sql_identifier                                  AS udt_name,
       NULL::name::information_schema.sql_identifier                                 AS scope_catalog,
       NULL::name::information_schema.sql_identifier                                 AS scope_schema,
       NULL::name::information_schema.sql_identifier                                 AS scope_name,
       NULL::integer::information_schema.cardinal_number                             AS maximum_cardinality,
       (ss.x).n::information_schema.sql_identifier                                   AS dtd_identifier,
       CASE
           WHEN pg_has_role(ss.proowner, 'USAGE'::text) THEN pg_get_function_arg_default(ss.p_oid, (ss.x).n)
           ELSE NULL::text
           END::information_schema.character_data                                    AS parameter_default
FROM pg_type t,
     pg_namespace nt,
     (SELECT n.nspname                                                                            AS n_nspname,
             p.proname,
             p.oid                                                                                AS p_oid,
             p.proowner,
             p.proargnames,
             p.proargmodes,
             information_schema._pg_expandarray(COALESCE(p.proallargtypes, p.proargtypes::oid[])) AS x
      FROM pg_namespace n,
           pg_proc p
      WHERE n.oid = p.pronamespace
        AND (pg_has_role(p.proowner, 'USAGE'::text) OR has_function_privilege(p.oid, 'EXECUTE'::text))) ss
WHERE t.oid = (ss.x).x
  AND t.typnamespace = nt.oid;

alter table information_schema.parameters
    owner to postgres;

grant select on information_schema.parameters to public;

create view information_schema.referential_constraints
            (constraint_catalog, constraint_schema, constraint_name, unique_constraint_catalog,
             unique_constraint_schema, unique_constraint_name, match_option, update_rule, delete_rule)
as
SELECT current_database()::information_schema.sql_identifier AS constraint_catalog,
       ncon.nspname::information_schema.sql_identifier       AS constraint_schema,
       con.conname::information_schema.sql_identifier        AS constraint_name,
       CASE
           WHEN npkc.nspname IS NULL THEN NULL::name
           ELSE current_database()
           END::information_schema.sql_identifier            AS unique_constraint_catalog,
       npkc.nspname::information_schema.sql_identifier       AS unique_constraint_schema,
       pkc.conname::information_schema.sql_identifier        AS unique_constraint_name,
       CASE con.confmatchtype
           WHEN 'f'::"char" THEN 'FULL'::text
           WHEN 'p'::"char" THEN 'PARTIAL'::text
           WHEN 's'::"char" THEN 'NONE'::text
           ELSE NULL::text
           END::information_schema.character_data            AS match_option,
       CASE con.confupdtype
           WHEN 'c'::"char" THEN 'CASCADE'::text
           WHEN 'n'::"char" THEN 'SET NULL'::text
           WHEN 'd'::"char" THEN 'SET DEFAULT'::text
           WHEN 'r'::"char" THEN 'RESTRICT'::text
           WHEN 'a'::"char" THEN 'NO ACTION'::text
           ELSE NULL::text
           END::information_schema.character_data            AS update_rule,
       CASE con.confdeltype
           WHEN 'c'::"char" THEN 'CASCADE'::text
           WHEN 'n'::"char" THEN 'SET NULL'::text
           WHEN 'd'::"char" THEN 'SET DEFAULT'::text
           WHEN 'r'::"char" THEN 'RESTRICT'::text
           WHEN 'a'::"char" THEN 'NO ACTION'::text
           ELSE NULL::text
           END::information_schema.character_data            AS delete_rule
FROM pg_namespace ncon
         JOIN pg_constraint con ON ncon.oid = con.connamespace
         JOIN pg_class c ON con.conrelid = c.oid AND con.contype = 'f'::"char"
         LEFT JOIN pg_depend d1 ON d1.objid = con.oid AND d1.classid = 'pg_constraint'::regclass::oid AND
                                   d1.refclassid = 'pg_class'::regclass::oid AND d1.refobjsubid = 0
         LEFT JOIN pg_depend d2
                   ON d2.refclassid = 'pg_constraint'::regclass::oid AND d2.classid = 'pg_class'::regclass::oid AND
                      d2.objid = d1.refobjid AND d2.objsubid = 0 AND d2.deptype = 'i'::"char"
         LEFT JOIN pg_constraint pkc
                   ON pkc.oid = d2.refobjid AND (pkc.contype = ANY (ARRAY ['p'::"char", 'u'::"char"])) AND
                      pkc.conrelid = con.confrelid
         LEFT JOIN pg_namespace npkc ON pkc.connamespace = npkc.oid
WHERE pg_has_role(c.relowner, 'USAGE'::text)
   OR has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text)
   OR has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text);

alter table information_schema.referential_constraints
    owner to postgres;

grant select on information_schema.referential_constraints to public;

create view information_schema.role_column_grants
            (grantor, grantee, table_catalog, table_schema, table_name, column_name, privilege_type, is_grantable) as
SELECT column_privileges.grantor,
       column_privileges.grantee,
       column_privileges.table_catalog,
       column_privileges.table_schema,
       column_privileges.table_name,
       column_privileges.column_name,
       column_privileges.privilege_type,
       column_privileges.is_grantable
FROM information_schema.column_privileges
WHERE (column_privileges.grantor::name IN (SELECT enabled_roles.role_name
                                           FROM information_schema.enabled_roles))
   OR (column_privileges.grantee::name IN (SELECT enabled_roles.role_name
                                           FROM information_schema.enabled_roles));

alter table information_schema.role_column_grants
    owner to postgres;

grant select on information_schema.role_column_grants to public;

create view information_schema.routine_privileges
            (grantor, grantee, specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema,
             routine_name, privilege_type, is_grantable)
as
SELECT u_grantor.rolname::information_schema.sql_identifier               AS grantor,
       grantee.rolname::information_schema.sql_identifier                 AS grantee,
       current_database()::information_schema.sql_identifier              AS specific_catalog,
       n.nspname::information_schema.sql_identifier                       AS specific_schema,
       nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,
       current_database()::information_schema.sql_identifier              AS routine_catalog,
       n.nspname::information_schema.sql_identifier                       AS routine_schema,
       p.proname::information_schema.sql_identifier                       AS routine_name,
       'EXECUTE'::character varying::information_schema.character_data    AS privilege_type,
       CASE
           WHEN pg_has_role(grantee.oid, p.proowner, 'USAGE'::text) OR p.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                              AS is_grantable
FROM (SELECT pg_proc.oid,
             pg_proc.proname,
             pg_proc.proowner,
             pg_proc.pronamespace,
             (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::"char", pg_proc.proowner)))).grantor        AS grantor,
             (aclexplode(COALESCE(pg_proc.proacl,
                                  acldefault('f'::"char", pg_proc.proowner)))).grantee                        AS grantee,
             (aclexplode(COALESCE(pg_proc.proacl,
                                  acldefault('f'::"char", pg_proc.proowner)))).privilege_type                 AS privilege_type,
             (aclexplode(COALESCE(pg_proc.proacl,
                                  acldefault('f'::"char", pg_proc.proowner)))).is_grantable                   AS is_grantable
      FROM pg_proc) p(oid, proname, proowner, pronamespace, grantor, grantee, prtype, grantable),
     pg_namespace n,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE p.pronamespace = n.oid
  AND grantee.oid = p.grantee
  AND u_grantor.oid = p.grantor
  AND p.prtype = 'EXECUTE'::text
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name);

alter table information_schema.routine_privileges
    owner to postgres;

grant select on information_schema.routine_privileges to public;

create view information_schema.role_routine_grants
            (grantor, grantee, specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema,
             routine_name, privilege_type, is_grantable)
as
SELECT routine_privileges.grantor,
       routine_privileges.grantee,
       routine_privileges.specific_catalog,
       routine_privileges.specific_schema,
       routine_privileges.specific_name,
       routine_privileges.routine_catalog,
       routine_privileges.routine_schema,
       routine_privileges.routine_name,
       routine_privileges.privilege_type,
       routine_privileges.is_grantable
FROM information_schema.routine_privileges
WHERE (routine_privileges.grantor::name IN (SELECT enabled_roles.role_name
                                            FROM information_schema.enabled_roles))
   OR (routine_privileges.grantee::name IN (SELECT enabled_roles.role_name
                                            FROM information_schema.enabled_roles));

alter table information_schema.role_routine_grants
    owner to postgres;

grant select on information_schema.role_routine_grants to public;

create view information_schema.routines
            (specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema, routine_name,
             routine_type, module_catalog, module_schema, module_name, udt_catalog, udt_schema, udt_name, data_type,
             character_maximum_length, character_octet_length, character_set_catalog, character_set_schema,
             character_set_name, collation_catalog, collation_schema, collation_name, numeric_precision,
             numeric_precision_radix, numeric_scale, datetime_precision, interval_type, interval_precision,
             type_udt_catalog, type_udt_schema, type_udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier, routine_body, routine_definition, external_name, external_language,
             parameter_style, is_deterministic, sql_data_access, is_null_call, sql_path, schema_level_routine,
             max_dynamic_result_sets, is_user_defined_cast, is_implicitly_invocable, security_type,
             to_sql_specific_catalog, to_sql_specific_schema, to_sql_specific_name, as_locator, created, last_altered,
             new_savepoint_level, is_udt_dependent, result_cast_from_data_type, result_cast_as_locator,
             result_cast_char_max_length, result_cast_char_octet_length, result_cast_char_set_catalog,
             result_cast_char_set_schema, result_cast_char_set_name, result_cast_collation_catalog,
             result_cast_collation_schema, result_cast_collation_name, result_cast_numeric_precision,
             result_cast_numeric_precision_radix, result_cast_numeric_scale, result_cast_datetime_precision,
             result_cast_interval_type, result_cast_interval_precision, result_cast_type_udt_catalog,
             result_cast_type_udt_schema, result_cast_type_udt_name, result_cast_scope_catalog,
             result_cast_scope_schema, result_cast_scope_name, result_cast_maximum_cardinality,
             result_cast_dtd_identifier)
as
SELECT current_database()::information_schema.sql_identifier              AS specific_catalog,
       n.nspname::information_schema.sql_identifier                       AS specific_schema,
       nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,
       current_database()::information_schema.sql_identifier              AS routine_catalog,
       n.nspname::information_schema.sql_identifier                       AS routine_schema,
       p.proname::information_schema.sql_identifier                       AS routine_name,
       CASE p.prokind
           WHEN 'f'::"char" THEN 'FUNCTION'::text
           WHEN 'p'::"char" THEN 'PROCEDURE'::text
           ELSE NULL::text
           END::information_schema.character_data                         AS routine_type,
       NULL::name::information_schema.sql_identifier                      AS module_catalog,
       NULL::name::information_schema.sql_identifier                      AS module_schema,
       NULL::name::information_schema.sql_identifier                      AS module_name,
       NULL::name::information_schema.sql_identifier                      AS udt_catalog,
       NULL::name::information_schema.sql_identifier                      AS udt_schema,
       NULL::name::information_schema.sql_identifier                      AS udt_name,
       CASE
           WHEN p.prokind = 'p'::"char" THEN NULL::text
           WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text
           WHEN nt.nspname = 'pg_catalog'::name THEN format_type(t.oid, NULL::integer)
           ELSE 'USER-DEFINED'::text
           END::information_schema.character_data                         AS data_type,
       NULL::integer::information_schema.cardinal_number                  AS character_maximum_length,
       NULL::integer::information_schema.cardinal_number                  AS character_octet_length,
       NULL::name::information_schema.sql_identifier                      AS character_set_catalog,
       NULL::name::information_schema.sql_identifier                      AS character_set_schema,
       NULL::name::information_schema.sql_identifier                      AS character_set_name,
       NULL::name::information_schema.sql_identifier                      AS collation_catalog,
       NULL::name::information_schema.sql_identifier                      AS collation_schema,
       NULL::name::information_schema.sql_identifier                      AS collation_name,
       NULL::integer::information_schema.cardinal_number                  AS numeric_precision,
       NULL::integer::information_schema.cardinal_number                  AS numeric_precision_radix,
       NULL::integer::information_schema.cardinal_number                  AS numeric_scale,
       NULL::integer::information_schema.cardinal_number                  AS datetime_precision,
       NULL::character varying::information_schema.character_data         AS interval_type,
       NULL::integer::information_schema.cardinal_number                  AS interval_precision,
       CASE
           WHEN nt.nspname IS NOT NULL THEN current_database()
           ELSE NULL::name
           END::information_schema.sql_identifier                         AS type_udt_catalog,
       nt.nspname::information_schema.sql_identifier                      AS type_udt_schema,
       t.typname::information_schema.sql_identifier                       AS type_udt_name,
       NULL::name::information_schema.sql_identifier                      AS scope_catalog,
       NULL::name::information_schema.sql_identifier                      AS scope_schema,
       NULL::name::information_schema.sql_identifier                      AS scope_name,
       NULL::integer::information_schema.cardinal_number                  AS maximum_cardinality,
       CASE
           WHEN p.prokind <> 'p'::"char" THEN 0
           ELSE NULL::integer
           END::information_schema.sql_identifier                         AS dtd_identifier,
       CASE
           WHEN l.lanname = 'sql'::name THEN 'SQL'::text
           ELSE 'EXTERNAL'::text
           END::information_schema.character_data                         AS routine_body,
       CASE
           WHEN pg_has_role(p.proowner, 'USAGE'::text) THEN p.prosrc
           ELSE NULL::text
           END::information_schema.character_data                         AS routine_definition,
       CASE
           WHEN l.lanname = 'c'::name THEN p.prosrc
           ELSE NULL::text
           END::information_schema.character_data                         AS external_name,
       upper(l.lanname::text)::information_schema.character_data          AS external_language,
       'GENERAL'::character varying::information_schema.character_data    AS parameter_style,
       CASE
           WHEN p.provolatile = 'i'::"char" THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                              AS is_deterministic,
       'MODIFIES'::character varying::information_schema.character_data   AS sql_data_access,
       CASE
           WHEN p.prokind <> 'p'::"char" THEN
               CASE
                   WHEN p.proisstrict THEN 'YES'::text
                   ELSE 'NO'::text
                   END
           ELSE NULL::text
           END::information_schema.yes_or_no                              AS is_null_call,
       NULL::character varying::information_schema.character_data         AS sql_path,
       'YES'::character varying::information_schema.yes_or_no             AS schema_level_routine,
       0::information_schema.cardinal_number                              AS max_dynamic_result_sets,
       NULL::character varying::information_schema.yes_or_no              AS is_user_defined_cast,
       NULL::character varying::information_schema.yes_or_no              AS is_implicitly_invocable,
       CASE
           WHEN p.prosecdef THEN 'DEFINER'::text
           ELSE 'INVOKER'::text
           END::information_schema.character_data                         AS security_type,
       NULL::name::information_schema.sql_identifier                      AS to_sql_specific_catalog,
       NULL::name::information_schema.sql_identifier                      AS to_sql_specific_schema,
       NULL::name::information_schema.sql_identifier                      AS to_sql_specific_name,
       'NO'::character varying::information_schema.yes_or_no              AS as_locator,
       NULL::timestamp with time zone::information_schema.time_stamp      AS created,
       NULL::timestamp with time zone::information_schema.time_stamp      AS last_altered,
       NULL::character varying::information_schema.yes_or_no              AS new_savepoint_level,
       'NO'::character varying::information_schema.yes_or_no              AS is_udt_dependent,
       NULL::character varying::information_schema.character_data         AS result_cast_from_data_type,
       NULL::character varying::information_schema.yes_or_no              AS result_cast_as_locator,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_char_max_length,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_char_octet_length,
       NULL::name::information_schema.sql_identifier                      AS result_cast_char_set_catalog,
       NULL::name::information_schema.sql_identifier                      AS result_cast_char_set_schema,
       NULL::name::information_schema.sql_identifier                      AS result_cast_char_set_name,
       NULL::name::information_schema.sql_identifier                      AS result_cast_collation_catalog,
       NULL::name::information_schema.sql_identifier                      AS result_cast_collation_schema,
       NULL::name::information_schema.sql_identifier                      AS result_cast_collation_name,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_numeric_precision,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_numeric_precision_radix,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_numeric_scale,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_datetime_precision,
       NULL::character varying::information_schema.character_data         AS result_cast_interval_type,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_interval_precision,
       NULL::name::information_schema.sql_identifier                      AS result_cast_type_udt_catalog,
       NULL::name::information_schema.sql_identifier                      AS result_cast_type_udt_schema,
       NULL::name::information_schema.sql_identifier                      AS result_cast_type_udt_name,
       NULL::name::information_schema.sql_identifier                      AS result_cast_scope_catalog,
       NULL::name::information_schema.sql_identifier                      AS result_cast_scope_schema,
       NULL::name::information_schema.sql_identifier                      AS result_cast_scope_name,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_maximum_cardinality,
       NULL::name::information_schema.sql_identifier                      AS result_cast_dtd_identifier
FROM pg_namespace n
         JOIN pg_proc p ON n.oid = p.pronamespace
         JOIN pg_language l ON p.prolang = l.oid
         LEFT JOIN (pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON p.prorettype = t.oid AND p.prokind <> 'p'::"char"
WHERE pg_has_role(p.proowner, 'USAGE'::text)
   OR has_function_privilege(p.oid, 'EXECUTE'::text);

alter table information_schema.routines
    owner to postgres;

grant select on information_schema.routines to public;

create view information_schema.schemata
            (catalog_name, schema_name, schema_owner, default_character_set_catalog, default_character_set_schema,
             default_character_set_name, sql_path)
as
SELECT current_database()::information_schema.sql_identifier      AS catalog_name,
       n.nspname::information_schema.sql_identifier               AS schema_name,
       u.rolname::information_schema.sql_identifier               AS schema_owner,
       NULL::name::information_schema.sql_identifier              AS default_character_set_catalog,
       NULL::name::information_schema.sql_identifier              AS default_character_set_schema,
       NULL::name::information_schema.sql_identifier              AS default_character_set_name,
       NULL::character varying::information_schema.character_data AS sql_path
FROM pg_namespace n,
     pg_authid u
WHERE n.nspowner = u.oid
  AND (pg_has_role(n.nspowner, 'USAGE'::text) OR has_schema_privilege(n.oid, 'CREATE, USAGE'::text));

alter table information_schema.schemata
    owner to postgres;

grant select on information_schema.schemata to public;

create view information_schema.sequences
            (sequence_catalog, sequence_schema, sequence_name, data_type, numeric_precision, numeric_precision_radix,
             numeric_scale, start_value, minimum_value, maximum_value, increment, cycle_option)
as
SELECT current_database()::information_schema.sql_identifier                                                   AS sequence_catalog,
       nc.nspname::information_schema.sql_identifier                                                           AS sequence_schema,
       c.relname::information_schema.sql_identifier                                                            AS sequence_name,
       format_type(s.seqtypid, NULL::integer)::information_schema.character_data                               AS data_type,
       information_schema._pg_numeric_precision(s.seqtypid, '-1'::integer)::information_schema.cardinal_number AS numeric_precision,
       2::information_schema.cardinal_number                                                                   AS numeric_precision_radix,
       0::information_schema.cardinal_number                                                                   AS numeric_scale,
       s.seqstart::information_schema.character_data                                                           AS start_value,
       s.seqmin::information_schema.character_data                                                             AS minimum_value,
       s.seqmax::information_schema.character_data                                                             AS maximum_value,
       s.seqincrement::information_schema.character_data                                                       AS increment,
       CASE
           WHEN s.seqcycle THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                                                                   AS cycle_option
FROM pg_namespace nc,
     pg_class c,
     pg_sequence s
WHERE c.relnamespace = nc.oid
  AND c.relkind = 'S'::"char"
  AND NOT (EXISTS(SELECT 1
                  FROM pg_depend
                  WHERE pg_depend.classid = 'pg_class'::regclass::oid
                    AND pg_depend.objid = c.oid
                    AND pg_depend.deptype = 'i'::"char"))
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND c.oid = s.seqrelid
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_sequence_privilege(c.oid, 'SELECT, UPDATE, USAGE'::text));

alter table information_schema.sequences
    owner to postgres;

grant select on information_schema.sequences to public;

create view information_schema.table_constraints
            (constraint_catalog, constraint_schema, constraint_name, table_catalog, table_schema, table_name,
             constraint_type, is_deferrable, initially_deferred, enforced)
as
SELECT current_database()::information_schema.sql_identifier  AS constraint_catalog,
       nc.nspname::information_schema.sql_identifier          AS constraint_schema,
       c.conname::information_schema.sql_identifier           AS constraint_name,
       current_database()::information_schema.sql_identifier  AS table_catalog,
       nr.nspname::information_schema.sql_identifier          AS table_schema,
       r.relname::information_schema.sql_identifier           AS table_name,
       CASE c.contype
           WHEN 'c'::"char" THEN 'CHECK'::text
           WHEN 'f'::"char" THEN 'FOREIGN KEY'::text
           WHEN 'p'::"char" THEN 'PRIMARY KEY'::text
           WHEN 'u'::"char" THEN 'UNIQUE'::text
           ELSE NULL::text
           END::information_schema.character_data             AS constraint_type,
       CASE
           WHEN c.condeferrable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                  AS is_deferrable,
       CASE
           WHEN c.condeferred THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                  AS initially_deferred,
       'YES'::character varying::information_schema.yes_or_no AS enforced
FROM pg_namespace nc,
     pg_namespace nr,
     pg_constraint c,
     pg_class r
WHERE nc.oid = c.connamespace
  AND nr.oid = r.relnamespace
  AND c.conrelid = r.oid
  AND (c.contype <> ALL (ARRAY ['t'::"char", 'x'::"char"]))
  AND (r.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]))
  AND NOT pg_is_other_temp_schema(nr.oid)
  AND (pg_has_role(r.relowner, 'USAGE'::text) OR
       has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
       has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES'::text))
UNION ALL
SELECT current_database()::information_schema.sql_identifier         AS constraint_catalog,
       nr.nspname::information_schema.sql_identifier                 AS constraint_schema,
       (((((nr.oid::text || '_'::text) || r.oid::text) || '_'::text) || a.attnum::text) ||
        '_not_null'::text)::information_schema.sql_identifier        AS constraint_name,
       current_database()::information_schema.sql_identifier         AS table_catalog,
       nr.nspname::information_schema.sql_identifier                 AS table_schema,
       r.relname::information_schema.sql_identifier                  AS table_name,
       'CHECK'::character varying::information_schema.character_data AS constraint_type,
       'NO'::character varying::information_schema.yes_or_no         AS is_deferrable,
       'NO'::character varying::information_schema.yes_or_no         AS initially_deferred,
       'YES'::character varying::information_schema.yes_or_no        AS enforced
FROM pg_namespace nr,
     pg_class r,
     pg_attribute a
WHERE nr.oid = r.relnamespace
  AND r.oid = a.attrelid
  AND a.attnotnull
  AND a.attnum > 0
  AND NOT a.attisdropped
  AND (r.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]))
  AND NOT pg_is_other_temp_schema(nr.oid)
  AND (pg_has_role(r.relowner, 'USAGE'::text) OR
       has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
       has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.table_constraints
    owner to postgres;

grant select on information_schema.table_constraints to public;

create view information_schema.table_privileges
            (grantor, grantee, table_catalog, table_schema, table_name, privilege_type, is_grantable, with_hierarchy) as
SELECT u_grantor.rolname::information_schema.sql_identifier  AS grantor,
       grantee.rolname::information_schema.sql_identifier    AS grantee,
       current_database()::information_schema.sql_identifier AS table_catalog,
       nc.nspname::information_schema.sql_identifier         AS table_schema,
       c.relname::information_schema.sql_identifier          AS table_name,
       c.prtype::information_schema.character_data           AS privilege_type,
       CASE
           WHEN pg_has_role(grantee.oid, c.relowner, 'USAGE'::text) OR c.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_grantable,
       CASE
           WHEN c.prtype = 'SELECT'::text THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS with_hierarchy
FROM (SELECT pg_class.oid,
             pg_class.relname,
             pg_class.relnamespace,
             pg_class.relkind,
             pg_class.relowner,
             (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantor        AS grantor,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).grantee                         AS grantee,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).privilege_type                  AS privilege_type,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).is_grantable                    AS is_grantable
      FROM pg_class) c(oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),
     pg_namespace nc,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE c.relnamespace = nc.oid
  AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND c.grantee = grantee.oid
  AND c.grantor = u_grantor.oid
  AND (c.prtype = ANY
       (ARRAY ['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'DELETE'::text, 'TRUNCATE'::text, 'REFERENCES'::text, 'TRIGGER'::text]))
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name);

alter table information_schema.table_privileges
    owner to postgres;

grant select on information_schema.table_privileges to public;

create view information_schema.role_table_grants
            (grantor, grantee, table_catalog, table_schema, table_name, privilege_type, is_grantable, with_hierarchy) as
SELECT table_privileges.grantor,
       table_privileges.grantee,
       table_privileges.table_catalog,
       table_privileges.table_schema,
       table_privileges.table_name,
       table_privileges.privilege_type,
       table_privileges.is_grantable,
       table_privileges.with_hierarchy
FROM information_schema.table_privileges
WHERE (table_privileges.grantor::name IN (SELECT enabled_roles.role_name
                                          FROM information_schema.enabled_roles))
   OR (table_privileges.grantee::name IN (SELECT enabled_roles.role_name
                                          FROM information_schema.enabled_roles));

alter table information_schema.role_table_grants
    owner to postgres;

grant select on information_schema.role_table_grants to public;

create view information_schema.tables
            (table_catalog, table_schema, table_name, table_type, self_referencing_column_name, reference_generation,
             user_defined_type_catalog, user_defined_type_schema, user_defined_type_name, is_insertable_into, is_typed,
             commit_action)
as
SELECT current_database()::information_schema.sql_identifier      AS table_catalog,
       nc.nspname::information_schema.sql_identifier              AS table_schema,
       c.relname::information_schema.sql_identifier               AS table_name,
       CASE
           WHEN nc.oid = pg_my_temp_schema() THEN 'LOCAL TEMPORARY'::text
           WHEN c.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]) THEN 'BASE TABLE'::text
           WHEN c.relkind = 'v'::"char" THEN 'VIEW'::text
           WHEN c.relkind = 'f'::"char" THEN 'FOREIGN'::text
           ELSE NULL::text
           END::information_schema.character_data                 AS table_type,
       NULL::name::information_schema.sql_identifier              AS self_referencing_column_name,
       NULL::character varying::information_schema.character_data AS reference_generation,
       CASE
           WHEN t.typname IS NOT NULL THEN current_database()
           ELSE NULL::name
           END::information_schema.sql_identifier                 AS user_defined_type_catalog,
       nt.nspname::information_schema.sql_identifier              AS user_defined_type_schema,
       t.typname::information_schema.sql_identifier               AS user_defined_type_name,
       CASE
           WHEN (c.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"])) OR
                (c.relkind = ANY (ARRAY ['v'::"char", 'f'::"char"])) AND
                (pg_relation_is_updatable(c.oid::regclass, false) & 8) = 8 THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                      AS is_insertable_into,
       CASE
           WHEN t.typname IS NOT NULL THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                      AS is_typed,
       NULL::character varying::information_schema.character_data AS commit_action
FROM pg_namespace nc
         JOIN pg_class c ON nc.oid = c.relnamespace
         LEFT JOIN (pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON c.reloftype = t.oid
WHERE (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
       has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.tables
    owner to postgres;

grant select on information_schema.tables to public;

create view information_schema.transforms
            (udt_catalog, udt_schema, udt_name, specific_catalog, specific_schema, specific_name, group_name,
             transform_type) as
SELECT current_database()::information_schema.sql_identifier              AS udt_catalog,
       nt.nspname::information_schema.sql_identifier                      AS udt_schema,
       t.typname::information_schema.sql_identifier                       AS udt_name,
       current_database()::information_schema.sql_identifier              AS specific_catalog,
       np.nspname::information_schema.sql_identifier                      AS specific_schema,
       nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,
       l.lanname::information_schema.sql_identifier                       AS group_name,
       'FROM SQL'::character varying::information_schema.character_data   AS transform_type
FROM pg_type t
         JOIN pg_transform x ON t.oid = x.trftype
         JOIN pg_language l ON x.trflang = l.oid
         JOIN pg_proc p ON x.trffromsql::oid = p.oid
         JOIN pg_namespace nt ON t.typnamespace = nt.oid
         JOIN pg_namespace np ON p.pronamespace = np.oid
UNION
SELECT current_database()::information_schema.sql_identifier              AS udt_catalog,
       nt.nspname::information_schema.sql_identifier                      AS udt_schema,
       t.typname::information_schema.sql_identifier                       AS udt_name,
       current_database()::information_schema.sql_identifier              AS specific_catalog,
       np.nspname::information_schema.sql_identifier                      AS specific_schema,
       nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,
       l.lanname::information_schema.sql_identifier                       AS group_name,
       'TO SQL'::character varying::information_schema.character_data     AS transform_type
FROM pg_type t
         JOIN pg_transform x ON t.oid = x.trftype
         JOIN pg_language l ON x.trflang = l.oid
         JOIN pg_proc p ON x.trftosql::oid = p.oid
         JOIN pg_namespace nt ON t.typnamespace = nt.oid
         JOIN pg_namespace np ON p.pronamespace = np.oid
ORDER BY 1, 2, 3, 7, 8;

alter table information_schema.transforms
    owner to postgres;

create view information_schema.triggered_update_columns
            (trigger_catalog, trigger_schema, trigger_name, event_object_catalog, event_object_schema,
             event_object_table, event_object_column)
as
SELECT current_database()::information_schema.sql_identifier AS trigger_catalog,
       n.nspname::information_schema.sql_identifier          AS trigger_schema,
       t.tgname::information_schema.sql_identifier           AS trigger_name,
       current_database()::information_schema.sql_identifier AS event_object_catalog,
       n.nspname::information_schema.sql_identifier          AS event_object_schema,
       c.relname::information_schema.sql_identifier          AS event_object_table,
       a.attname::information_schema.sql_identifier          AS event_object_column
FROM pg_namespace n,
     pg_class c,
     pg_trigger t,
     (SELECT ta0.tgoid,
             (ta0.tgat).x AS tgattnum,
             (ta0.tgat).n AS tgattpos
      FROM (SELECT pg_trigger.oid                                        AS tgoid,
                   information_schema._pg_expandarray(pg_trigger.tgattr) AS tgat
            FROM pg_trigger) ta0) ta,
     pg_attribute a
WHERE n.oid = c.relnamespace
  AND c.oid = t.tgrelid
  AND t.oid = ta.tgoid
  AND a.attrelid = t.tgrelid
  AND a.attnum = ta.tgattnum
  AND NOT t.tgisinternal
  AND NOT pg_is_other_temp_schema(n.oid)
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_column_privilege(c.oid, a.attnum, 'INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.triggered_update_columns
    owner to postgres;

grant select on information_schema.triggered_update_columns to public;

create view information_schema.triggers
            (trigger_catalog, trigger_schema, trigger_name, event_manipulation, event_object_catalog,
             event_object_schema, event_object_table, action_order, action_condition, action_statement,
             action_orientation, action_timing, action_reference_old_table, action_reference_new_table,
             action_reference_old_row, action_reference_new_row, created)
as
SELECT current_database()::information_schema.sql_identifier                                                                                                                                                                               AS trigger_catalog,
       n.nspname::information_schema.sql_identifier                                                                                                                                                                                        AS trigger_schema,
       t.tgname::information_schema.sql_identifier                                                                                                                                                                                         AS trigger_name,
       em.text::information_schema.character_data                                                                                                                                                                                          AS event_manipulation,
       current_database()::information_schema.sql_identifier                                                                                                                                                                               AS event_object_catalog,
       n.nspname::information_schema.sql_identifier                                                                                                                                                                                        AS event_object_schema,
       c.relname::information_schema.sql_identifier                                                                                                                                                                                        AS event_object_table,
       rank()
       OVER (PARTITION BY (n.nspname::information_schema.sql_identifier), (c.relname::information_schema.sql_identifier), em.num, (t.tgtype::integer & 1), (t.tgtype::integer & 66) ORDER BY t.tgname)::information_schema.cardinal_number AS action_order,
       CASE
           WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN (regexp_match(pg_get_triggerdef(t.oid),
                                                                          '.{35,} WHEN \((.+)\) EXECUTE FUNCTION'::text))[1]
           ELSE NULL::text
           END::information_schema.character_data                                                                                                                                                                                          AS action_condition,
       "substring"(pg_get_triggerdef(t.oid),
                   "position"("substring"(pg_get_triggerdef(t.oid), 48), 'EXECUTE FUNCTION'::text) +
                   47)::information_schema.character_data                                                                                                                                                                                  AS action_statement,
       CASE t.tgtype::integer & 1
           WHEN 1 THEN 'ROW'::text
           ELSE 'STATEMENT'::text
           END::information_schema.character_data                                                                                                                                                                                          AS action_orientation,
       CASE t.tgtype::integer & 66
           WHEN 2 THEN 'BEFORE'::text
           WHEN 64 THEN 'INSTEAD OF'::text
           ELSE 'AFTER'::text
           END::information_schema.character_data                                                                                                                                                                                          AS action_timing,
       t.tgoldtable::information_schema.sql_identifier                                                                                                                                                                                     AS action_reference_old_table,
       t.tgnewtable::information_schema.sql_identifier                                                                                                                                                                                     AS action_reference_new_table,
       NULL::name::information_schema.sql_identifier                                                                                                                                                                                       AS action_reference_old_row,
       NULL::name::information_schema.sql_identifier                                                                                                                                                                                       AS action_reference_new_row,
       NULL::timestamp with time zone::information_schema.time_stamp                                                                                                                                                                       AS created
FROM pg_namespace n,
     pg_class c,
     pg_trigger t,
     (VALUES (4, 'INSERT'::text), (8, 'DELETE'::text), (16, 'UPDATE'::text)) em(num, text)
WHERE n.oid = c.relnamespace
  AND c.oid = t.tgrelid
  AND (t.tgtype::integer & em.num) <> 0
  AND NOT t.tgisinternal
  AND NOT pg_is_other_temp_schema(n.oid)
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
       has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.triggers
    owner to postgres;

grant select on information_schema.triggers to public;

create view information_schema.udt_privileges
            (grantor, grantee, udt_catalog, udt_schema, udt_name, privilege_type, is_grantable) as
SELECT u_grantor.rolname::information_schema.sql_identifier               AS grantor,
       grantee.rolname::information_schema.sql_identifier                 AS grantee,
       current_database()::information_schema.sql_identifier              AS udt_catalog,
       n.nspname::information_schema.sql_identifier                       AS udt_schema,
       t.typname::information_schema.sql_identifier                       AS udt_name,
       'TYPE USAGE'::character varying::information_schema.character_data AS privilege_type,
       CASE
           WHEN pg_has_role(grantee.oid, t.typowner, 'USAGE'::text) OR t.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                              AS is_grantable
FROM (SELECT pg_type.oid,
             pg_type.typname,
             pg_type.typnamespace,
             pg_type.typtype,
             pg_type.typowner,
             (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).grantor        AS grantor,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).grantee                        AS grantee,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).privilege_type                 AS privilege_type,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).is_grantable                   AS is_grantable
      FROM pg_type) t(oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),
     pg_namespace n,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE t.typnamespace = n.oid
  AND t.typtype = 'c'::"char"
  AND t.grantee = grantee.oid
  AND t.grantor = u_grantor.oid
  AND t.prtype = 'USAGE'::text
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name);

alter table information_schema.udt_privileges
    owner to postgres;

grant select on information_schema.udt_privileges to public;

create view information_schema.role_udt_grants
            (grantor, grantee, udt_catalog, udt_schema, udt_name, privilege_type, is_grantable) as
SELECT udt_privileges.grantor,
       udt_privileges.grantee,
       udt_privileges.udt_catalog,
       udt_privileges.udt_schema,
       udt_privileges.udt_name,
       udt_privileges.privilege_type,
       udt_privileges.is_grantable
FROM information_schema.udt_privileges
WHERE (udt_privileges.grantor::name IN (SELECT enabled_roles.role_name
                                        FROM information_schema.enabled_roles))
   OR (udt_privileges.grantee::name IN (SELECT enabled_roles.role_name
                                        FROM information_schema.enabled_roles));

alter table information_schema.role_udt_grants
    owner to postgres;

grant select on information_schema.role_udt_grants to public;

create view information_schema.usage_privileges
            (grantor, grantee, object_catalog, object_schema, object_name, object_type, privilege_type, is_grantable) as
SELECT u.rolname::information_schema.sql_identifier                      AS grantor,
       'PUBLIC'::name::information_schema.sql_identifier                 AS grantee,
       current_database()::information_schema.sql_identifier             AS object_catalog,
       n.nspname::information_schema.sql_identifier                      AS object_schema,
       c.collname::information_schema.sql_identifier                     AS object_name,
       'COLLATION'::character varying::information_schema.character_data AS object_type,
       'USAGE'::character varying::information_schema.character_data     AS privilege_type,
       'NO'::character varying::information_schema.yes_or_no             AS is_grantable
FROM pg_authid u,
     pg_namespace n,
     pg_collation c
WHERE u.oid = c.collowner
  AND c.collnamespace = n.oid
  AND (c.collencoding = ANY (ARRAY ['-1'::integer, (SELECT pg_database.encoding
                                                    FROM pg_database
                                                    WHERE pg_database.datname = current_database())]))
UNION ALL
SELECT u_grantor.rolname::information_schema.sql_identifier           AS grantor,
       grantee.rolname::information_schema.sql_identifier             AS grantee,
       current_database()::information_schema.sql_identifier          AS object_catalog,
       n.nspname::information_schema.sql_identifier                   AS object_schema,
       t.typname::information_schema.sql_identifier                   AS object_name,
       'DOMAIN'::character varying::information_schema.character_data AS object_type,
       'USAGE'::character varying::information_schema.character_data  AS privilege_type,
       CASE
           WHEN pg_has_role(grantee.oid, t.typowner, 'USAGE'::text) OR t.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                          AS is_grantable
FROM (SELECT pg_type.oid,
             pg_type.typname,
             pg_type.typnamespace,
             pg_type.typtype,
             pg_type.typowner,
             (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).grantor        AS grantor,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).grantee                        AS grantee,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).privilege_type                 AS privilege_type,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).is_grantable                   AS is_grantable
      FROM pg_type) t(oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),
     pg_namespace n,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE t.typnamespace = n.oid
  AND t.typtype = 'd'::"char"
  AND t.grantee = grantee.oid
  AND t.grantor = u_grantor.oid
  AND t.prtype = 'USAGE'::text
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name)
UNION ALL
SELECT u_grantor.rolname::information_schema.sql_identifier                         AS grantor,
       grantee.rolname::information_schema.sql_identifier                           AS grantee,
       current_database()::information_schema.sql_identifier                        AS object_catalog,
       ''::name::information_schema.sql_identifier                                  AS object_schema,
       fdw.fdwname::information_schema.sql_identifier                               AS object_name,
       'FOREIGN DATA WRAPPER'::character varying::information_schema.character_data AS object_type,
       'USAGE'::character varying::information_schema.character_data                AS privilege_type,
       CASE
           WHEN pg_has_role(grantee.oid, fdw.fdwowner, 'USAGE'::text) OR fdw.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                                        AS is_grantable
FROM (SELECT pg_foreign_data_wrapper.fdwname,
             pg_foreign_data_wrapper.fdwowner,
             (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                  acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).grantor        AS grantor,
             (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                  acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).grantee        AS grantee,
             (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                  acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).privilege_type AS privilege_type,
             (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                  acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).is_grantable   AS is_grantable
      FROM pg_foreign_data_wrapper) fdw(fdwname, fdwowner, grantor, grantee, prtype, grantable),
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE u_grantor.oid = fdw.grantor
  AND grantee.oid = fdw.grantee
  AND fdw.prtype = 'USAGE'::text
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name)
UNION ALL
SELECT u_grantor.rolname::information_schema.sql_identifier                   AS grantor,
       grantee.rolname::information_schema.sql_identifier                     AS grantee,
       current_database()::information_schema.sql_identifier                  AS object_catalog,
       ''::name::information_schema.sql_identifier                            AS object_schema,
       srv.srvname::information_schema.sql_identifier                         AS object_name,
       'FOREIGN SERVER'::character varying::information_schema.character_data AS object_type,
       'USAGE'::character varying::information_schema.character_data          AS privilege_type,
       CASE
           WHEN pg_has_role(grantee.oid, srv.srvowner, 'USAGE'::text) OR srv.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                                  AS is_grantable
FROM (SELECT pg_foreign_server.srvname,
             pg_foreign_server.srvowner,
             (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                  acldefault('S'::"char", pg_foreign_server.srvowner)))).grantor        AS grantor,
             (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                  acldefault('S'::"char", pg_foreign_server.srvowner)))).grantee        AS grantee,
             (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                  acldefault('S'::"char", pg_foreign_server.srvowner)))).privilege_type AS privilege_type,
             (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                  acldefault('S'::"char", pg_foreign_server.srvowner)))).is_grantable   AS is_grantable
      FROM pg_foreign_server) srv(srvname, srvowner, grantor, grantee, prtype, grantable),
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE u_grantor.oid = srv.grantor
  AND grantee.oid = srv.grantee
  AND srv.prtype = 'USAGE'::text
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name)
UNION ALL
SELECT u_grantor.rolname::information_schema.sql_identifier             AS grantor,
       grantee.rolname::information_schema.sql_identifier               AS grantee,
       current_database()::information_schema.sql_identifier            AS object_catalog,
       n.nspname::information_schema.sql_identifier                     AS object_schema,
       c.relname::information_schema.sql_identifier                     AS object_name,
       'SEQUENCE'::character varying::information_schema.character_data AS object_type,
       'USAGE'::character varying::information_schema.character_data    AS privilege_type,
       CASE
           WHEN pg_has_role(grantee.oid, c.relowner, 'USAGE'::text) OR c.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                            AS is_grantable
FROM (SELECT pg_class.oid,
             pg_class.relname,
             pg_class.relnamespace,
             pg_class.relkind,
             pg_class.relowner,
             (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantor        AS grantor,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).grantee                         AS grantee,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).privilege_type                  AS privilege_type,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).is_grantable                    AS is_grantable
      FROM pg_class) c(oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),
     pg_namespace n,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE c.relnamespace = n.oid
  AND c.relkind = 'S'::"char"
  AND c.grantee = grantee.oid
  AND c.grantor = u_grantor.oid
  AND c.prtype = 'USAGE'::text
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name);

alter table information_schema.usage_privileges
    owner to postgres;

grant select on information_schema.usage_privileges to public;

create view information_schema.role_usage_grants
            (grantor, grantee, object_catalog, object_schema, object_name, object_type, privilege_type, is_grantable) as
SELECT usage_privileges.grantor,
       usage_privileges.grantee,
       usage_privileges.object_catalog,
       usage_privileges.object_schema,
       usage_privileges.object_name,
       usage_privileges.object_type,
       usage_privileges.privilege_type,
       usage_privileges.is_grantable
FROM information_schema.usage_privileges
WHERE (usage_privileges.grantor::name IN (SELECT enabled_roles.role_name
                                          FROM information_schema.enabled_roles))
   OR (usage_privileges.grantee::name IN (SELECT enabled_roles.role_name
                                          FROM information_schema.enabled_roles));

alter table information_schema.role_usage_grants
    owner to postgres;

grant select on information_schema.role_usage_grants to public;

create view information_schema.user_defined_types
            (user_defined_type_catalog, user_defined_type_schema, user_defined_type_name, user_defined_type_category,
             is_instantiable, is_final, ordering_form, ordering_category, ordering_routine_catalog,
             ordering_routine_schema, ordering_routine_name, reference_type, data_type, character_maximum_length,
             character_octet_length, character_set_catalog, character_set_schema, character_set_name, collation_catalog,
             collation_schema, collation_name, numeric_precision, numeric_precision_radix, numeric_scale,
             datetime_precision, interval_type, interval_precision, source_dtd_identifier, ref_dtd_identifier)
as
SELECT current_database()::information_schema.sql_identifier              AS user_defined_type_catalog,
       n.nspname::information_schema.sql_identifier                       AS user_defined_type_schema,
       c.relname::information_schema.sql_identifier                       AS user_defined_type_name,
       'STRUCTURED'::character varying::information_schema.character_data AS user_defined_type_category,
       'YES'::character varying::information_schema.yes_or_no             AS is_instantiable,
       NULL::character varying::information_schema.yes_or_no              AS is_final,
       NULL::character varying::information_schema.character_data         AS ordering_form,
       NULL::character varying::information_schema.character_data         AS ordering_category,
       NULL::name::information_schema.sql_identifier                      AS ordering_routine_catalog,
       NULL::name::information_schema.sql_identifier                      AS ordering_routine_schema,
       NULL::name::information_schema.sql_identifier                      AS ordering_routine_name,
       NULL::character varying::information_schema.character_data         AS reference_type,
       NULL::character varying::information_schema.character_data         AS data_type,
       NULL::integer::information_schema.cardinal_number                  AS character_maximum_length,
       NULL::integer::information_schema.cardinal_number                  AS character_octet_length,
       NULL::name::information_schema.sql_identifier                      AS character_set_catalog,
       NULL::name::information_schema.sql_identifier                      AS character_set_schema,
       NULL::name::information_schema.sql_identifier                      AS character_set_name,
       NULL::name::information_schema.sql_identifier                      AS collation_catalog,
       NULL::name::information_schema.sql_identifier                      AS collation_schema,
       NULL::name::information_schema.sql_identifier                      AS collation_name,
       NULL::integer::information_schema.cardinal_number                  AS numeric_precision,
       NULL::integer::information_schema.cardinal_number                  AS numeric_precision_radix,
       NULL::integer::information_schema.cardinal_number                  AS numeric_scale,
       NULL::integer::information_schema.cardinal_number                  AS datetime_precision,
       NULL::character varying::information_schema.character_data         AS interval_type,
       NULL::integer::information_schema.cardinal_number                  AS interval_precision,
       NULL::name::information_schema.sql_identifier                      AS source_dtd_identifier,
       NULL::name::information_schema.sql_identifier                      AS ref_dtd_identifier
FROM pg_namespace n,
     pg_class c,
     pg_type t
WHERE n.oid = c.relnamespace
  AND t.typrelid = c.oid
  AND c.relkind = 'c'::"char"
  AND (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text));

alter table information_schema.user_defined_types
    owner to postgres;

grant select on information_schema.user_defined_types to public;

create view information_schema.view_column_usage
            (view_catalog, view_schema, view_name, table_catalog, table_schema, table_name, column_name) as
SELECT DISTINCT current_database()::information_schema.sql_identifier AS view_catalog,
                nv.nspname::information_schema.sql_identifier         AS view_schema,
                v.relname::information_schema.sql_identifier          AS view_name,
                current_database()::information_schema.sql_identifier AS table_catalog,
                nt.nspname::information_schema.sql_identifier         AS table_schema,
                t.relname::information_schema.sql_identifier          AS table_name,
                a.attname::information_schema.sql_identifier          AS column_name
FROM pg_namespace nv,
     pg_class v,
     pg_depend dv,
     pg_depend dt,
     pg_class t,
     pg_namespace nt,
     pg_attribute a
WHERE nv.oid = v.relnamespace
  AND v.relkind = 'v'::"char"
  AND v.oid = dv.refobjid
  AND dv.refclassid = 'pg_class'::regclass::oid
  AND dv.classid = 'pg_rewrite'::regclass::oid
  AND dv.deptype = 'i'::"char"
  AND dv.objid = dt.objid
  AND dv.refobjid <> dt.refobjid
  AND dt.classid = 'pg_rewrite'::regclass::oid
  AND dt.refclassid = 'pg_class'::regclass::oid
  AND dt.refobjid = t.oid
  AND t.relnamespace = nt.oid
  AND (t.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND t.oid = a.attrelid
  AND dt.refobjsubid = a.attnum
  AND pg_has_role(t.relowner, 'USAGE'::text);

alter table information_schema.view_column_usage
    owner to postgres;

grant select on information_schema.view_column_usage to public;

create view information_schema.view_routine_usage
            (table_catalog, table_schema, table_name, specific_catalog, specific_schema, specific_name) as
SELECT DISTINCT current_database()::information_schema.sql_identifier              AS table_catalog,
                nv.nspname::information_schema.sql_identifier                      AS table_schema,
                v.relname::information_schema.sql_identifier                       AS table_name,
                current_database()::information_schema.sql_identifier              AS specific_catalog,
                np.nspname::information_schema.sql_identifier                      AS specific_schema,
                nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name
FROM pg_namespace nv,
     pg_class v,
     pg_depend dv,
     pg_depend dp,
     pg_proc p,
     pg_namespace np
WHERE nv.oid = v.relnamespace
  AND v.relkind = 'v'::"char"
  AND v.oid = dv.refobjid
  AND dv.refclassid = 'pg_class'::regclass::oid
  AND dv.classid = 'pg_rewrite'::regclass::oid
  AND dv.deptype = 'i'::"char"
  AND dv.objid = dp.objid
  AND dp.classid = 'pg_rewrite'::regclass::oid
  AND dp.refclassid = 'pg_proc'::regclass::oid
  AND dp.refobjid = p.oid
  AND p.pronamespace = np.oid
  AND pg_has_role(p.proowner, 'USAGE'::text);

alter table information_schema.view_routine_usage
    owner to postgres;

grant select on information_schema.view_routine_usage to public;

create view information_schema.view_table_usage
            (view_catalog, view_schema, view_name, table_catalog, table_schema, table_name) as
SELECT DISTINCT current_database()::information_schema.sql_identifier AS view_catalog,
                nv.nspname::information_schema.sql_identifier         AS view_schema,
                v.relname::information_schema.sql_identifier          AS view_name,
                current_database()::information_schema.sql_identifier AS table_catalog,
                nt.nspname::information_schema.sql_identifier         AS table_schema,
                t.relname::information_schema.sql_identifier          AS table_name
FROM pg_namespace nv,
     pg_class v,
     pg_depend dv,
     pg_depend dt,
     pg_class t,
     pg_namespace nt
WHERE nv.oid = v.relnamespace
  AND v.relkind = 'v'::"char"
  AND v.oid = dv.refobjid
  AND dv.refclassid = 'pg_class'::regclass::oid
  AND dv.classid = 'pg_rewrite'::regclass::oid
  AND dv.deptype = 'i'::"char"
  AND dv.objid = dt.objid
  AND dv.refobjid <> dt.refobjid
  AND dt.classid = 'pg_rewrite'::regclass::oid
  AND dt.refclassid = 'pg_class'::regclass::oid
  AND dt.refobjid = t.oid
  AND t.relnamespace = nt.oid
  AND (t.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND pg_has_role(t.relowner, 'USAGE'::text);

alter table information_schema.view_table_usage
    owner to postgres;

grant select on information_schema.view_table_usage to public;

create view information_schema.views
            (table_catalog, table_schema, table_name, view_definition, check_option, is_updatable, is_insertable_into,
             is_trigger_updatable, is_trigger_deletable, is_trigger_insertable_into)
as
SELECT current_database()::information_schema.sql_identifier AS table_catalog,
       nc.nspname::information_schema.sql_identifier         AS table_schema,
       c.relname::information_schema.sql_identifier          AS table_name,
       CASE
           WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN pg_get_viewdef(c.oid)
           ELSE NULL::text
           END::information_schema.character_data            AS view_definition,
       CASE
           WHEN 'check_option=cascaded'::text = ANY (c.reloptions) THEN 'CASCADED'::text
           WHEN 'check_option=local'::text = ANY (c.reloptions) THEN 'LOCAL'::text
           ELSE 'NONE'::text
           END::information_schema.character_data            AS check_option,
       CASE
           WHEN (pg_relation_is_updatable(c.oid::regclass, false) & 20) = 20 THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_updatable,
       CASE
           WHEN (pg_relation_is_updatable(c.oid::regclass, false) & 8) = 8 THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_insertable_into,
       CASE
           WHEN (EXISTS(SELECT 1
                        FROM pg_trigger
                        WHERE pg_trigger.tgrelid = c.oid
                          AND (pg_trigger.tgtype::integer & 81) = 81)) THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_trigger_updatable,
       CASE
           WHEN (EXISTS(SELECT 1
                        FROM pg_trigger
                        WHERE pg_trigger.tgrelid = c.oid
                          AND (pg_trigger.tgtype::integer & 73) = 73)) THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_trigger_deletable,
       CASE
           WHEN (EXISTS(SELECT 1
                        FROM pg_trigger
                        WHERE pg_trigger.tgrelid = c.oid
                          AND (pg_trigger.tgtype::integer & 69) = 69)) THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_trigger_insertable_into
FROM pg_namespace nc,
     pg_class c
WHERE c.relnamespace = nc.oid
  AND c.relkind = 'v'::"char"
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
       has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.views
    owner to postgres;

grant select on information_schema.views to public;

create view information_schema.data_type_privileges
            (object_catalog, object_schema, object_name, object_type, dtd_identifier) as
SELECT current_database()::information_schema.sql_identifier AS object_catalog,
       x.objschema                                           AS object_schema,
       x.objname                                             AS object_name,
       x.objtype::information_schema.character_data          AS object_type,
       x.objdtdid                                            AS dtd_identifier
FROM (SELECT attributes.udt_schema,
             attributes.udt_name,
             'USER-DEFINED TYPE'::text AS text,
             attributes.dtd_identifier
      FROM information_schema.attributes
      UNION ALL
      SELECT columns.table_schema,
             columns.table_name,
             'TABLE'::text AS text,
             columns.dtd_identifier
      FROM information_schema.columns
      UNION ALL
      SELECT domains.domain_schema,
             domains.domain_name,
             'DOMAIN'::text AS text,
             domains.dtd_identifier
      FROM information_schema.domains
      UNION ALL
      SELECT parameters.specific_schema,
             parameters.specific_name,
             'ROUTINE'::text AS text,
             parameters.dtd_identifier
      FROM information_schema.parameters
      UNION ALL
      SELECT routines.specific_schema,
             routines.specific_name,
             'ROUTINE'::text AS text,
             routines.dtd_identifier
      FROM information_schema.routines) x(objschema, objname, objtype, objdtdid);

alter table information_schema.data_type_privileges
    owner to postgres;

grant select on information_schema.data_type_privileges to public;

create view information_schema.element_types
            (object_catalog, object_schema, object_name, object_type, collection_type_identifier, data_type,
             character_maximum_length, character_octet_length, character_set_catalog, character_set_schema,
             character_set_name, collation_catalog, collation_schema, collation_name, numeric_precision,
             numeric_precision_radix, numeric_scale, datetime_precision, interval_type, interval_precision,
             domain_default, udt_catalog, udt_schema, udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier)
as
SELECT current_database()::information_schema.sql_identifier              AS object_catalog,
       n.nspname::information_schema.sql_identifier                       AS object_schema,
       x.objname                                                          AS object_name,
       x.objtype::information_schema.character_data                       AS object_type,
       x.objdtdid::information_schema.sql_identifier                      AS collection_type_identifier,
       CASE
           WHEN nbt.nspname = 'pg_catalog'::name THEN format_type(bt.oid, NULL::integer)
           ELSE 'USER-DEFINED'::text
           END::information_schema.character_data                         AS data_type,
       NULL::integer::information_schema.cardinal_number                  AS character_maximum_length,
       NULL::integer::information_schema.cardinal_number                  AS character_octet_length,
       NULL::name::information_schema.sql_identifier                      AS character_set_catalog,
       NULL::name::information_schema.sql_identifier                      AS character_set_schema,
       NULL::name::information_schema.sql_identifier                      AS character_set_name,
       CASE
           WHEN nco.nspname IS NOT NULL THEN current_database()
           ELSE NULL::name
           END::information_schema.sql_identifier                         AS collation_catalog,
       nco.nspname::information_schema.sql_identifier                     AS collation_schema,
       co.collname::information_schema.sql_identifier                     AS collation_name,
       NULL::integer::information_schema.cardinal_number                  AS numeric_precision,
       NULL::integer::information_schema.cardinal_number                  AS numeric_precision_radix,
       NULL::integer::information_schema.cardinal_number                  AS numeric_scale,
       NULL::integer::information_schema.cardinal_number                  AS datetime_precision,
       NULL::character varying::information_schema.character_data         AS interval_type,
       NULL::integer::information_schema.cardinal_number                  AS interval_precision,
       NULL::character varying::information_schema.character_data         AS domain_default,
       current_database()::information_schema.sql_identifier              AS udt_catalog,
       nbt.nspname::information_schema.sql_identifier                     AS udt_schema,
       bt.typname::information_schema.sql_identifier                      AS udt_name,
       NULL::name::information_schema.sql_identifier                      AS scope_catalog,
       NULL::name::information_schema.sql_identifier                      AS scope_schema,
       NULL::name::information_schema.sql_identifier                      AS scope_name,
       NULL::integer::information_schema.cardinal_number                  AS maximum_cardinality,
       ('a'::text || x.objdtdid::text)::information_schema.sql_identifier AS dtd_identifier
FROM pg_namespace n,
     pg_type at,
     pg_namespace nbt,
     pg_type bt,
     (SELECT c.relnamespace,
             c.relname::information_schema.sql_identifier AS relname,
             CASE
                 WHEN c.relkind = 'c'::"char" THEN 'USER-DEFINED TYPE'::text
                 ELSE 'TABLE'::text
                 END                                      AS "case",
             a.attnum,
             a.atttypid,
             a.attcollation
      FROM pg_class c,
           pg_attribute a
      WHERE c.oid = a.attrelid
        AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'c'::"char", 'p'::"char"]))
        AND a.attnum > 0
        AND NOT a.attisdropped
      UNION ALL
      SELECT t.typnamespace,
             t.typname::information_schema.sql_identifier AS typname,
             'DOMAIN'::text                               AS text,
             1,
             t.typbasetype,
             t.typcollation
      FROM pg_type t
      WHERE t.typtype = 'd'::"char"
      UNION ALL
      SELECT ss.pronamespace,
             nameconcatoid(ss.proname, ss.oid)::information_schema.sql_identifier AS nameconcatoid,
             'ROUTINE'::text                                                      AS text,
             (ss.x).n                                                             AS n,
             (ss.x).x                                                             AS x,
             0
      FROM (SELECT p.pronamespace,
                   p.proname,
                   p.oid,
                   information_schema._pg_expandarray(COALESCE(p.proallargtypes, p.proargtypes::oid[])) AS x
            FROM pg_proc p) ss
      UNION ALL
      SELECT p.pronamespace,
             nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS nameconcatoid,
             'ROUTINE'::text                                                    AS text,
             0,
             p.prorettype,
             0
      FROM pg_proc p) x(objschema, objname, objtype, objdtdid, objtypeid, objcollation)
         LEFT JOIN (pg_collation co
         JOIN pg_namespace nco ON co.collnamespace = nco.oid)
                   ON x.objcollation = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)
WHERE n.oid = x.objschema
  AND at.oid = x.objtypeid
  AND at.typelem <> 0::oid
  AND at.typlen = '-1'::integer
  AND at.typelem = bt.oid
  AND nbt.oid = bt.typnamespace
  AND ((n.nspname, x.objname::name, x.objtype, x.objdtdid::information_schema.sql_identifier::name) IN
       (SELECT data_type_privileges.object_schema,
               data_type_privileges.object_name,
               data_type_privileges.object_type,
               data_type_privileges.dtd_identifier
        FROM information_schema.data_type_privileges));

alter table information_schema.element_types
    owner to postgres;

grant select on information_schema.element_types to public;

create view information_schema._pg_foreign_table_columns(nspname, relname, attname, attfdwoptions) as
SELECT n.nspname,
       c.relname,
       a.attname,
       a.attfdwoptions
FROM pg_foreign_table t,
     pg_authid u,
     pg_namespace n,
     pg_class c,
     pg_attribute a
WHERE u.oid = c.relowner
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text))
  AND n.oid = c.relnamespace
  AND c.oid = t.ftrelid
  AND c.relkind = 'f'::"char"
  AND a.attrelid = c.oid
  AND a.attnum > 0;

alter table information_schema._pg_foreign_table_columns
    owner to postgres;

create view information_schema.column_options
            (table_catalog, table_schema, table_name, column_name, option_name, option_value) as
SELECT current_database()::information_schema.sql_identifier                                  AS table_catalog,
       c.nspname::information_schema.sql_identifier                                           AS table_schema,
       c.relname::information_schema.sql_identifier                                           AS table_name,
       c.attname::information_schema.sql_identifier                                           AS column_name,
       (pg_options_to_table(c.attfdwoptions)).option_name::information_schema.sql_identifier  AS option_name,
       (pg_options_to_table(c.attfdwoptions)).option_value::information_schema.character_data AS option_value
FROM information_schema._pg_foreign_table_columns c;

alter table information_schema.column_options
    owner to postgres;

grant select on information_schema.column_options to public;

create view information_schema._pg_foreign_data_wrappers
            (oid, fdwowner, fdwoptions, foreign_data_wrapper_catalog, foreign_data_wrapper_name,
             authorization_identifier, foreign_data_wrapper_language)
as
SELECT w.oid,
       w.fdwowner,
       w.fdwoptions,
       current_database()::information_schema.sql_identifier     AS foreign_data_wrapper_catalog,
       w.fdwname::information_schema.sql_identifier              AS foreign_data_wrapper_name,
       u.rolname::information_schema.sql_identifier              AS authorization_identifier,
       'c'::character varying::information_schema.character_data AS foreign_data_wrapper_language
FROM pg_foreign_data_wrapper w,
     pg_authid u
WHERE u.oid = w.fdwowner
  AND (pg_has_role(w.fdwowner, 'USAGE'::text) OR has_foreign_data_wrapper_privilege(w.oid, 'USAGE'::text));

alter table information_schema._pg_foreign_data_wrappers
    owner to postgres;

create view information_schema.foreign_data_wrapper_options
            (foreign_data_wrapper_catalog, foreign_data_wrapper_name, option_name, option_value) as
SELECT w.foreign_data_wrapper_catalog,
       w.foreign_data_wrapper_name,
       (pg_options_to_table(w.fdwoptions)).option_name::information_schema.sql_identifier  AS option_name,
       (pg_options_to_table(w.fdwoptions)).option_value::information_schema.character_data AS option_value
FROM information_schema._pg_foreign_data_wrappers w;

alter table information_schema.foreign_data_wrapper_options
    owner to postgres;

grant select on information_schema.foreign_data_wrapper_options to public;

create view information_schema.foreign_data_wrappers
            (foreign_data_wrapper_catalog, foreign_data_wrapper_name, authorization_identifier, library_name,
             foreign_data_wrapper_language)
as
SELECT w.foreign_data_wrapper_catalog,
       w.foreign_data_wrapper_name,
       w.authorization_identifier,
       NULL::character varying::information_schema.character_data AS library_name,
       w.foreign_data_wrapper_language
FROM information_schema._pg_foreign_data_wrappers w;

alter table information_schema.foreign_data_wrappers
    owner to postgres;

grant select on information_schema.foreign_data_wrappers to public;

create view information_schema._pg_foreign_servers
            (oid, srvoptions, foreign_server_catalog, foreign_server_name, foreign_data_wrapper_catalog,
             foreign_data_wrapper_name, foreign_server_type, foreign_server_version, authorization_identifier)
as
SELECT s.oid,
       s.srvoptions,
       current_database()::information_schema.sql_identifier AS foreign_server_catalog,
       s.srvname::information_schema.sql_identifier          AS foreign_server_name,
       current_database()::information_schema.sql_identifier AS foreign_data_wrapper_catalog,
       w.fdwname::information_schema.sql_identifier          AS foreign_data_wrapper_name,
       s.srvtype::information_schema.character_data          AS foreign_server_type,
       s.srvversion::information_schema.character_data       AS foreign_server_version,
       u.rolname::information_schema.sql_identifier          AS authorization_identifier
FROM pg_foreign_server s,
     pg_foreign_data_wrapper w,
     pg_authid u
WHERE w.oid = s.srvfdw
  AND u.oid = s.srvowner
  AND (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text));

alter table information_schema._pg_foreign_servers
    owner to postgres;

create view information_schema.foreign_server_options
            (foreign_server_catalog, foreign_server_name, option_name, option_value) as
SELECT s.foreign_server_catalog,
       s.foreign_server_name,
       (pg_options_to_table(s.srvoptions)).option_name::information_schema.sql_identifier  AS option_name,
       (pg_options_to_table(s.srvoptions)).option_value::information_schema.character_data AS option_value
FROM information_schema._pg_foreign_servers s;

alter table information_schema.foreign_server_options
    owner to postgres;

grant select on information_schema.foreign_server_options to public;

create view information_schema.foreign_servers
            (foreign_server_catalog, foreign_server_name, foreign_data_wrapper_catalog, foreign_data_wrapper_name,
             foreign_server_type, foreign_server_version, authorization_identifier)
as
SELECT _pg_foreign_servers.foreign_server_catalog,
       _pg_foreign_servers.foreign_server_name,
       _pg_foreign_servers.foreign_data_wrapper_catalog,
       _pg_foreign_servers.foreign_data_wrapper_name,
       _pg_foreign_servers.foreign_server_type,
       _pg_foreign_servers.foreign_server_version,
       _pg_foreign_servers.authorization_identifier
FROM information_schema._pg_foreign_servers;

alter table information_schema.foreign_servers
    owner to postgres;

grant select on information_schema.foreign_servers to public;

create view information_schema._pg_foreign_tables
            (foreign_table_catalog, foreign_table_schema, foreign_table_name, ftoptions, foreign_server_catalog,
             foreign_server_name, authorization_identifier)
as
SELECT current_database()::information_schema.sql_identifier AS foreign_table_catalog,
       n.nspname::information_schema.sql_identifier          AS foreign_table_schema,
       c.relname::information_schema.sql_identifier          AS foreign_table_name,
       t.ftoptions,
       current_database()::information_schema.sql_identifier AS foreign_server_catalog,
       s.srvname::information_schema.sql_identifier          AS foreign_server_name,
       u.rolname::information_schema.sql_identifier          AS authorization_identifier
FROM pg_foreign_table t,
     pg_foreign_server s,
     pg_foreign_data_wrapper w,
     pg_authid u,
     pg_namespace n,
     pg_class c
WHERE w.oid = s.srvfdw
  AND u.oid = c.relowner
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
       has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text))
  AND n.oid = c.relnamespace
  AND c.oid = t.ftrelid
  AND c.relkind = 'f'::"char"
  AND s.oid = t.ftserver;

alter table information_schema._pg_foreign_tables
    owner to postgres;

create view information_schema.foreign_table_options
            (foreign_table_catalog, foreign_table_schema, foreign_table_name, option_name, option_value) as
SELECT t.foreign_table_catalog,
       t.foreign_table_schema,
       t.foreign_table_name,
       (pg_options_to_table(t.ftoptions)).option_name::information_schema.sql_identifier  AS option_name,
       (pg_options_to_table(t.ftoptions)).option_value::information_schema.character_data AS option_value
FROM information_schema._pg_foreign_tables t;

alter table information_schema.foreign_table_options
    owner to postgres;

grant select on information_schema.foreign_table_options to public;

create view information_schema.foreign_tables
            (foreign_table_catalog, foreign_table_schema, foreign_table_name, foreign_server_catalog,
             foreign_server_name) as
SELECT _pg_foreign_tables.foreign_table_catalog,
       _pg_foreign_tables.foreign_table_schema,
       _pg_foreign_tables.foreign_table_name,
       _pg_foreign_tables.foreign_server_catalog,
       _pg_foreign_tables.foreign_server_name
FROM information_schema._pg_foreign_tables;

alter table information_schema.foreign_tables
    owner to postgres;

grant select on information_schema.foreign_tables to public;

create view information_schema._pg_user_mappings
            (oid, umoptions, umuser, authorization_identifier, foreign_server_catalog, foreign_server_name, srvowner) as
SELECT um.oid,
       um.umoptions,
       um.umuser,
       COALESCE(u.rolname, 'PUBLIC'::name)::information_schema.sql_identifier AS authorization_identifier,
       s.foreign_server_catalog,
       s.foreign_server_name,
       s.authorization_identifier                                             AS srvowner
FROM pg_user_mapping um
         LEFT JOIN pg_authid u ON u.oid = um.umuser,
     information_schema._pg_foreign_servers s
WHERE s.oid = um.umserver;

alter table information_schema._pg_user_mappings
    owner to postgres;

create view information_schema.user_mapping_options
            (authorization_identifier, foreign_server_catalog, foreign_server_name, option_name, option_value) as
SELECT um.authorization_identifier,
       um.foreign_server_catalog,
       um.foreign_server_name,
       opts.option_name::information_schema.sql_identifier AS option_name,
       CASE
           WHEN um.umuser <> 0::oid AND um.authorization_identifier::name = CURRENT_USER OR
                um.umuser = 0::oid AND pg_has_role(um.srvowner::name, 'USAGE'::text) OR (SELECT pg_authid.rolsuper
                                                                                         FROM pg_authid
                                                                                         WHERE pg_authid.rolname = CURRENT_USER)
               THEN opts.option_value
           ELSE NULL::text
           END::information_schema.character_data          AS option_value
FROM information_schema._pg_user_mappings um,
     LATERAL pg_options_to_table(um.umoptions) opts(option_name, option_value);

alter table information_schema.user_mapping_options
    owner to postgres;

grant select on information_schema.user_mapping_options to public;

create view information_schema.user_mappings(authorization_identifier, foreign_server_catalog, foreign_server_name) as
SELECT _pg_user_mappings.authorization_identifier,
       _pg_user_mappings.foreign_server_catalog,
       _pg_user_mappings.foreign_server_name
FROM information_schema._pg_user_mappings;

alter table information_schema.user_mappings
    owner to postgres;

grant select on information_schema.user_mappings to public;

create function pg_catalog.heap_tableam_handler()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.heap_tableam_handler() is 'row-oriented heap table access method handler';

alter function pg_catalog.heap_tableam_handler() owner to postgres;

create function pg_catalog.byteaout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteaout() is 'I/O';

alter function pg_catalog.byteaout() owner to postgres;

create function pg_catalog.charout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charout() is 'I/O';

alter function pg_catalog.charout() owner to postgres;

create function pg_catalog.namein()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namein() is 'I/O';

alter function pg_catalog.namein() owner to postgres;

create function pg_catalog.nameout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameout() is 'I/O';

alter function pg_catalog.nameout() owner to postgres;

create function pg_catalog.int2in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2in() is 'I/O';

alter function pg_catalog.int2in() owner to postgres;

create function pg_catalog.int2out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2out() is 'I/O';

alter function pg_catalog.int2out() owner to postgres;

create function pg_catalog.int2vectorin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorin() is 'I/O';

alter function pg_catalog.int2vectorin() owner to postgres;

create function pg_catalog.int2vectorout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorout() is 'I/O';

alter function pg_catalog.int2vectorout() owner to postgres;

create function pg_catalog.int4in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4in() is 'I/O';

alter function pg_catalog.int4in() owner to postgres;

create function pg_catalog.int4out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4out() is 'I/O';

alter function pg_catalog.int4out() owner to postgres;

create function pg_catalog.regprocin()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocin() is 'I/O';

alter function pg_catalog.regprocin() owner to postgres;

create function pg_catalog.regprocout()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocout() is 'I/O';

alter function pg_catalog.regprocout() owner to postgres;

create function pg_catalog.textin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textin() is 'I/O';

alter function pg_catalog.textin() owner to postgres;

create function pg_catalog.textout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textout() is 'I/O';

alter function pg_catalog.textout() owner to postgres;

create function pg_catalog.tidin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidin() is 'I/O';

alter function pg_catalog.tidin() owner to postgres;

create function pg_catalog.tidout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidout() is 'I/O';

alter function pg_catalog.tidout() owner to postgres;

create function pg_catalog.xidin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidin() is 'I/O';

alter function pg_catalog.xidin() owner to postgres;

create function pg_catalog.xidout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidout() is 'I/O';

alter function pg_catalog.xidout() owner to postgres;

create function pg_catalog.cidin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidin() is 'I/O';

alter function pg_catalog.cidin() owner to postgres;

create function pg_catalog.cidout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidout() is 'I/O';

alter function pg_catalog.cidout() owner to postgres;

create function pg_catalog.oidvectorin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorin() is 'I/O';

alter function pg_catalog.oidvectorin() owner to postgres;

create function pg_catalog.oidvectorout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorout() is 'I/O';

alter function pg_catalog.oidvectorout() owner to postgres;

create function pg_catalog.boollt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boollt() is 'implementation of < operator';

alter function pg_catalog.boollt() owner to postgres;

create function pg_catalog.boolgt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolgt() is 'implementation of > operator';

alter function pg_catalog.boolgt() owner to postgres;

create function pg_catalog.booleq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.booleq() is 'implementation of = operator';

alter function pg_catalog.booleq() owner to postgres;

create function pg_catalog.chareq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.chareq() is 'implementation of = operator';

alter function pg_catalog.chareq() owner to postgres;

create function pg_catalog.nameeq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameeq() is 'implementation of = operator';

alter function pg_catalog.nameeq() owner to postgres;

create function pg_catalog.int2eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2eq() is 'implementation of = operator';

alter function pg_catalog.int2eq() owner to postgres;

create function pg_catalog.int2lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2lt() is 'implementation of < operator';

alter function pg_catalog.int2lt() owner to postgres;

create function pg_catalog.int4eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4eq() is 'implementation of = operator';

alter function pg_catalog.int4eq() owner to postgres;

create function pg_catalog.int4lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4lt() is 'implementation of < operator';

alter function pg_catalog.int4lt() owner to postgres;

create function pg_catalog.texteq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texteq() is 'implementation of = operator';

alter function pg_catalog.texteq() owner to postgres;

create function pg_catalog.xideq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xideq() is 'implementation of = operator';

alter function pg_catalog.xideq() owner to postgres;

create function pg_catalog.cideq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cideq() is 'implementation of = operator';

alter function pg_catalog.cideq() owner to postgres;

create function pg_catalog.charne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charne() is 'implementation of <> operator';

alter function pg_catalog.charne() owner to postgres;

create function pg_catalog.charle()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charle() is 'implementation of <= operator';

alter function pg_catalog.charle() owner to postgres;

create function pg_catalog.chargt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.chargt() is 'implementation of > operator';

alter function pg_catalog.chargt() owner to postgres;

create function pg_catalog.charge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charge() is 'implementation of >= operator';

alter function pg_catalog.charge() owner to postgres;

create function pg_catalog.int4("char")
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4("char") is 'convert char to int4';

alter function pg_catalog.int4("char") owner to postgres;

create function pg_catalog.char()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char() is 'convert int4 to char';

alter function pg_catalog.char() owner to postgres;

create function pg_catalog.nameregexeq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameregexeq() is 'implementation of ~ operator';

alter function pg_catalog.nameregexeq() owner to postgres;

create function pg_catalog.boolne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolne() is 'implementation of <> operator';

alter function pg_catalog.boolne() owner to postgres;

create function pg_catalog.pg_ddl_command_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_in() is 'I/O';

alter function pg_catalog.pg_ddl_command_in() owner to postgres;

create function pg_catalog.pg_ddl_command_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_out() is 'I/O';

alter function pg_catalog.pg_ddl_command_out() owner to postgres;

create function pg_catalog.pg_ddl_command_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_recv() is 'I/O';

alter function pg_catalog.pg_ddl_command_recv() owner to postgres;

create function pg_catalog.version()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.version() is 'PostgreSQL version string';

alter function pg_catalog.version() owner to postgres;

create function pg_catalog.pg_ddl_command_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_send() is 'I/O';

alter function pg_catalog.pg_ddl_command_send() owner to postgres;

create function pg_catalog.eqsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.eqsel() is 'restriction selectivity of = and related operators';

alter function pg_catalog.eqsel() owner to postgres;

create function pg_catalog.neqsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.neqsel() is 'restriction selectivity of <> and related operators';

alter function pg_catalog.neqsel() owner to postgres;

create function pg_catalog.scalarltsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarltsel() is 'restriction selectivity of < and related operators on scalar datatypes';

alter function pg_catalog.scalarltsel() owner to postgres;

create function pg_catalog.scalargtsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargtsel() is 'restriction selectivity of > and related operators on scalar datatypes';

alter function pg_catalog.scalargtsel() owner to postgres;

create function pg_catalog.eqjoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.eqjoinsel() is 'join selectivity of = and related operators';

alter function pg_catalog.eqjoinsel() owner to postgres;

create function pg_catalog.neqjoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.neqjoinsel() is 'join selectivity of <> and related operators';

alter function pg_catalog.neqjoinsel() owner to postgres;

create function pg_catalog.scalarltjoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarltjoinsel() is 'join selectivity of < and related operators on scalar datatypes';

alter function pg_catalog.scalarltjoinsel() owner to postgres;

create function pg_catalog.scalargtjoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargtjoinsel() is 'join selectivity of > and related operators on scalar datatypes';

alter function pg_catalog.scalargtjoinsel() owner to postgres;

create function pg_catalog.unknownin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownin() is 'I/O';

alter function pg_catalog.unknownin() owner to postgres;

create function pg_catalog.unknownout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownout() is 'I/O';

alter function pg_catalog.unknownout() owner to postgres;

create function pg_catalog.numeric_fac()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_fac() is 'implementation of ! operator';

alter function pg_catalog.numeric_fac() owner to postgres;

create function pg_catalog.box_above_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_above_eq() is 'implementation of >^ operator';

alter function pg_catalog.box_above_eq() owner to postgres;

create function pg_catalog.box_below_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_below_eq() is 'implementation of <^ operator';

alter function pg_catalog.box_below_eq() owner to postgres;

create function pg_catalog.point_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_in() is 'I/O';

alter function pg_catalog.point_in() owner to postgres;

create function pg_catalog.point_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_out() is 'I/O';

alter function pg_catalog.point_out() owner to postgres;

create function pg_catalog.lseg_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_in() is 'I/O';

alter function pg_catalog.lseg_in() owner to postgres;

create function pg_catalog.lseg_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_out() is 'I/O';

alter function pg_catalog.lseg_out() owner to postgres;

create function pg_catalog.path_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_in() is 'I/O';

alter function pg_catalog.path_in() owner to postgres;

create function pg_catalog.path_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_out() is 'I/O';

alter function pg_catalog.path_out() owner to postgres;

create function pg_catalog.box_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_in() is 'I/O';

alter function pg_catalog.box_in() owner to postgres;

create function pg_catalog.box_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_out() is 'I/O';

alter function pg_catalog.box_out() owner to postgres;

create function pg_catalog.box_overlap()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overlap() is 'implementation of && operator';

alter function pg_catalog.box_overlap() owner to postgres;

create function pg_catalog.box_ge()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_ge() is 'implementation of >= operator';

alter function pg_catalog.box_ge() owner to postgres;

create function pg_catalog.box_gt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_gt() is 'implementation of > operator';

alter function pg_catalog.box_gt() owner to postgres;

create function pg_catalog.box_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_eq() is 'implementation of = operator';

alter function pg_catalog.box_eq() owner to postgres;

create function pg_catalog.box_lt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_lt() is 'implementation of < operator';

alter function pg_catalog.box_lt() owner to postgres;

create function pg_catalog.box_le()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_le() is 'implementation of <= operator';

alter function pg_catalog.box_le() owner to postgres;

create function pg_catalog.point_above()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_above() is 'implementation of >^ operator';

alter function pg_catalog.point_above() owner to postgres;

create function pg_catalog.point_left()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_left() is 'implementation of << operator';

alter function pg_catalog.point_left() owner to postgres;

create function pg_catalog.point_right()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_right() is 'implementation of >> operator';

alter function pg_catalog.point_right() owner to postgres;

create function pg_catalog.point_below()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_below() is 'implementation of <^ operator';

alter function pg_catalog.point_below() owner to postgres;

create function pg_catalog.point_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_eq() is 'implementation of ~= operator';

alter function pg_catalog.point_eq() owner to postgres;

create function pg_catalog.on_pb()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_pb() is 'implementation of <@ operator';

alter function pg_catalog.on_pb() owner to postgres;

create function pg_catalog.on_ppath()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_ppath() is 'implementation of <@ operator';

alter function pg_catalog.on_ppath() owner to postgres;

create function pg_catalog.box_center()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_center() is 'implementation of @@ operator';

alter function pg_catalog.box_center() owner to postgres;

create function pg_catalog.areasel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.areasel() is 'restriction selectivity for area-comparison operators';

alter function pg_catalog.areasel() owner to postgres;

create function pg_catalog.areajoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.areajoinsel() is 'join selectivity for area-comparison operators';

alter function pg_catalog.areajoinsel() owner to postgres;

create function pg_catalog.int4mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4mul() is 'implementation of * operator';

alter function pg_catalog.int4mul() owner to postgres;

create function pg_catalog.int4ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4ne() is 'implementation of <> operator';

alter function pg_catalog.int4ne() owner to postgres;

create function pg_catalog.int2ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2ne() is 'implementation of <> operator';

alter function pg_catalog.int2ne() owner to postgres;

create function pg_catalog.int2gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2gt() is 'implementation of > operator';

alter function pg_catalog.int2gt() owner to postgres;

create function pg_catalog.int4gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4gt() is 'implementation of > operator';

alter function pg_catalog.int4gt() owner to postgres;

create function pg_catalog.int2le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2le() is 'implementation of <= operator';

alter function pg_catalog.int2le() owner to postgres;

create function pg_catalog.int4le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4le() is 'implementation of <= operator';

alter function pg_catalog.int4le() owner to postgres;

create function pg_catalog.int4ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4ge() is 'implementation of >= operator';

alter function pg_catalog.int4ge() owner to postgres;

create function pg_catalog.int2ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2ge() is 'implementation of >= operator';

alter function pg_catalog.int2ge() owner to postgres;

create function pg_catalog.int2mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2mul() is 'implementation of * operator';

alter function pg_catalog.int2mul() owner to postgres;

create function pg_catalog.int2div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2div() is 'implementation of / operator';

alter function pg_catalog.int2div() owner to postgres;

create function pg_catalog.int4div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4div() is 'implementation of / operator';

alter function pg_catalog.int4div() owner to postgres;

create function pg_catalog.int2mod()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2mod() is 'implementation of % operator';

alter function pg_catalog.int2mod() owner to postgres;

create function pg_catalog.int4mod()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4mod() is 'implementation of % operator';

alter function pg_catalog.int4mod() owner to postgres;

create function pg_catalog.textne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textne() is 'implementation of <> operator';

alter function pg_catalog.textne() owner to postgres;

create function pg_catalog.int24eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24eq() is 'implementation of = operator';

alter function pg_catalog.int24eq() owner to postgres;

create function pg_catalog.int42eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42eq() is 'implementation of = operator';

alter function pg_catalog.int42eq() owner to postgres;

create function pg_catalog.int24lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24lt() is 'implementation of < operator';

alter function pg_catalog.int24lt() owner to postgres;

create function pg_catalog.int42lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42lt() is 'implementation of < operator';

alter function pg_catalog.int42lt() owner to postgres;

create function pg_catalog.int24gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24gt() is 'implementation of > operator';

alter function pg_catalog.int24gt() owner to postgres;

create function pg_catalog.int42gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42gt() is 'implementation of > operator';

alter function pg_catalog.int42gt() owner to postgres;

create function pg_catalog.int24ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24ne() is 'implementation of <> operator';

alter function pg_catalog.int24ne() owner to postgres;

create function pg_catalog.int42ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42ne() is 'implementation of <> operator';

alter function pg_catalog.int42ne() owner to postgres;

create function pg_catalog.int24le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24le() is 'implementation of <= operator';

alter function pg_catalog.int24le() owner to postgres;

create function pg_catalog.int42le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42le() is 'implementation of <= operator';

alter function pg_catalog.int42le() owner to postgres;

create function pg_catalog.int24ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24ge() is 'implementation of >= operator';

alter function pg_catalog.int24ge() owner to postgres;

create function pg_catalog.int42ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42ge() is 'implementation of >= operator';

alter function pg_catalog.int42ge() owner to postgres;

create function pg_catalog.int24mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24mul() is 'implementation of * operator';

alter function pg_catalog.int24mul() owner to postgres;

create function pg_catalog.int42mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42mul() is 'implementation of * operator';

alter function pg_catalog.int42mul() owner to postgres;

create function pg_catalog.int24div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24div() is 'implementation of / operator';

alter function pg_catalog.int24div() owner to postgres;

create function pg_catalog.int42div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42div() is 'implementation of / operator';

alter function pg_catalog.int42div() owner to postgres;

create function pg_catalog.int2pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2pl() is 'implementation of + operator';

alter function pg_catalog.int2pl() owner to postgres;

create function pg_catalog.int4pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4pl() is 'implementation of + operator';

alter function pg_catalog.int4pl() owner to postgres;

create function pg_catalog.int24pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24pl() is 'implementation of + operator';

alter function pg_catalog.int24pl() owner to postgres;

create function pg_catalog.int42pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42pl() is 'implementation of + operator';

alter function pg_catalog.int42pl() owner to postgres;

create function pg_catalog.int2mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2mi() is 'implementation of - operator';

alter function pg_catalog.int2mi() owner to postgres;

create function pg_catalog.int4mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4mi() is 'implementation of - operator';

alter function pg_catalog.int4mi() owner to postgres;

create function pg_catalog.int24mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24mi() is 'implementation of - operator';

alter function pg_catalog.int24mi() owner to postgres;

create function pg_catalog.int42mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42mi() is 'implementation of - operator';

alter function pg_catalog.int42mi() owner to postgres;

create function pg_catalog.oideq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oideq() is 'implementation of = operator';

alter function pg_catalog.oideq() owner to postgres;

create function pg_catalog.oidne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidne() is 'implementation of <> operator';

alter function pg_catalog.oidne() owner to postgres;

create function pg_catalog.box_same()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_same() is 'implementation of ~= operator';

alter function pg_catalog.box_same() owner to postgres;

create function pg_catalog.box_contain()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_contain() is 'implementation of @> operator';

alter function pg_catalog.box_contain() owner to postgres;

create function pg_catalog.box_left()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_left() is 'implementation of << operator';

alter function pg_catalog.box_left() owner to postgres;

create function pg_catalog.box_overleft()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overleft() is 'implementation of &< operator';

alter function pg_catalog.box_overleft() owner to postgres;

create function pg_catalog.box_overright()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overright() is 'implementation of &> operator';

alter function pg_catalog.box_overright() owner to postgres;

create function pg_catalog.box_right()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_right() is 'implementation of >> operator';

alter function pg_catalog.box_right() owner to postgres;

create function pg_catalog.box_contained()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_contained() is 'implementation of <@ operator';

alter function pg_catalog.box_contained() owner to postgres;

create function pg_catalog.box_contain_pt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_contain_pt() is 'implementation of @> operator';

alter function pg_catalog.box_contain_pt() owner to postgres;

create function pg_catalog.pg_node_tree_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_in() is 'I/O';

alter function pg_catalog.pg_node_tree_in() owner to postgres;

create function pg_catalog.pg_node_tree_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_out() is 'I/O';

alter function pg_catalog.pg_node_tree_out() owner to postgres;

create function pg_catalog.pg_node_tree_recv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_recv() is 'I/O';

alter function pg_catalog.pg_node_tree_recv() owner to postgres;

create function pg_catalog.pg_node_tree_send()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_send() is 'I/O';

alter function pg_catalog.pg_node_tree_send() owner to postgres;

create function pg_catalog.float4in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4in() is 'I/O';

alter function pg_catalog.float4in() owner to postgres;

create function pg_catalog.float4out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4out() is 'I/O';

alter function pg_catalog.float4out() owner to postgres;

create function pg_catalog.float4mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4mul() is 'implementation of * operator';

alter function pg_catalog.float4mul() owner to postgres;

create function pg_catalog.float4div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4div() is 'implementation of / operator';

alter function pg_catalog.float4div() owner to postgres;

create function pg_catalog.float4pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4pl() is 'implementation of + operator';

alter function pg_catalog.float4pl() owner to postgres;

create function pg_catalog.float4mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4mi() is 'implementation of - operator';

alter function pg_catalog.float4mi() owner to postgres;

create function pg_catalog.float4um()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4um() is 'implementation of - operator';

alter function pg_catalog.float4um() owner to postgres;

create function pg_catalog.float4abs()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4abs() is 'implementation of @ operator';

alter function pg_catalog.float4abs() owner to postgres;

create function pg_catalog.float4_accum()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4_accum() is 'aggregate transition function';

alter function pg_catalog.float4_accum() owner to postgres;

create function pg_catalog.float4larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4larger() is 'larger of two';

alter function pg_catalog.float4larger() owner to postgres;

create function pg_catalog.float4smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4smaller() is 'smaller of two';

alter function pg_catalog.float4smaller() owner to postgres;

create function pg_catalog.int4um()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4um() is 'implementation of - operator';

alter function pg_catalog.int4um() owner to postgres;

create function pg_catalog.int2um()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2um() is 'implementation of - operator';

alter function pg_catalog.int2um() owner to postgres;

create function pg_catalog.float8in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8in() is 'I/O';

alter function pg_catalog.float8in() owner to postgres;

create function pg_catalog.float8out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8out() is 'I/O';

alter function pg_catalog.float8out() owner to postgres;

create function pg_catalog.float8mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8mul() is 'implementation of * operator';

alter function pg_catalog.float8mul() owner to postgres;

create function pg_catalog.float8div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8div() is 'implementation of / operator';

alter function pg_catalog.float8div() owner to postgres;

create function pg_catalog.float8pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8pl() is 'implementation of + operator';

alter function pg_catalog.float8pl() owner to postgres;

create function pg_catalog.float8mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8mi() is 'implementation of - operator';

alter function pg_catalog.float8mi() owner to postgres;

create function pg_catalog.float8um()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8um() is 'implementation of - operator';

alter function pg_catalog.float8um() owner to postgres;

create function pg_catalog.float8abs()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8abs() is 'implementation of @ operator';

alter function pg_catalog.float8abs() owner to postgres;

create function pg_catalog.float8_accum()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_accum() is 'aggregate transition function';

alter function pg_catalog.float8_accum() owner to postgres;

create function pg_catalog.float8larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8larger() is 'larger of two';

alter function pg_catalog.float8larger() owner to postgres;

create function pg_catalog.float8smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8smaller() is 'smaller of two';

alter function pg_catalog.float8smaller() owner to postgres;

create function pg_catalog.lseg_center()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_center() is 'implementation of @@ operator';

alter function pg_catalog.lseg_center() owner to postgres;

create function pg_catalog.path_center()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_center() is 'implementation of @@ operator';

alter function pg_catalog.path_center() owner to postgres;

create function pg_catalog.poly_center()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_center() is 'implementation of @@ operator';

alter function pg_catalog.poly_center() owner to postgres;

create function pg_catalog.dround()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dround() is 'round to nearest integer';

alter function pg_catalog.dround() owner to postgres;

create function pg_catalog.dtrunc()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dtrunc() is 'truncate to integer';

alter function pg_catalog.dtrunc() owner to postgres;

create function pg_catalog.dsqrt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsqrt() is 'implementation of |/ operator';

alter function pg_catalog.dsqrt() owner to postgres;

create function pg_catalog.dcbrt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dcbrt() is 'implementation of ||/ operator';

alter function pg_catalog.dcbrt() owner to postgres;

create function pg_catalog.dpow()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dpow() is 'implementation of ^ operator';

alter function pg_catalog.dpow() owner to postgres;

create function pg_catalog.dexp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dexp() is 'natural exponential (e^x)';

alter function pg_catalog.dexp() owner to postgres;

create function pg_catalog.dlog1()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dlog1() is 'natural logarithm';

alter function pg_catalog.dlog1() owner to postgres;

create function pg_catalog.float8(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(smallint) is 'convert int2 to float8';

alter function pg_catalog.float8(smallint) owner to postgres;

create function pg_catalog.float4(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(smallint) is 'convert int2 to float4';

alter function pg_catalog.float4(smallint) owner to postgres;

create function pg_catalog.int2(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(double precision) is 'convert float8 to int2';

alter function pg_catalog.int2(double precision) owner to postgres;

create function pg_catalog.int2(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(real) is 'convert float4 to int2';

alter function pg_catalog.int2(real) owner to postgres;

create function pg_catalog.line_distance()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_distance() is 'implementation of <-> operator';

alter function pg_catalog.line_distance() owner to postgres;

create function pg_catalog.nameeqtext()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameeqtext() is 'implementation of = operator';

alter function pg_catalog.nameeqtext() owner to postgres;

create function pg_catalog.namelttext()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namelttext() is 'implementation of < operator';

alter function pg_catalog.namelttext() owner to postgres;

create function pg_catalog.nameletext()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameletext() is 'implementation of <= operator';

alter function pg_catalog.nameletext() owner to postgres;

create function pg_catalog.namegetext()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namegetext() is 'implementation of >= operator';

alter function pg_catalog.namegetext() owner to postgres;

create function pg_catalog.namegttext()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namegttext() is 'implementation of > operator';

alter function pg_catalog.namegttext() owner to postgres;

create function pg_catalog.namenetext()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namenetext() is 'implementation of <> operator';

alter function pg_catalog.namenetext() owner to postgres;

create function pg_catalog.btnametextcmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btnametextcmp() is 'less-equal-greater';

alter function pg_catalog.btnametextcmp() owner to postgres;

create function pg_catalog.texteqname()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texteqname() is 'implementation of = operator';

alter function pg_catalog.texteqname() owner to postgres;

create function pg_catalog.textltname()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textltname() is 'implementation of < operator';

alter function pg_catalog.textltname() owner to postgres;

create function pg_catalog.textlename()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlename() is 'implementation of <= operator';

alter function pg_catalog.textlename() owner to postgres;

create function pg_catalog.textgename()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textgename() is 'implementation of >= operator';

alter function pg_catalog.textgename() owner to postgres;

create function pg_catalog.textgtname()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textgtname() is 'implementation of > operator';

alter function pg_catalog.textgtname() owner to postgres;

create function pg_catalog.textnename()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textnename() is 'implementation of <> operator';

alter function pg_catalog.textnename() owner to postgres;

create function pg_catalog.bttextnamecmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttextnamecmp() is 'less-equal-greater';

alter function pg_catalog.bttextnamecmp() owner to postgres;

create function pg_catalog.nameconcatoid()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameconcatoid() is 'concatenate name and oid';

alter function pg_catalog.nameconcatoid() owner to postgres;

create function pg_catalog.table_am_handler_in()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_am_handler_in() is 'I/O';

alter function pg_catalog.table_am_handler_in() owner to postgres;

create function pg_catalog.table_am_handler_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_am_handler_out() is 'I/O';

alter function pg_catalog.table_am_handler_out() owner to postgres;

create function pg_catalog.timeofday()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timeofday() is 'current date and time - increments during transactions';

alter function pg_catalog.timeofday() owner to postgres;

create function pg_catalog.pg_nextoid()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_nextoid() is 'return the next oid for a system table';

alter function pg_catalog.pg_nextoid() owner to postgres;

create function pg_catalog.float8_combine()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_combine() is 'aggregate combine function';

alter function pg_catalog.float8_combine() owner to postgres;

create function pg_catalog.inter_sl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inter_sl() is 'implementation of ?# operator';

alter function pg_catalog.inter_sl() owner to postgres;

create function pg_catalog.inter_lb()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inter_lb() is 'implementation of ?# operator';

alter function pg_catalog.inter_lb() owner to postgres;

create function pg_catalog.float48mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48mul() is 'implementation of * operator';

alter function pg_catalog.float48mul() owner to postgres;

create function pg_catalog.float48div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48div() is 'implementation of / operator';

alter function pg_catalog.float48div() owner to postgres;

create function pg_catalog.float48pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48pl() is 'implementation of + operator';

alter function pg_catalog.float48pl() owner to postgres;

create function pg_catalog.float48mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48mi() is 'implementation of - operator';

alter function pg_catalog.float48mi() owner to postgres;

create function pg_catalog.float84mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84mul() is 'implementation of * operator';

alter function pg_catalog.float84mul() owner to postgres;

create function pg_catalog.float84div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84div() is 'implementation of / operator';

alter function pg_catalog.float84div() owner to postgres;

create function pg_catalog.float84pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84pl() is 'implementation of + operator';

alter function pg_catalog.float84pl() owner to postgres;

create function pg_catalog.float84mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84mi() is 'implementation of - operator';

alter function pg_catalog.float84mi() owner to postgres;

create function pg_catalog.float4eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4eq() is 'implementation of = operator';

alter function pg_catalog.float4eq() owner to postgres;

create function pg_catalog.float4ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4ne() is 'implementation of <> operator';

alter function pg_catalog.float4ne() owner to postgres;

create function pg_catalog.float4lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4lt() is 'implementation of < operator';

alter function pg_catalog.float4lt() owner to postgres;

create function pg_catalog.float4le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4le() is 'implementation of <= operator';

alter function pg_catalog.float4le() owner to postgres;

create function pg_catalog.float4gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4gt() is 'implementation of > operator';

alter function pg_catalog.float4gt() owner to postgres;

create function pg_catalog.float4ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4ge() is 'implementation of >= operator';

alter function pg_catalog.float4ge() owner to postgres;

create function pg_catalog.float8eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8eq() is 'implementation of = operator';

alter function pg_catalog.float8eq() owner to postgres;

create function pg_catalog.float8ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8ne() is 'implementation of <> operator';

alter function pg_catalog.float8ne() owner to postgres;

create function pg_catalog.float8lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8lt() is 'implementation of < operator';

alter function pg_catalog.float8lt() owner to postgres;

create function pg_catalog.float8le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8le() is 'implementation of <= operator';

alter function pg_catalog.float8le() owner to postgres;

create function pg_catalog.float8gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8gt() is 'implementation of > operator';

alter function pg_catalog.float8gt() owner to postgres;

create function pg_catalog.float8ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8ge() is 'implementation of >= operator';

alter function pg_catalog.float8ge() owner to postgres;

create function pg_catalog.float48eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48eq() is 'implementation of = operator';

alter function pg_catalog.float48eq() owner to postgres;

create function pg_catalog.float48ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48ne() is 'implementation of <> operator';

alter function pg_catalog.float48ne() owner to postgres;

create function pg_catalog.float48lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48lt() is 'implementation of < operator';

alter function pg_catalog.float48lt() owner to postgres;

create function pg_catalog.float48le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48le() is 'implementation of <= operator';

alter function pg_catalog.float48le() owner to postgres;

create function pg_catalog.float48gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48gt() is 'implementation of > operator';

alter function pg_catalog.float48gt() owner to postgres;

create function pg_catalog.float48ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48ge() is 'implementation of >= operator';

alter function pg_catalog.float48ge() owner to postgres;

create function pg_catalog.float84eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84eq() is 'implementation of = operator';

alter function pg_catalog.float84eq() owner to postgres;

create function pg_catalog.float84ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84ne() is 'implementation of <> operator';

alter function pg_catalog.float84ne() owner to postgres;

create function pg_catalog.float84lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84lt() is 'implementation of < operator';

alter function pg_catalog.float84lt() owner to postgres;

create function pg_catalog.float84le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84le() is 'implementation of <= operator';

alter function pg_catalog.float84le() owner to postgres;

create function pg_catalog.float84gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84gt() is 'implementation of > operator';

alter function pg_catalog.float84gt() owner to postgres;

create function pg_catalog.float84ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84ge() is 'implementation of >= operator';

alter function pg_catalog.float84ge() owner to postgres;

create function pg_catalog.float8(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(real) is 'convert float4 to float8';

alter function pg_catalog.float8(real) owner to postgres;

create function pg_catalog.float4(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(double precision) is 'convert float8 to float4';

alter function pg_catalog.float4(double precision) owner to postgres;

create function pg_catalog.int4(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(smallint) is 'convert int2 to int4';

alter function pg_catalog.int4(smallint) owner to postgres;

create function pg_catalog.int2()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2() is 'convert int4 to int2';

alter function pg_catalog.int2() owner to postgres;

create function pg_catalog.pg_jit_available()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_jit_available() is 'Is JIT compilation available in this session?';

alter function pg_catalog.pg_jit_available() owner to postgres;

create function pg_catalog.float8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8() is 'convert int4 to float8';

alter function pg_catalog.float8() owner to postgres;

create function pg_catalog.int4(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(double precision) is 'convert float8 to int4';

alter function pg_catalog.int4(double precision) owner to postgres;

create function pg_catalog.float4()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4() is 'convert int4 to float4';

alter function pg_catalog.float4() owner to postgres;

create function pg_catalog.int4(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(real) is 'convert float4 to int4';

alter function pg_catalog.int4(real) owner to postgres;

create function pg_catalog.width_bucket(double precision, double precision, double precision, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width_bucket(double precision, double precision, double precision, integer) is 'bucket number of operand in equal-width histogram';

alter function pg_catalog.width_bucket(double precision, double precision, double precision, integer) owner to postgres;

create function pg_catalog.json_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_in() is 'I/O';

alter function pg_catalog.json_in() owner to postgres;

create function pg_catalog.json_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_out() is 'I/O';

alter function pg_catalog.json_out() owner to postgres;

create function pg_catalog.json_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_recv() is 'I/O';

alter function pg_catalog.json_recv() owner to postgres;

create function pg_catalog.json_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_send() is 'I/O';

alter function pg_catalog.json_send() owner to postgres;

create function pg_catalog.index_am_handler_in()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.index_am_handler_in() is 'I/O';

alter function pg_catalog.index_am_handler_in() owner to postgres;

create function pg_catalog.index_am_handler_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.index_am_handler_out() is 'I/O';

alter function pg_catalog.index_am_handler_out() owner to postgres;

create function pg_catalog.hashmacaddr8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddr8() is 'hash';

alter function pg_catalog.hashmacaddr8() owner to postgres;

create function pg_catalog.hash_aclitem()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_aclitem() is 'hash';

alter function pg_catalog.hash_aclitem() owner to postgres;

create function pg_catalog.bthandler()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bthandler() is 'btree index access method handler';

alter function pg_catalog.bthandler() owner to postgres;

create function pg_catalog.hashhandler()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashhandler() is 'hash index access method handler';

alter function pg_catalog.hashhandler() owner to postgres;

create function pg_catalog.gisthandler()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gisthandler() is 'gist index access method handler';

alter function pg_catalog.gisthandler() owner to postgres;

create function pg_catalog.ginhandler()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginhandler() is 'gin index access method handler';

alter function pg_catalog.ginhandler() owner to postgres;

create function pg_catalog.spghandler()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spghandler() is 'spgist index access method handler';

alter function pg_catalog.spghandler() owner to postgres;

create function pg_catalog.brinhandler()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brinhandler() is 'brin index access method handler';

alter function pg_catalog.brinhandler() owner to postgres;

create function pg_catalog.scalarlesel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarlesel() is 'restriction selectivity of <= and related operators on scalar datatypes';

alter function pg_catalog.scalarlesel() owner to postgres;

create function pg_catalog.scalargesel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargesel() is 'restriction selectivity of >= and related operators on scalar datatypes';

alter function pg_catalog.scalargesel() owner to postgres;

create function pg_catalog.amvalidate()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.amvalidate() is 'validate an operator class';

alter function pg_catalog.amvalidate() owner to postgres;

create function pg_catalog.poly_same()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_same() is 'implementation of ~= operator';

alter function pg_catalog.poly_same() owner to postgres;

create function pg_catalog.poly_contain()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_contain() is 'implementation of @> operator';

alter function pg_catalog.poly_contain() owner to postgres;

create function pg_catalog.poly_left()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_left() is 'implementation of << operator';

alter function pg_catalog.poly_left() owner to postgres;

create function pg_catalog.poly_overleft()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overleft() is 'implementation of &< operator';

alter function pg_catalog.poly_overleft() owner to postgres;

create function pg_catalog.poly_overright()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overright() is 'implementation of &> operator';

alter function pg_catalog.poly_overright() owner to postgres;

create function pg_catalog.poly_right()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_right() is 'implementation of >> operator';

alter function pg_catalog.poly_right() owner to postgres;

create function pg_catalog.poly_contained()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_contained() is 'implementation of <@ operator';

alter function pg_catalog.poly_contained() owner to postgres;

create function pg_catalog.poly_overlap()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overlap() is 'implementation of && operator';

alter function pg_catalog.poly_overlap() owner to postgres;

create function pg_catalog.poly_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_in() is 'I/O';

alter function pg_catalog.poly_in() owner to postgres;

create function pg_catalog.poly_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_out() is 'I/O';

alter function pg_catalog.poly_out() owner to postgres;

create function pg_catalog.btint2cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint2cmp() is 'less-equal-greater';

alter function pg_catalog.btint2cmp() owner to postgres;

create function pg_catalog.btint4cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint4cmp() is 'less-equal-greater';

alter function pg_catalog.btint4cmp() owner to postgres;

create function pg_catalog.btfloat4cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat4cmp() is 'less-equal-greater';

alter function pg_catalog.btfloat4cmp() owner to postgres;

create function pg_catalog.btfloat8cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat8cmp() is 'less-equal-greater';

alter function pg_catalog.btfloat8cmp() owner to postgres;

create function pg_catalog.btoidcmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btoidcmp() is 'less-equal-greater';

alter function pg_catalog.btoidcmp() owner to postgres;

create function pg_catalog.btcharcmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btcharcmp() is 'less-equal-greater';

alter function pg_catalog.btcharcmp() owner to postgres;

create function pg_catalog.btnamecmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btnamecmp() is 'less-equal-greater';

alter function pg_catalog.btnamecmp() owner to postgres;

create function pg_catalog.bttextcmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttextcmp() is 'less-equal-greater';

alter function pg_catalog.bttextcmp() owner to postgres;

create function pg_catalog.lseg_distance()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_distance() is 'implementation of <-> operator';

alter function pg_catalog.lseg_distance() owner to postgres;

create function pg_catalog.lseg_interpt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_interpt() is 'implementation of # operator';

alter function pg_catalog.lseg_interpt() owner to postgres;

create function pg_catalog.dist_ps()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ps() is 'implementation of <-> operator';

alter function pg_catalog.dist_ps() owner to postgres;

create function pg_catalog.dist_pb()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pb() is 'implementation of <-> operator';

alter function pg_catalog.dist_pb() owner to postgres;

create function pg_catalog.dist_sb()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_sb() is 'implementation of <-> operator';

alter function pg_catalog.dist_sb() owner to postgres;

create function pg_catalog.close_ps()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_ps() is 'implementation of ## operator';

alter function pg_catalog.close_ps() owner to postgres;

create function pg_catalog.close_pb()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_pb() is 'implementation of ## operator';

alter function pg_catalog.close_pb() owner to postgres;

create function pg_catalog.close_sb()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_sb() is 'implementation of ## operator';

alter function pg_catalog.close_sb() owner to postgres;

create function pg_catalog.on_ps()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_ps() is 'implementation of <@ operator';

alter function pg_catalog.on_ps() owner to postgres;

create function pg_catalog.path_distance()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_distance() is 'implementation of <-> operator';

alter function pg_catalog.path_distance() owner to postgres;

create function pg_catalog.dist_ppath()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ppath() is 'implementation of <-> operator';

alter function pg_catalog.dist_ppath() owner to postgres;

create function pg_catalog.on_sb()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_sb() is 'implementation of <@ operator';

alter function pg_catalog.on_sb() owner to postgres;

create function pg_catalog.inter_sb()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inter_sb() is 'implementation of ?# operator';

alter function pg_catalog.inter_sb() owner to postgres;

create function pg_catalog.string_to_array()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_to_array() is 'split delimited text into text[], with null string';

alter function pg_catalog.string_to_array() owner to postgres;

create function pg_catalog.cash_cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_cmp() is 'less-equal-greater';

alter function pg_catalog.cash_cmp() owner to postgres;

create function pg_catalog.array_append()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_append() is 'append element onto end of array';

alter function pg_catalog.array_append() owner to postgres;

create function pg_catalog.array_prepend()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_prepend() is 'prepend element onto front of array';

alter function pg_catalog.array_prepend() owner to postgres;

create function pg_catalog.btarraycmp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btarraycmp() is 'less-equal-greater';

alter function pg_catalog.btarraycmp() owner to postgres;

create function pg_catalog.array_cat()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_cat() is 'implementation of || operator';

alter function pg_catalog.array_cat() owner to postgres;

create function pg_catalog.array_to_string()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_string() is 'concatenate array elements, using delimiter and null string, into text';

alter function pg_catalog.array_to_string() owner to postgres;

create function pg_catalog.scalarlejoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarlejoinsel() is 'join selectivity of <= and related operators on scalar datatypes';

alter function pg_catalog.scalarlejoinsel() owner to postgres;

create function pg_catalog.array_ne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_ne() is 'implementation of <> operator';

alter function pg_catalog.array_ne() owner to postgres;

create function pg_catalog.array_lt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_lt() is 'implementation of < operator';

alter function pg_catalog.array_lt() owner to postgres;

create function pg_catalog.array_gt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_gt() is 'implementation of > operator';

alter function pg_catalog.array_gt() owner to postgres;

create function pg_catalog.array_le()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_le() is 'implementation of <= operator';

alter function pg_catalog.array_le() owner to postgres;

create function pg_catalog.string_to_array()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_to_array() is 'split delimited text into text[]';

alter function pg_catalog.string_to_array() owner to postgres;

create function pg_catalog.array_to_string()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_string() is 'concatenate array elements, using delimiter, into text';

alter function pg_catalog.array_to_string() owner to postgres;

create function pg_catalog.array_ge()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_ge() is 'implementation of >= operator';

alter function pg_catalog.array_ge() owner to postgres;

create function pg_catalog.scalargejoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargejoinsel() is 'join selectivity of >= and related operators on scalar datatypes';

alter function pg_catalog.scalargejoinsel() owner to postgres;

create function pg_catalog.hashmacaddr()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddr() is 'hash';

alter function pg_catalog.hashmacaddr() owner to postgres;

create function pg_catalog.hashtext()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtext() is 'hash';

alter function pg_catalog.hashtext() owner to postgres;

create function pg_catalog.text(char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(char) is 'convert char(n) to text';

alter function pg_catalog.text(char) owner to postgres;

create function pg_catalog.btoidvectorcmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btoidvectorcmp() is 'less-equal-greater';

alter function pg_catalog.btoidvectorcmp() owner to postgres;

create function pg_catalog.text(name)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(name) is 'convert name to text';

alter function pg_catalog.text(name) owner to postgres;

create function pg_catalog.name(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.name(text) is 'convert text to name';

alter function pg_catalog.name(text) owner to postgres;

create function pg_catalog.bpchar(name)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar(name) is 'convert name to char(n)';

alter function pg_catalog.bpchar(name) owner to postgres;

create function pg_catalog.name(char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.name(char) is 'convert char(n) to name';

alter function pg_catalog.name(char) owner to postgres;

create function pg_catalog.hashinet()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashinet() is 'hash';

alter function pg_catalog.hashinet() owner to postgres;

create function pg_catalog.hashint4extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint4extended() is 'hash';

alter function pg_catalog.hashint4extended() owner to postgres;

create function pg_catalog.hash_numeric()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_numeric() is 'hash';

alter function pg_catalog.hash_numeric() owner to postgres;

create function pg_catalog.macaddr_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_in() is 'I/O';

alter function pg_catalog.macaddr_in() owner to postgres;

create function pg_catalog.macaddr_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_out() is 'I/O';

alter function pg_catalog.macaddr_out() owner to postgres;

create function pg_catalog.num_nulls()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.num_nulls() is 'count the number of NULL arguments';

alter function pg_catalog.num_nulls() owner to postgres;

create function pg_catalog.num_nonnulls()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.num_nonnulls() is 'count the number of non-NULL arguments';

alter function pg_catalog.num_nonnulls() owner to postgres;

create function pg_catalog.hashint2extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint2extended() is 'hash';

alter function pg_catalog.hashint2extended() owner to postgres;

create function pg_catalog.hashint8extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint8extended() is 'hash';

alter function pg_catalog.hashint8extended() owner to postgres;

create function pg_catalog.hashfloat4extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat4extended() is 'hash';

alter function pg_catalog.hashfloat4extended() owner to postgres;

create function pg_catalog.hashfloat8extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat8extended() is 'hash';

alter function pg_catalog.hashfloat8extended() owner to postgres;

create function pg_catalog.hashoidextended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoidextended() is 'hash';

alter function pg_catalog.hashoidextended() owner to postgres;

create function pg_catalog.hashcharextended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashcharextended() is 'hash';

alter function pg_catalog.hashcharextended() owner to postgres;

create function pg_catalog.hashnameextended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashnameextended() is 'hash';

alter function pg_catalog.hashnameextended() owner to postgres;

create function pg_catalog.hashtextextended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtextextended() is 'hash';

alter function pg_catalog.hashtextextended() owner to postgres;

create function pg_catalog.hashint2()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint2() is 'hash';

alter function pg_catalog.hashint2() owner to postgres;

create function pg_catalog.hashint4()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint4() is 'hash';

alter function pg_catalog.hashint4() owner to postgres;

create function pg_catalog.hashfloat4()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat4() is 'hash';

alter function pg_catalog.hashfloat4() owner to postgres;

create function pg_catalog.hashfloat8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat8() is 'hash';

alter function pg_catalog.hashfloat8() owner to postgres;

create function pg_catalog.hashoid()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoid() is 'hash';

alter function pg_catalog.hashoid() owner to postgres;

create function pg_catalog.hashchar()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashchar() is 'hash';

alter function pg_catalog.hashchar() owner to postgres;

create function pg_catalog.hashname()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashname() is 'hash';

alter function pg_catalog.hashname() owner to postgres;

create function pg_catalog.hashvarlena()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashvarlena() is 'hash';

alter function pg_catalog.hashvarlena() owner to postgres;

create function pg_catalog.hashoidvector()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoidvector() is 'hash';

alter function pg_catalog.hashoidvector() owner to postgres;

create function pg_catalog.text_larger()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_larger() is 'larger of two';

alter function pg_catalog.text_larger() owner to postgres;

create function pg_catalog.text_smaller()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_smaller() is 'smaller of two';

alter function pg_catalog.text_smaller() owner to postgres;

create function pg_catalog.int8in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8in() is 'I/O';

alter function pg_catalog.int8in() owner to postgres;

create function pg_catalog.int8out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8out() is 'I/O';

alter function pg_catalog.int8out() owner to postgres;

create function pg_catalog.int8um()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8um() is 'implementation of - operator';

alter function pg_catalog.int8um() owner to postgres;

create function pg_catalog.int8pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8pl() is 'implementation of + operator';

alter function pg_catalog.int8pl() owner to postgres;

create function pg_catalog.int8mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8mi() is 'implementation of - operator';

alter function pg_catalog.int8mi() owner to postgres;

create function pg_catalog.int8mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8mul() is 'implementation of * operator';

alter function pg_catalog.int8mul() owner to postgres;

create function pg_catalog.int8div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8div() is 'implementation of / operator';

alter function pg_catalog.int8div() owner to postgres;

create function pg_catalog.int8eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8eq() is 'implementation of = operator';

alter function pg_catalog.int8eq() owner to postgres;

create function pg_catalog.int8ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8ne() is 'implementation of <> operator';

alter function pg_catalog.int8ne() owner to postgres;

create function pg_catalog.int8lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8lt() is 'implementation of < operator';

alter function pg_catalog.int8lt() owner to postgres;

create function pg_catalog.int8gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8gt() is 'implementation of > operator';

alter function pg_catalog.int8gt() owner to postgres;

create function pg_catalog.int8le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8le() is 'implementation of <= operator';

alter function pg_catalog.int8le() owner to postgres;

create function pg_catalog.int8ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8ge() is 'implementation of >= operator';

alter function pg_catalog.int8ge() owner to postgres;

create function pg_catalog.int84eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84eq() is 'implementation of = operator';

alter function pg_catalog.int84eq() owner to postgres;

create function pg_catalog.int84ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84ne() is 'implementation of <> operator';

alter function pg_catalog.int84ne() owner to postgres;

create function pg_catalog.int84lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84lt() is 'implementation of < operator';

alter function pg_catalog.int84lt() owner to postgres;

create function pg_catalog.int84gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84gt() is 'implementation of > operator';

alter function pg_catalog.int84gt() owner to postgres;

create function pg_catalog.int84le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84le() is 'implementation of <= operator';

alter function pg_catalog.int84le() owner to postgres;

create function pg_catalog.int84ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84ge() is 'implementation of >= operator';

alter function pg_catalog.int84ge() owner to postgres;

create function pg_catalog.int4(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(bigint) is 'convert int8 to int4';

alter function pg_catalog.int4(bigint) owner to postgres;

create function pg_catalog.int8(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(integer) is 'convert int4 to int8';

alter function pg_catalog.int8(integer) owner to postgres;

create function pg_catalog.float8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8() is 'convert int8 to float8';

alter function pg_catalog.float8() owner to postgres;

create function pg_catalog.int8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8() is 'convert float8 to int8';

alter function pg_catalog.int8() owner to postgres;

create function pg_catalog.array_larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_larger() is 'larger of two';

alter function pg_catalog.array_larger() owner to postgres;

create function pg_catalog.array_smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_smaller() is 'smaller of two';

alter function pg_catalog.array_smaller() owner to postgres;

create function pg_catalog.abbrev(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abbrev(inet) is 'abbreviated display of inet value';

alter function pg_catalog.abbrev(inet) owner to postgres;

create function pg_catalog.abbrev(cidr)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abbrev(cidr) is 'abbreviated display of cidr value';

alter function pg_catalog.abbrev(cidr) owner to postgres;

create function pg_catalog.set_masklen(inet) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_masklen(inet) is 'change netmask of inet';

alter function pg_catalog.set_masklen(inet) owner to postgres;

create function pg_catalog.oidvectorne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorne() is 'implementation of <> operator';

alter function pg_catalog.oidvectorne() owner to postgres;

create function pg_catalog.hash_array()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_array() is 'hash';

alter function pg_catalog.hash_array() owner to postgres;

create function pg_catalog.set_masklen(cidr) returns cidr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_masklen(cidr) is 'change netmask of cidr';

alter function pg_catalog.set_masklen(cidr) owner to postgres;

create function pg_catalog.pg_indexam_has_property()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_indexam_has_property() is 'test property of an index access method';

alter function pg_catalog.pg_indexam_has_property() owner to postgres;

create function pg_catalog.pg_index_has_property()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_index_has_property() is 'test property of an index';

alter function pg_catalog.pg_index_has_property() owner to postgres;

create function pg_catalog.pg_index_column_has_property()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_index_column_has_property() is 'test property of an index column';

alter function pg_catalog.pg_index_column_has_property() owner to postgres;

create function pg_catalog.float4()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4() is 'convert int8 to float4';

alter function pg_catalog.float4() owner to postgres;

create function pg_catalog.int8(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(real) is 'convert float4 to int8';

alter function pg_catalog.int8(real) owner to postgres;

create function pg_catalog.namelt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namelt() is 'implementation of < operator';

alter function pg_catalog.namelt() owner to postgres;

create function pg_catalog.namele()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namele() is 'implementation of <= operator';

alter function pg_catalog.namele() owner to postgres;

create function pg_catalog.namegt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namegt() is 'implementation of > operator';

alter function pg_catalog.namegt() owner to postgres;

create function pg_catalog.namege()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namege() is 'implementation of >= operator';

alter function pg_catalog.namege() owner to postgres;

create function pg_catalog.namene()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namene() is 'implementation of <> operator';

alter function pg_catalog.namene() owner to postgres;

create function pg_catalog.bpchar(char, integer, boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar(char, integer, boolean) is 'adjust char() to typmod length';

alter function pg_catalog.bpchar(char, integer, boolean) owner to postgres;

create function pg_catalog.varchar()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchar() is 'adjust varchar() to typmod length';

alter function pg_catalog.varchar() owner to postgres;

create function pg_catalog.pg_indexam_progress_phasename()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_indexam_progress_phasename() is 'return name of given index build phase';

alter function pg_catalog.pg_indexam_progress_phasename() owner to postgres;

create function pg_catalog.oidvectorlt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorlt() is 'implementation of < operator';

alter function pg_catalog.oidvectorlt() owner to postgres;

create function pg_catalog.oidvectorle()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorle() is 'implementation of <= operator';

alter function pg_catalog.oidvectorle() owner to postgres;

create function pg_catalog.oidvectoreq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectoreq() is 'implementation of = operator';

alter function pg_catalog.oidvectoreq() owner to postgres;

create function pg_catalog.oidvectorge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorge() is 'implementation of >= operator';

alter function pg_catalog.oidvectorge() owner to postgres;

create function pg_catalog.oidvectorgt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorgt() is 'implementation of > operator';

alter function pg_catalog.oidvectorgt() owner to postgres;

create function pg_catalog.network()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network() is 'network part of address';

alter function pg_catalog.network() owner to postgres;

create function pg_catalog.netmask()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.netmask() is 'netmask of address';

alter function pg_catalog.netmask() owner to postgres;

create function pg_catalog.masklen()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.masklen() is 'netmask length';

alter function pg_catalog.masklen() owner to postgres;

create function pg_catalog.broadcast()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.broadcast() is 'broadcast address of network';

alter function pg_catalog.broadcast() owner to postgres;

create function pg_catalog.host()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.host() is 'show address octets only';

alter function pg_catalog.host() owner to postgres;

create function pg_catalog.getpgusername()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.getpgusername() is 'deprecated, use current_user instead';

alter function pg_catalog.getpgusername() owner to postgres;

create function pg_catalog.family()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.family() is 'address family (4 for IPv4, 6 for IPv6)';

alter function pg_catalog.family() owner to postgres;

create function pg_catalog.int2()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2() is 'convert int8 to int2';

alter function pg_catalog.int2() owner to postgres;

create function pg_catalog.lo_create()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_create() is 'large object create';

alter function pg_catalog.lo_create() owner to postgres;

create function pg_catalog.oidlt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidlt() is 'implementation of < operator';

alter function pg_catalog.oidlt() owner to postgres;

create function pg_catalog.oidle()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidle() is 'implementation of <= operator';

alter function pg_catalog.oidle() owner to postgres;

create function pg_catalog.octet_length(bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(bytea) is 'octet length';

alter function pg_catalog.octet_length(bytea) owner to postgres;

create function pg_catalog.get_byte()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_byte() is 'get byte';

alter function pg_catalog.get_byte() owner to postgres;

create function pg_catalog.set_byte()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_byte() is 'set byte';

alter function pg_catalog.set_byte() owner to postgres;

create function pg_catalog.get_bit(bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_bit(bytea) is 'get bit';

alter function pg_catalog.get_bit(bytea) owner to postgres;

create function pg_catalog.set_bit(bytea) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_bit(bytea) is 'set bit';

alter function pg_catalog.set_bit(bytea) owner to postgres;

create function pg_catalog.dist_pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pl() is 'implementation of <-> operator';

alter function pg_catalog.dist_pl() owner to postgres;

create function pg_catalog.dist_lb()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_lb() is 'implementation of <-> operator';

alter function pg_catalog.dist_lb() owner to postgres;

create function pg_catalog.dist_sl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_sl() is 'implementation of <-> operator';

alter function pg_catalog.dist_sl() owner to postgres;

create function pg_catalog.dist_cpoly()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_cpoly() is 'implementation of <-> operator';

alter function pg_catalog.dist_cpoly() owner to postgres;

create function pg_catalog.poly_distance()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_distance() is 'implementation of <-> operator';

alter function pg_catalog.poly_distance() owner to postgres;

create function pg_catalog.text(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(inet) is 'show all parts of inet/cidr value';

alter function pg_catalog.text(inet) owner to postgres;

create function pg_catalog.text_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_lt() is 'implementation of < operator';

alter function pg_catalog.text_lt() owner to postgres;

create function pg_catalog.text_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_le() is 'implementation of <= operator';

alter function pg_catalog.text_le() owner to postgres;

create function pg_catalog.text_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_gt() is 'implementation of > operator';

alter function pg_catalog.text_gt() owner to postgres;

create function pg_catalog.text_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_ge() is 'implementation of >= operator';

alter function pg_catalog.text_ge() owner to postgres;

create function pg_catalog.array_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_eq() is 'implementation of = operator';

alter function pg_catalog.array_eq() owner to postgres;

create function pg_catalog."current_user"()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."current_user"() is 'current user name';

alter function pg_catalog."current_user"() owner to postgres;

create function pg_catalog."session_user"()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."session_user"() is 'session user name';

alter function pg_catalog."session_user"() owner to postgres;

create function pg_catalog.array_dims()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_dims() is 'array dimensions';

alter function pg_catalog.array_dims() owner to postgres;

create function pg_catalog.array_ndims()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_ndims() is 'number of array dimensions';

alter function pg_catalog.array_ndims() owner to postgres;

create function pg_catalog.overlay(bytea, bytea, integer) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(bytea, bytea, integer) is 'substitute portion of string';

alter function pg_catalog.overlay(bytea, bytea, integer) owner to postgres;

create function pg_catalog.array_in()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_in() is 'I/O';

alter function pg_catalog.array_in() owner to postgres;

create function pg_catalog.array_out()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_out() is 'I/O';

alter function pg_catalog.array_out() owner to postgres;

create function pg_catalog.overlay(bytea, bytea) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(bytea, bytea) is 'substitute portion of string';

alter function pg_catalog.overlay(bytea, bytea) owner to postgres;

create function pg_catalog.trunc(macaddr) returns macaddr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(macaddr) is 'MACADDR manufacturer fields';

alter function pg_catalog.trunc(macaddr) owner to postgres;

create function pg_catalog.int8(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(smallint) is 'convert int2 to int8';

alter function pg_catalog.int8(smallint) owner to postgres;

create function pg_catalog.lo_import()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_import() is 'large object import';

alter function pg_catalog.lo_import() owner to postgres;

create function pg_catalog.lo_export()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_export() is 'large object export';

alter function pg_catalog.lo_export() owner to postgres;

create function pg_catalog.int4inc()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4inc() is 'increment';

alter function pg_catalog.int4inc() owner to postgres;

create function pg_catalog.lo_import()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_import() is 'large object import';

alter function pg_catalog.lo_import() owner to postgres;

create function pg_catalog.int4larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4larger() is 'larger of two';

alter function pg_catalog.int4larger() owner to postgres;

create function pg_catalog.int4smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4smaller() is 'smaller of two';

alter function pg_catalog.int4smaller() owner to postgres;

create function pg_catalog.int2larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2larger() is 'larger of two';

alter function pg_catalog.int2larger() owner to postgres;

create function pg_catalog.int2smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2smaller() is 'smaller of two';

alter function pg_catalog.int2smaller() owner to postgres;

create function pg_catalog.hashvarlenaextended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashvarlenaextended() is 'hash';

alter function pg_catalog.hashvarlenaextended() owner to postgres;

create function pg_catalog.hashoidvectorextended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoidvectorextended() is 'hash';

alter function pg_catalog.hashoidvectorextended() owner to postgres;

create function pg_catalog.hash_aclitem_extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_aclitem_extended() is 'hash';

alter function pg_catalog.hash_aclitem_extended() owner to postgres;

create function pg_catalog.hashmacaddrextended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddrextended() is 'hash';

alter function pg_catalog.hashmacaddrextended() owner to postgres;

create function pg_catalog.hashinetextended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashinetextended() is 'hash';

alter function pg_catalog.hashinetextended() owner to postgres;

create function pg_catalog.hash_numeric_extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_numeric_extended() is 'hash';

alter function pg_catalog.hash_numeric_extended() owner to postgres;

create function pg_catalog.hashmacaddr8extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddr8extended() is 'hash';

alter function pg_catalog.hashmacaddr8extended() owner to postgres;

create function pg_catalog.hash_array_extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_array_extended() is 'hash';

alter function pg_catalog.hash_array_extended() owner to postgres;

create function pg_catalog.pg_client_encoding()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_client_encoding() is 'encoding name of current database';

alter function pg_catalog.pg_client_encoding() owner to postgres;

create function pg_catalog.current_query()
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_query() is 'get the currently executing query';

alter function pg_catalog.current_query() owner to postgres;

create function pg_catalog.macaddr_eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_eq() is 'implementation of = operator';

alter function pg_catalog.macaddr_eq() owner to postgres;

create function pg_catalog.macaddr_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_lt() is 'implementation of < operator';

alter function pg_catalog.macaddr_lt() owner to postgres;

create function pg_catalog.macaddr_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_le() is 'implementation of <= operator';

alter function pg_catalog.macaddr_le() owner to postgres;

create function pg_catalog.macaddr_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_gt() is 'implementation of > operator';

alter function pg_catalog.macaddr_gt() owner to postgres;

create function pg_catalog.macaddr_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_ge() is 'implementation of >= operator';

alter function pg_catalog.macaddr_ge() owner to postgres;

create function pg_catalog.macaddr_ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_ne() is 'implementation of <> operator';

alter function pg_catalog.macaddr_ne() owner to postgres;

create function pg_catalog.macaddr_cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_cmp() is 'less-equal-greater';

alter function pg_catalog.macaddr_cmp() owner to postgres;

create function pg_catalog.int82pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82pl() is 'implementation of + operator';

alter function pg_catalog.int82pl() owner to postgres;

create function pg_catalog.int82mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82mi() is 'implementation of - operator';

alter function pg_catalog.int82mi() owner to postgres;

create function pg_catalog.int82mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82mul() is 'implementation of * operator';

alter function pg_catalog.int82mul() owner to postgres;

create function pg_catalog.int82div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82div() is 'implementation of / operator';

alter function pg_catalog.int82div() owner to postgres;

create function pg_catalog.int28pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28pl() is 'implementation of + operator';

alter function pg_catalog.int28pl() owner to postgres;

create function pg_catalog.btint8cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint8cmp() is 'less-equal-greater';

alter function pg_catalog.btint8cmp() owner to postgres;

create function pg_catalog.cash_mul_flt4()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_flt4() is 'implementation of * operator';

alter function pg_catalog.cash_mul_flt4() owner to postgres;

create function pg_catalog.cash_div_flt4()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_flt4() is 'implementation of / operator';

alter function pg_catalog.cash_div_flt4() owner to postgres;

create function pg_catalog.flt4_mul_cash()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.flt4_mul_cash() is 'implementation of * operator';

alter function pg_catalog.flt4_mul_cash() owner to postgres;

create function pg_catalog.position(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.position(text, text) is 'position of substring';

alter function pg_catalog.position(text, text) owner to postgres;

create function pg_catalog.textlike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlike() is 'implementation of ~~ operator';

alter function pg_catalog.textlike() owner to postgres;

create function pg_catalog.textnlike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textnlike() is 'implementation of !~~ operator';

alter function pg_catalog.textnlike() owner to postgres;

create function pg_catalog.int48eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48eq() is 'implementation of = operator';

alter function pg_catalog.int48eq() owner to postgres;

create function pg_catalog.int48ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48ne() is 'implementation of <> operator';

alter function pg_catalog.int48ne() owner to postgres;

create function pg_catalog.int48lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48lt() is 'implementation of < operator';

alter function pg_catalog.int48lt() owner to postgres;

create function pg_catalog.int48gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48gt() is 'implementation of > operator';

alter function pg_catalog.int48gt() owner to postgres;

create function pg_catalog.int48le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48le() is 'implementation of <= operator';

alter function pg_catalog.int48le() owner to postgres;

create function pg_catalog.int48ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48ge() is 'implementation of >= operator';

alter function pg_catalog.int48ge() owner to postgres;

create function pg_catalog.namelike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namelike() is 'implementation of ~~ operator';

alter function pg_catalog.namelike() owner to postgres;

create function pg_catalog.namenlike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namenlike() is 'implementation of !~~ operator';

alter function pg_catalog.namenlike() owner to postgres;

create function pg_catalog.bpchar()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar() is 'convert char to char(n)';

alter function pg_catalog.bpchar() owner to postgres;

create function pg_catalog.current_database()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_database() is 'name of the current database';

alter function pg_catalog.current_database() owner to postgres;

create function pg_catalog.int4_mul_cash()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_mul_cash() is 'implementation of * operator';

alter function pg_catalog.int4_mul_cash() owner to postgres;

create function pg_catalog.int2_mul_cash()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_mul_cash() is 'implementation of * operator';

alter function pg_catalog.int2_mul_cash() owner to postgres;

create function pg_catalog.cash_mul_int4()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_int4() is 'implementation of * operator';

alter function pg_catalog.cash_mul_int4() owner to postgres;

create function pg_catalog.cash_div_int4()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_int4() is 'implementation of / operator';

alter function pg_catalog.cash_div_int4() owner to postgres;

create function pg_catalog.cash_mul_int2()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_int2() is 'implementation of * operator';

alter function pg_catalog.cash_mul_int2() owner to postgres;

create function pg_catalog.cash_div_int2()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_int2() is 'implementation of / operator';

alter function pg_catalog.cash_div_int2() owner to postgres;

create function pg_catalog.strpos()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.strpos() is 'position of substring';

alter function pg_catalog.strpos() owner to postgres;

create function pg_catalog.lower()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower() is 'lowercase';

alter function pg_catalog.lower() owner to postgres;

create function pg_catalog.upper()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper() is 'uppercase';

alter function pg_catalog.upper() owner to postgres;

create function pg_catalog.initcap()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.initcap() is 'capitalize each word';

alter function pg_catalog.initcap() owner to postgres;

create function pg_catalog.lpad(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lpad(text) is 'left-pad string to length';

alter function pg_catalog.lpad(text) owner to postgres;

create function pg_catalog.rpad(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rpad(text) is 'right-pad string to length';

alter function pg_catalog.rpad(text) owner to postgres;

create function pg_catalog.ltrim()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ltrim() is 'trim selected characters from left end of string';

alter function pg_catalog.ltrim() owner to postgres;

create function pg_catalog.rtrim()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rtrim() is 'trim selected characters from right end of string';

alter function pg_catalog.rtrim() owner to postgres;

create function pg_catalog.substr(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(text, integer) is 'extract portion of string';

alter function pg_catalog.substr(text, integer) owner to postgres;

create function pg_catalog.translate()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.translate() is 'map a set of characters appearing in string';

alter function pg_catalog.translate() owner to postgres;

create function pg_catalog.lpad(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.lpad() is 'left-pad string to length';

alter function pg_catalog.lpad() owner to postgres;

create function pg_catalog.rpad(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.rpad() is 'right-pad string to length';

alter function pg_catalog.rpad() owner to postgres;

create function pg_catalog.ltrim()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ltrim() is 'trim spaces from left end of string';

alter function pg_catalog.ltrim() owner to postgres;

create function pg_catalog.rtrim()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rtrim() is 'trim spaces from right end of string';

alter function pg_catalog.rtrim() owner to postgres;

create function pg_catalog.substr(text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(text) is 'extract portion of string';

alter function pg_catalog.substr(text) owner to postgres;

create function pg_catalog.btrim(text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrim(text, text) is 'trim selected characters from both ends of string';

alter function pg_catalog.btrim(text, text) owner to postgres;

create function pg_catalog.btrim()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrim() is 'trim spaces from both ends of string';

alter function pg_catalog.btrim() owner to postgres;

create function pg_catalog.cash_in()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_in() is 'I/O';

alter function pg_catalog.cash_in() owner to postgres;

create function pg_catalog.cash_out()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_out() is 'I/O';

alter function pg_catalog.cash_out() owner to postgres;

create function pg_catalog.cash_eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_eq() is 'implementation of = operator';

alter function pg_catalog.cash_eq() owner to postgres;

create function pg_catalog.cash_ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_ne() is 'implementation of <> operator';

alter function pg_catalog.cash_ne() owner to postgres;

create function pg_catalog.cash_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_lt() is 'implementation of < operator';

alter function pg_catalog.cash_lt() owner to postgres;

create function pg_catalog.cash_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_le() is 'implementation of <= operator';

alter function pg_catalog.cash_le() owner to postgres;

create function pg_catalog.cash_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_gt() is 'implementation of > operator';

alter function pg_catalog.cash_gt() owner to postgres;

create function pg_catalog.cash_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_ge() is 'implementation of >= operator';

alter function pg_catalog.cash_ge() owner to postgres;

create function pg_catalog.cash_pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_pl() is 'implementation of + operator';

alter function pg_catalog.cash_pl() owner to postgres;

create function pg_catalog.cash_mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mi() is 'implementation of - operator';

alter function pg_catalog.cash_mi() owner to postgres;

create function pg_catalog.cash_mul_flt8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_flt8() is 'implementation of * operator';

alter function pg_catalog.cash_mul_flt8() owner to postgres;

create function pg_catalog.cash_div_flt8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_flt8() is 'implementation of / operator';

alter function pg_catalog.cash_div_flt8() owner to postgres;

create function pg_catalog.cashlarger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cashlarger() is 'larger of two';

alter function pg_catalog.cashlarger() owner to postgres;

create function pg_catalog.cashsmaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cashsmaller() is 'smaller of two';

alter function pg_catalog.cashsmaller() owner to postgres;

create function pg_catalog.inet_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_in() is 'I/O';

alter function pg_catalog.inet_in() owner to postgres;

create function pg_catalog.inet_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_out() is 'I/O';

alter function pg_catalog.inet_out() owner to postgres;

create function pg_catalog.flt8_mul_cash()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.flt8_mul_cash() is 'implementation of * operator';

alter function pg_catalog.flt8_mul_cash() owner to postgres;

create function pg_catalog.network_eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_eq() is 'implementation of = operator';

alter function pg_catalog.network_eq() owner to postgres;

create function pg_catalog.network_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_lt() is 'implementation of < operator';

alter function pg_catalog.network_lt() owner to postgres;

create function pg_catalog.network_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_le() is 'implementation of <= operator';

alter function pg_catalog.network_le() owner to postgres;

create function pg_catalog.network_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_gt() is 'implementation of > operator';

alter function pg_catalog.network_gt() owner to postgres;

create function pg_catalog.network_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_ge() is 'implementation of >= operator';

alter function pg_catalog.network_ge() owner to postgres;

create function pg_catalog.network_ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_ne() is 'implementation of <> operator';

alter function pg_catalog.network_ne() owner to postgres;

create function pg_catalog.network_cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_cmp() is 'less-equal-greater';

alter function pg_catalog.network_cmp() owner to postgres;

create function pg_catalog.network_sub()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_sub() is 'implementation of << operator';

alter function pg_catalog.network_sub() owner to postgres;

create function pg_catalog.network_subeq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_subeq() is 'implementation of <<= operator';

alter function pg_catalog.network_subeq() owner to postgres;

create function pg_catalog.network_sup()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_sup() is 'implementation of >> operator';

alter function pg_catalog.network_sup() owner to postgres;

create function pg_catalog.network_supeq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_supeq() is 'implementation of >>= operator';

alter function pg_catalog.network_supeq() owner to postgres;

create function pg_catalog.cash_words()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_words() is 'output money amount as words';

alter function pg_catalog.cash_words() owner to postgres;

create function pg_catalog.substring(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(text, integer) is 'extract portion of string';

alter function pg_catalog.substring(text, integer) owner to postgres;

create function pg_catalog.generate_series(timestamp, timestamp, interval) returns setof setof timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(timestamp, timestamp, interval) is 'non-persistent series generator';

alter function pg_catalog.generate_series(timestamp, timestamp, interval) owner to postgres;

create function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval) returns setof setof timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval) is 'non-persistent series generator';

alter function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval) owner to postgres;

create function pg_catalog.mod(smallint, smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(smallint, smallint) is 'modulus';

alter function pg_catalog.mod(smallint, smallint) owner to postgres;

create function pg_catalog.mod()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod() is 'modulus';

alter function pg_catalog.mod() owner to postgres;

create function pg_catalog.int28mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28mi() is 'implementation of - operator';

alter function pg_catalog.int28mi() owner to postgres;

create function pg_catalog.int28mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28mul() is 'implementation of * operator';

alter function pg_catalog.int28mul() owner to postgres;

create function pg_catalog.char()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char() is 'convert text to char';

alter function pg_catalog.char() owner to postgres;

create function pg_catalog.int8mod()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8mod() is 'implementation of % operator';

alter function pg_catalog.int8mod() owner to postgres;

create function pg_catalog.text("char")
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text("char") is 'convert char to text';

alter function pg_catalog.text("char") owner to postgres;

create function pg_catalog.mod(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(bigint, bigint) is 'modulus';

alter function pg_catalog.mod(bigint, bigint) owner to postgres;

create function pg_catalog.int28div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28div() is 'implementation of / operator';

alter function pg_catalog.int28div() owner to postgres;

create function pg_catalog.hashint8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint8() is 'hash';

alter function pg_catalog.hashint8() owner to postgres;

create function pg_catalog.lo_open()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_open() is 'large object open';

alter function pg_catalog.lo_open() owner to postgres;

create function pg_catalog.lo_close()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_close() is 'large object close';

alter function pg_catalog.lo_close() owner to postgres;

create function pg_catalog.loread()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.loread() is 'large object read';

alter function pg_catalog.loread() owner to postgres;

create function pg_catalog.lowrite()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lowrite() is 'large object write';

alter function pg_catalog.lowrite() owner to postgres;

create function pg_catalog.lo_lseek()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_lseek() is 'large object seek';

alter function pg_catalog.lo_lseek() owner to postgres;

create function pg_catalog.lo_creat()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_creat() is 'large object create';

alter function pg_catalog.lo_creat() owner to postgres;

create function pg_catalog.lo_tell()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_tell() is 'large object position';

alter function pg_catalog.lo_tell() owner to postgres;

create function pg_catalog.on_pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_pl() is 'implementation of <@ operator';

alter function pg_catalog.on_pl() owner to postgres;

create function pg_catalog.on_sl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_sl() is 'implementation of <@ operator';

alter function pg_catalog.on_sl() owner to postgres;

create function pg_catalog.close_pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_pl() is 'implementation of ## operator';

alter function pg_catalog.close_pl() owner to postgres;

create function pg_catalog.close_sl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_sl() is 'implementation of ## operator';

alter function pg_catalog.close_sl() owner to postgres;

create function pg_catalog.close_lb()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_lb() is 'implementation of ## operator';

alter function pg_catalog.close_lb() owner to postgres;

create function pg_catalog.lo_unlink()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_unlink() is 'large object unlink (delete)';

alter function pg_catalog.lo_unlink() owner to postgres;

create function pg_catalog.hashbpcharextended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashbpcharextended() is 'hash';

alter function pg_catalog.hashbpcharextended() owner to postgres;

create function pg_catalog.path_inter()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_inter() is 'implementation of ?# operator';

alter function pg_catalog.path_inter() owner to postgres;

create function pg_catalog.area(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.area(box) is 'box area';

alter function pg_catalog.area(box) owner to postgres;

create function pg_catalog.width()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width() is 'box width';

alter function pg_catalog.width() owner to postgres;

create function pg_catalog.height()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.height() is 'box height';

alter function pg_catalog.height() owner to postgres;

create function pg_catalog.box_distance()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_distance() is 'implementation of <-> operator';

alter function pg_catalog.box_distance() owner to postgres;

create function pg_catalog.area(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.area(path) is 'area of a closed path';

alter function pg_catalog.area(path) owner to postgres;

create function pg_catalog.box_intersect()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_intersect() is 'implementation of # operator';

alter function pg_catalog.box_intersect() owner to postgres;

create function pg_catalog.diagonal()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.diagonal() is 'box diagonal';

alter function pg_catalog.diagonal() owner to postgres;

create function pg_catalog.path_n_lt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_lt() is 'implementation of < operator';

alter function pg_catalog.path_n_lt() owner to postgres;

create function pg_catalog.path_n_gt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_gt() is 'implementation of > operator';

alter function pg_catalog.path_n_gt() owner to postgres;

create function pg_catalog.path_n_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_eq() is 'implementation of = operator';

alter function pg_catalog.path_n_eq() owner to postgres;

create function pg_catalog.path_n_le()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_le() is 'implementation of <= operator';

alter function pg_catalog.path_n_le() owner to postgres;

create function pg_catalog.path_n_ge()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_ge() is 'implementation of >= operator';

alter function pg_catalog.path_n_ge() owner to postgres;

create function pg_catalog.path_length()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_length() is 'implementation of @-@ operator';

alter function pg_catalog.path_length() owner to postgres;

create function pg_catalog.point_ne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_ne() is 'implementation of <> operator';

alter function pg_catalog.point_ne() owner to postgres;

create function pg_catalog.point_vert()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_vert() is 'implementation of ?| operator';

alter function pg_catalog.point_vert() owner to postgres;

create function pg_catalog.point_horiz()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_horiz() is 'implementation of ?- operator';

alter function pg_catalog.point_horiz() owner to postgres;

create function pg_catalog.point_distance()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_distance() is 'implementation of <-> operator';

alter function pg_catalog.point_distance() owner to postgres;

create function pg_catalog.slope()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.slope() is 'slope between points';

alter function pg_catalog.slope() owner to postgres;

create function pg_catalog.lseg()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg() is 'convert points to line segment';

alter function pg_catalog.lseg() owner to postgres;

create function pg_catalog.lseg_intersect()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_intersect() is 'implementation of ?# operator';

alter function pg_catalog.lseg_intersect() owner to postgres;

create function pg_catalog.lseg_parallel()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_parallel() is 'implementation of ?|| operator';

alter function pg_catalog.lseg_parallel() owner to postgres;

create function pg_catalog.lseg_perp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_perp() is 'implementation of ?-| operator';

alter function pg_catalog.lseg_perp() owner to postgres;

create function pg_catalog.lseg_vertical()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_vertical() is 'implementation of ?| operator';

alter function pg_catalog.lseg_vertical() owner to postgres;

create function pg_catalog.lseg_horizontal()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_horizontal() is 'implementation of ?- operator';

alter function pg_catalog.lseg_horizontal() owner to postgres;

create function pg_catalog.lseg_eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_eq() is 'implementation of = operator';

alter function pg_catalog.lseg_eq() owner to postgres;

create function pg_catalog.lo_truncate()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_truncate() is 'truncate large object';

alter function pg_catalog.lo_truncate() owner to postgres;

create function pg_catalog.textlike_support()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlike_support() is 'planner support for textlike';

alter function pg_catalog.textlike_support() owner to postgres;

create function pg_catalog.texticregexeq_support()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticregexeq_support() is 'planner support for texticregexeq';

alter function pg_catalog.texticregexeq_support() owner to postgres;

create function pg_catalog.texticlike_support()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticlike_support() is 'planner support for texticlike';

alter function pg_catalog.texticlike_support() owner to postgres;

create function pg_catalog.timezone(interval, timestamp with time zone) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(interval, timestamp with time zone) is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(interval, timestamp with time zone) owner to postgres;

create function pg_catalog.gist_point_compress()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_compress() is 'GiST support';

alter function pg_catalog.gist_point_compress() owner to postgres;

create function pg_catalog.aclitemin()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclitemin() is 'I/O';

alter function pg_catalog.aclitemin() owner to postgres;

create function pg_catalog.aclitemout()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclitemout() is 'I/O';

alter function pg_catalog.aclitemout() owner to postgres;

create function pg_catalog.aclinsert()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclinsert() is 'add/update ACL item';

alter function pg_catalog.aclinsert() owner to postgres;

create function pg_catalog.aclremove()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclremove() is 'remove ACL item';

alter function pg_catalog.aclremove() owner to postgres;

create function pg_catalog.aclcontains()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclcontains() is 'contains';

alter function pg_catalog.aclcontains() owner to postgres;

create function pg_catalog.getdatabaseencoding()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.getdatabaseencoding() is 'encoding name of current database';

alter function pg_catalog.getdatabaseencoding() owner to postgres;

create function pg_catalog.bpcharin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharin() is 'I/O';

alter function pg_catalog.bpcharin() owner to postgres;

create function pg_catalog.bpcharout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharout() is 'I/O';

alter function pg_catalog.bpcharout() owner to postgres;

create function pg_catalog.varcharin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharin() is 'I/O';

alter function pg_catalog.varcharin() owner to postgres;

create function pg_catalog.varcharout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharout() is 'I/O';

alter function pg_catalog.varcharout() owner to postgres;

create function pg_catalog.bpchareq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchareq() is 'implementation of = operator';

alter function pg_catalog.bpchareq() owner to postgres;

create function pg_catalog.bpcharlt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharlt() is 'implementation of < operator';

alter function pg_catalog.bpcharlt() owner to postgres;

create function pg_catalog.bpcharle()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharle() is 'implementation of <= operator';

alter function pg_catalog.bpcharle() owner to postgres;

create function pg_catalog.bpchargt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchargt() is 'implementation of > operator';

alter function pg_catalog.bpchargt() owner to postgres;

create function pg_catalog.bpcharge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharge() is 'implementation of >= operator';

alter function pg_catalog.bpcharge() owner to postgres;

create function pg_catalog.bpcharne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharne() is 'implementation of <> operator';

alter function pg_catalog.bpcharne() owner to postgres;

create function pg_catalog.aclitemeq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclitemeq() is 'implementation of = operator';

alter function pg_catalog.aclitemeq() owner to postgres;

create function pg_catalog.bpchar_larger()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_larger() is 'larger of two';

alter function pg_catalog.bpchar_larger() owner to postgres;

create function pg_catalog.bpchar_smaller()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_smaller() is 'smaller of two';

alter function pg_catalog.bpchar_smaller() owner to postgres;

create function pg_catalog.pg_prepared_xact()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_prepared_xact() is 'view two-phase transactions';

alter function pg_catalog.pg_prepared_xact() owner to postgres;

create function pg_catalog.generate_series(integer, integer, integer) returns setof setof integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(integer, integer, integer) is 'non-persistent series generator';

alter function pg_catalog.generate_series(integer, integer, integer) owner to postgres;

create function pg_catalog.generate_series(integer, integer) returns setof setof integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(integer, integer) is 'non-persistent series generator';

alter function pg_catalog.generate_series(integer, integer) owner to postgres;

create function pg_catalog.generate_series(bigint, bigint, bigint) returns setof setof bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(bigint, bigint, bigint) is 'non-persistent series generator';

alter function pg_catalog.generate_series(bigint, bigint, bigint) owner to postgres;

create function pg_catalog.generate_series(bigint, bigint) returns setof setof bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(bigint, bigint) is 'non-persistent series generator';

alter function pg_catalog.generate_series(bigint, bigint) owner to postgres;

create function pg_catalog.bpcharcmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharcmp() is 'less-equal-greater';

alter function pg_catalog.bpcharcmp() owner to postgres;

create function pg_catalog.regclass()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclass() is 'convert text to regclass';

alter function pg_catalog.regclass() owner to postgres;

create function pg_catalog.hashbpchar()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashbpchar() is 'hash';

alter function pg_catalog.hashbpchar() owner to postgres;

create function pg_catalog.format_type()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.format_type() is 'format a type oid and atttypmod to canonical SQL';

alter function pg_catalog.format_type() owner to postgres;

create function pg_catalog.date_in()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_in() is 'I/O';

alter function pg_catalog.date_in() owner to postgres;

create function pg_catalog.date_out()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_out() is 'I/O';

alter function pg_catalog.date_out() owner to postgres;

create function pg_catalog.date_eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_eq() is 'implementation of = operator';

alter function pg_catalog.date_eq() owner to postgres;

create function pg_catalog.date_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_lt() is 'implementation of < operator';

alter function pg_catalog.date_lt() owner to postgres;

create function pg_catalog.date_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_le() is 'implementation of <= operator';

alter function pg_catalog.date_le() owner to postgres;

create function pg_catalog.date_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_gt() is 'implementation of > operator';

alter function pg_catalog.date_gt() owner to postgres;

create function pg_catalog.date_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ge() is 'implementation of >= operator';

alter function pg_catalog.date_ge() owner to postgres;

create function pg_catalog.date_ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ne() is 'implementation of <> operator';

alter function pg_catalog.date_ne() owner to postgres;

create function pg_catalog.date_cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_cmp() is 'less-equal-greater';

alter function pg_catalog.date_cmp() owner to postgres;

create function pg_catalog.time_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_lt() is 'implementation of < operator';

alter function pg_catalog.time_lt() owner to postgres;

create function pg_catalog.time_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_le() is 'implementation of <= operator';

alter function pg_catalog.time_le() owner to postgres;

create function pg_catalog.time_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_gt() is 'implementation of > operator';

alter function pg_catalog.time_gt() owner to postgres;

create function pg_catalog.time_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_ge() is 'implementation of >= operator';

alter function pg_catalog.time_ge() owner to postgres;

create function pg_catalog.time_ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_ne() is 'implementation of <> operator';

alter function pg_catalog.time_ne() owner to postgres;

create function pg_catalog.time_cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_cmp() is 'less-equal-greater';

alter function pg_catalog.time_cmp() owner to postgres;

create function pg_catalog.date_larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_larger() is 'larger of two';

alter function pg_catalog.date_larger() owner to postgres;

create function pg_catalog.date_smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_smaller() is 'smaller of two';

alter function pg_catalog.date_smaller() owner to postgres;

create function pg_catalog.date_mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_mi() is 'implementation of - operator';

alter function pg_catalog.date_mi() owner to postgres;

create function pg_catalog.date_pli()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_pli() is 'implementation of + operator';

alter function pg_catalog.date_pli() owner to postgres;

create function pg_catalog.date_mii()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_mii() is 'implementation of - operator';

alter function pg_catalog.date_mii() owner to postgres;

create function pg_catalog.time_in()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_in() is 'I/O';

alter function pg_catalog.time_in() owner to postgres;

create function pg_catalog.time_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_out() is 'I/O';

alter function pg_catalog.time_out() owner to postgres;

create function pg_catalog.time_eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_eq() is 'implementation of = operator';

alter function pg_catalog.time_eq() owner to postgres;

create function pg_catalog.circle_add_pt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_add_pt() is 'implementation of + operator';

alter function pg_catalog.circle_add_pt() owner to postgres;

create function pg_catalog.circle_sub_pt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_sub_pt() is 'implementation of - operator';

alter function pg_catalog.circle_sub_pt() owner to postgres;

create function pg_catalog.circle_mul_pt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_mul_pt() is 'implementation of * operator';

alter function pg_catalog.circle_mul_pt() owner to postgres;

create function pg_catalog.circle_div_pt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_div_pt() is 'implementation of / operator';

alter function pg_catalog.circle_div_pt() owner to postgres;

create function pg_catalog.timestamptz_in()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_in() is 'I/O';

alter function pg_catalog.timestamptz_in() owner to postgres;

create function pg_catalog.timestamptz_out()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_out() is 'I/O';

alter function pg_catalog.timestamptz_out() owner to postgres;

create function pg_catalog.timestamptz_eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_eq() is 'implementation of = operator';

alter function pg_catalog.timestamptz_eq() owner to postgres;

create function pg_catalog.timestamptz_ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ne() is 'implementation of <> operator';

alter function pg_catalog.timestamptz_ne() owner to postgres;

create function pg_catalog.timestamptz_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_lt() is 'implementation of < operator';

alter function pg_catalog.timestamptz_lt() owner to postgres;

create function pg_catalog.timestamptz_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_le() is 'implementation of <= operator';

alter function pg_catalog.timestamptz_le() owner to postgres;

create function pg_catalog.timestamptz_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ge() is 'implementation of >= operator';

alter function pg_catalog.timestamptz_ge() owner to postgres;

create function pg_catalog.timestamptz_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_gt() is 'implementation of > operator';

alter function pg_catalog.timestamptz_gt() owner to postgres;

create function pg_catalog.to_timestamp(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_timestamp(double precision) is 'convert UNIX epoch to timestamptz';

alter function pg_catalog.to_timestamp(double precision) owner to postgres;

create function pg_catalog.timezone(text, timestamp with time zone) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(text, timestamp with time zone) is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(text, timestamp with time zone) owner to postgres;

create function pg_catalog.interval_in()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_in() is 'I/O';

alter function pg_catalog.interval_in() owner to postgres;

create function pg_catalog.interval_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_out() is 'I/O';

alter function pg_catalog.interval_out() owner to postgres;

create function pg_catalog.interval_eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_eq() is 'implementation of = operator';

alter function pg_catalog.interval_eq() owner to postgres;

create function pg_catalog.interval_ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_ne() is 'implementation of <> operator';

alter function pg_catalog.interval_ne() owner to postgres;

create function pg_catalog.interval_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_lt() is 'implementation of < operator';

alter function pg_catalog.interval_lt() owner to postgres;

create function pg_catalog.interval_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_le() is 'implementation of <= operator';

alter function pg_catalog.interval_le() owner to postgres;

create function pg_catalog.interval_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_ge() is 'implementation of >= operator';

alter function pg_catalog.interval_ge() owner to postgres;

create function pg_catalog.interval_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_gt() is 'implementation of > operator';

alter function pg_catalog.interval_gt() owner to postgres;

create function pg_catalog.interval_um()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_um() is 'implementation of - operator';

alter function pg_catalog.interval_um() owner to postgres;

create function pg_catalog.interval_pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl() is 'implementation of + operator';

alter function pg_catalog.interval_pl() owner to postgres;

create function pg_catalog.interval_mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_mi() is 'implementation of - operator';

alter function pg_catalog.interval_mi() owner to postgres;

create function pg_catalog.date_part(text, date) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(timestamp with time zone) is 'extract field from timestamp with time zone';

alter function pg_catalog.date_part(timestamp with time zone) owner to postgres;

create function pg_catalog.date_part()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part() is 'extract field from interval';

alter function pg_catalog.date_part() owner to postgres;

create function pg_catalog.network_subset_support()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_subset_support() is 'planner support for network_sub/superset';

alter function pg_catalog.network_subset_support() owner to postgres;

create function pg_catalog.timestamptz(date)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(date) is 'convert date to timestamp with time zone';

alter function pg_catalog.timestamptz(date) owner to postgres;

create function pg_catalog.justify_hours()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.justify_hours() is 'promote groups of 24 hours to numbers of days';

alter function pg_catalog.justify_hours() owner to postgres;

create function pg_catalog.timestamptz(date, time without time zone) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz() is 'convert date and time to timestamp with time zone';

alter function pg_catalog.timestamptz() owner to postgres;

create function pg_catalog.date(timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date(timestamp with time zone) is 'convert timestamp with time zone to date';

alter function pg_catalog.date(timestamp with time zone) owner to postgres;

create function pg_catalog.age()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.age() is 'age of a transaction ID, in transactions before current transaction';

alter function pg_catalog.age() owner to postgres;

create function pg_catalog.timestamptz_mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_mi() is 'implementation of - operator';

alter function pg_catalog.timestamptz_mi() owner to postgres;

create function pg_catalog.timestamptz_pl_interval()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_pl_interval() is 'implementation of + operator';

alter function pg_catalog.timestamptz_pl_interval() owner to postgres;

create function pg_catalog.timestamptz_mi_interval()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_mi_interval() is 'implementation of - operator';

alter function pg_catalog.timestamptz_mi_interval() owner to postgres;

create function pg_catalog.generate_subscripts(boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_subscripts(boolean) is 'array subscripts generator';

alter function pg_catalog.generate_subscripts(boolean) owner to postgres;

create function pg_catalog.generate_subscripts()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_subscripts() is 'array subscripts generator';

alter function pg_catalog.generate_subscripts() owner to postgres;

create function pg_catalog.array_fill()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_fill() is 'array constructor with value';

alter function pg_catalog.array_fill() owner to postgres;

create function pg_catalog.log10(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.log10(double precision) is 'base 10 logarithm';

alter function pg_catalog.log10(double precision) owner to postgres;

create function pg_catalog.timestamptz_smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_smaller() is 'smaller of two';

alter function pg_catalog.timestamptz_smaller() owner to postgres;

create function pg_catalog.timestamptz_larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_larger() is 'larger of two';

alter function pg_catalog.timestamptz_larger() owner to postgres;

create function pg_catalog.interval_smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_smaller() is 'smaller of two';

alter function pg_catalog.interval_smaller() owner to postgres;

create function pg_catalog.interval_larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_larger() is 'larger of two';

alter function pg_catalog.interval_larger() owner to postgres;

create function pg_catalog.interval()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval() is 'adjust interval precision';

alter function pg_catalog.interval() owner to postgres;

create function pg_catalog.obj_description(oid, name) returns text
    stable
    strict
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.obj_description() is 'get description for object id and catalog name';

alter function pg_catalog.obj_description() owner to postgres;

create function pg_catalog.col_description(oid, integer) returns text
    stable
    strict
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.col_description() is 'get description for table column';

alter function pg_catalog.col_description() owner to postgres;

create function pg_catalog.date_trunc(timestamp with time zone) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(timestamp with time zone) is 'truncate timestamp with time zone to specified units';

alter function pg_catalog.date_trunc(timestamp with time zone) owner to postgres;

create function pg_catalog.date_trunc(interval) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(interval) is 'truncate interval to specified units';

alter function pg_catalog.date_trunc(interval) owner to postgres;

create function pg_catalog.int8inc()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8inc() is 'increment';

alter function pg_catalog.int8inc() owner to postgres;

create function pg_catalog.int8abs()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8abs() is 'implementation of @ operator';

alter function pg_catalog.int8abs() owner to postgres;

create function pg_catalog.int8larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8larger() is 'larger of two';

alter function pg_catalog.int8larger() owner to postgres;

create function pg_catalog.int8smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8smaller() is 'smaller of two';

alter function pg_catalog.int8smaller() owner to postgres;

create function pg_catalog.texticregexeq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticregexeq() is 'implementation of ~* operator';

alter function pg_catalog.texticregexeq() owner to postgres;

create function pg_catalog.texticregexne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticregexne() is 'implementation of !~* operator';

alter function pg_catalog.texticregexne() owner to postgres;

create function pg_catalog.nameicregexeq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameicregexeq() is 'implementation of ~* operator';

alter function pg_catalog.nameicregexeq() owner to postgres;

create function pg_catalog.nameicregexne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameicregexne() is 'implementation of !~* operator';

alter function pg_catalog.nameicregexne() owner to postgres;

create function pg_catalog.boolin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolin() is 'I/O';

alter function pg_catalog.boolin() owner to postgres;

create function pg_catalog.boolout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolout() is 'I/O';

alter function pg_catalog.boolout() owner to postgres;

create function pg_catalog.byteain()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteain() is 'I/O';

alter function pg_catalog.byteain() owner to postgres;

create function pg_catalog.charin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charin() is 'I/O';

alter function pg_catalog.charin() owner to postgres;

create function pg_catalog.charlt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charlt() is 'implementation of < operator';

alter function pg_catalog.charlt() owner to postgres;

create function pg_catalog.unique_key_recheck()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unique_key_recheck() is 'deferred UNIQUE constraint check';

alter function pg_catalog.unique_key_recheck() owner to postgres;

create function pg_catalog.int4abs()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4abs() is 'implementation of @ operator';

alter function pg_catalog.int4abs() owner to postgres;

create function pg_catalog.nameregexne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameregexne() is 'implementation of !~ operator';

alter function pg_catalog.nameregexne() owner to postgres;

create function pg_catalog.int2abs()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2abs() is 'implementation of @ operator';

alter function pg_catalog.int2abs() owner to postgres;

create function pg_catalog.textregexeq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textregexeq() is 'implementation of ~ operator';

alter function pg_catalog.textregexeq() owner to postgres;

create function pg_catalog.textregexne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textregexne() is 'implementation of !~ operator';

alter function pg_catalog.textregexne() owner to postgres;

create function pg_catalog.textlen()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlen() is 'length';

alter function pg_catalog.textlen() owner to postgres;

create function pg_catalog.textcat()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textcat() is 'implementation of || operator';

alter function pg_catalog.textcat() owner to postgres;

create function pg_catalog.pg_char_to_encoding()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_char_to_encoding() is 'convert encoding name to encoding id';

alter function pg_catalog.pg_char_to_encoding() owner to postgres;

create function pg_catalog.tidne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidne() is 'implementation of <> operator';

alter function pg_catalog.tidne() owner to postgres;

create function pg_catalog.cidr_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_in() is 'I/O';

alter function pg_catalog.cidr_in() owner to postgres;

create function pg_catalog.parse_ident()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.parse_ident() is 'parse qualified identifier to array of identifiers';

alter function pg_catalog.parse_ident() owner to postgres;

create function pg_catalog.pg_column_size()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_column_size() is 'bytes required to store the value, perhaps with compression';

alter function pg_catalog.pg_column_size() owner to postgres;

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(time with time zone, time with time zone, time with time zone, time with time zone) is 'intervals overlap?';

alter function pg_catalog."overlaps"(time with time zone, time with time zone, time with time zone, time with time zone) owner to postgres;

create function pg_catalog.datetime_pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.datetime_pl() is 'implementation of + operator';

alter function pg_catalog.datetime_pl() owner to postgres;

create function pg_catalog.date_part(time with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(time with time zone) is 'extract field from time with time zone';

alter function pg_catalog.date_part(time with time zone) owner to postgres;

create function pg_catalog.int84pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84pl() is 'implementation of + operator';

alter function pg_catalog.int84pl() owner to postgres;

create function pg_catalog.int84mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84mi() is 'implementation of - operator';

alter function pg_catalog.int84mi() owner to postgres;

create function pg_catalog.int84mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84mul() is 'implementation of * operator';

alter function pg_catalog.int84mul() owner to postgres;

create function pg_catalog.int84div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84div() is 'implementation of / operator';

alter function pg_catalog.int84div() owner to postgres;

create function pg_catalog.int48pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48pl() is 'implementation of + operator';

alter function pg_catalog.int48pl() owner to postgres;

create function pg_catalog.int48mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48mi() is 'implementation of - operator';

alter function pg_catalog.int48mi() owner to postgres;

create function pg_catalog.int48mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48mul() is 'implementation of * operator';

alter function pg_catalog.int48mul() owner to postgres;

create function pg_catalog.int48div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48div() is 'implementation of / operator';

alter function pg_catalog.int48div() owner to postgres;

create function pg_catalog.quote_ident()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_ident() is 'quote an identifier for usage in a querystring';

alter function pg_catalog.quote_ident() owner to postgres;

create function pg_catalog.quote_literal()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_literal() is 'quote a literal for usage in a querystring';

alter function pg_catalog.quote_literal() owner to postgres;

create function pg_catalog.date_trunc(timestamp with time zone, text) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(timestamp with time zone, text) is 'truncate timestamp with time zone to specified units in specified time zone';

alter function pg_catalog.date_trunc(timestamp with time zone, text) owner to postgres;

create function pg_catalog.quote_literal(anyelement) returns text
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_literal() is 'quote a data value for usage in a querystring';

alter function pg_catalog.quote_literal() owner to postgres;

create function pg_catalog.array_fill()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_fill() is 'array constructor with value';

alter function pg_catalog.array_fill() owner to postgres;

create function pg_catalog.oid()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oid() is 'convert int8 to oid';

alter function pg_catalog.oid() owner to postgres;

create function pg_catalog.int8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8() is 'convert oid to int8';

alter function pg_catalog.int8() owner to postgres;

create function pg_catalog.quote_nullable()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_nullable() is 'quote a possibly-null literal for usage in a querystring';

alter function pg_catalog.quote_nullable() owner to postgres;

create function pg_catalog.quote_nullable(anyelement) returns text
    stable
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_nullable() is 'quote a possibly-null data value for usage in a querystring';

alter function pg_catalog.quote_nullable() owner to postgres;

create function pg_catalog.suppress_redundant_updates_trigger()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.suppress_redundant_updates_trigger() is 'trigger to suppress updates when new and old records match';

alter function pg_catalog.suppress_redundant_updates_trigger() owner to postgres;

create function pg_catalog.tideq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tideq() is 'implementation of = operator';

alter function pg_catalog.tideq() owner to postgres;

create function pg_catalog.currtid()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.currtid() is 'latest tid of a tuple';

alter function pg_catalog.currtid() owner to postgres;

create function pg_catalog.currtid2()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.currtid2() is 'latest tid of a tuple';

alter function pg_catalog.currtid2() owner to postgres;

create function pg_catalog.justify_days()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.justify_days() is 'promote groups of 30 days to numbers of months';

alter function pg_catalog.justify_days() owner to postgres;

create function pg_catalog.timedate_pl(time without time zone, date) returns timestamp without time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.timedate_pl() is 'implementation of + operator';

alter function pg_catalog.timedate_pl() owner to postgres;

create function pg_catalog.datetimetz_pl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.datetimetz_pl() is 'implementation of + operator';

alter function pg_catalog.datetimetz_pl() owner to postgres;

create function pg_catalog.timetzdate_pl(time with time zone, date) returns timestamp with time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetzdate_pl() is 'implementation of + operator';

alter function pg_catalog.timetzdate_pl() owner to postgres;

create function pg_catalog.now()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.now() is 'current transaction time';

alter function pg_catalog.now() owner to postgres;

create function pg_catalog.positionsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.positionsel() is 'restriction selectivity for position-comparison operators';

alter function pg_catalog.positionsel() owner to postgres;

create function pg_catalog.positionjoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.positionjoinsel() is 'join selectivity for position-comparison operators';

alter function pg_catalog.positionjoinsel() owner to postgres;

create function pg_catalog.contsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.contsel() is 'restriction selectivity for containment comparison operators';

alter function pg_catalog.contsel() owner to postgres;

create function pg_catalog.contjoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.contjoinsel() is 'join selectivity for containment comparison operators';

alter function pg_catalog.contjoinsel() owner to postgres;

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, time without time zone) returns boolean
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval) returns boolean
    stable
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone) owner to postgres;

create function pg_catalog."overlaps"(timestamp without time zone, timestamp without time zone, timestamp without time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(time, time, time, time) is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, time, time, time) owner to postgres;

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
as
$$select ($1, ($1 + $2)) overlaps ($3, ($3 + $4))$$;

comment on function pg_catalog."overlaps"(time, interval, time, interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, interval, time, interval) owner to postgres;

create function pg_catalog."overlaps"(time without time zone, time without time zone, time without time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(interval) owner to postgres;

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, time without time zone) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
as
$$select ($1, ($1 + $2)) overlaps ($3, $4)$$;

comment on function pg_catalog."overlaps"(time, interval, time, time) is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, interval, time, time) owner to postgres;

create function pg_catalog.timestamp_in()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_in() is 'I/O';

alter function pg_catalog.timestamp_in() owner to postgres;

create function pg_catalog.timestamp_out()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_out() is 'I/O';

alter function pg_catalog.timestamp_out() owner to postgres;

create function pg_catalog.timestamptz_cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_cmp() is 'less-equal-greater';

alter function pg_catalog.timestamptz_cmp() owner to postgres;

create function pg_catalog.interval_cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_cmp() is 'less-equal-greater';

alter function pg_catalog.interval_cmp() owner to postgres;

create function pg_catalog.time(timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(timestamp) is 'convert timestamp to time';

alter function pg_catalog.time(timestamp) owner to postgres;

create function pg_catalog.length(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(text) is 'length';

alter function pg_catalog.length(text) owner to postgres;

create function pg_catalog.length()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length() is 'character length';

alter function pg_catalog.length() owner to postgres;

create function pg_catalog.xideqint4()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xideqint4() is 'implementation of = operator';

alter function pg_catalog.xideqint4() owner to postgres;

create function pg_catalog.interval_div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_div() is 'implementation of / operator';

alter function pg_catalog.interval_div() owner to postgres;

create function pg_catalog.dlog10()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dlog10() is 'base 10 logarithm';

alter function pg_catalog.dlog10() owner to postgres;

create function pg_catalog.log()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.log() is 'base 10 logarithm';

alter function pg_catalog.log() owner to postgres;

create function pg_catalog.ln()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ln() is 'natural logarithm';

alter function pg_catalog.ln() owner to postgres;

create function pg_catalog.round()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.round() is 'round to nearest integer';

alter function pg_catalog.round() owner to postgres;

create function pg_catalog.trunc()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc() is 'truncate to integer';

alter function pg_catalog.trunc() owner to postgres;

create function pg_catalog.sqrt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sqrt() is 'square root';

alter function pg_catalog.sqrt() owner to postgres;

create function pg_catalog.cbrt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cbrt() is 'cube root';

alter function pg_catalog.cbrt() owner to postgres;

create function pg_catalog.pow()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pow() is 'exponentiation';

alter function pg_catalog.pow() owner to postgres;

create function pg_catalog.exp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.exp() is 'natural exponential (e^x)';

alter function pg_catalog.exp() owner to postgres;

create function pg_catalog.obj_description(oid) returns text
    stable
    strict
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.obj_description() is 'deprecated, use two-argument form instead';

alter function pg_catalog.obj_description() owner to postgres;

create function pg_catalog.oidvectortypes()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectortypes() is 'print type names of oidvector field';

alter function pg_catalog.oidvectortypes() owner to postgres;

create function pg_catalog.timetz_in()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_in() is 'I/O';

alter function pg_catalog.timetz_in() owner to postgres;

create function pg_catalog.timetz_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_out() is 'I/O';

alter function pg_catalog.timetz_out() owner to postgres;

create function pg_catalog.timetz_eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_eq() is 'implementation of = operator';

alter function pg_catalog.timetz_eq() owner to postgres;

create function pg_catalog.timetz_ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_ne() is 'implementation of <> operator';

alter function pg_catalog.timetz_ne() owner to postgres;

create function pg_catalog.timetz_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_lt() is 'implementation of < operator';

alter function pg_catalog.timetz_lt() owner to postgres;

create function pg_catalog.timetz_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_le() is 'implementation of <= operator';

alter function pg_catalog.timetz_le() owner to postgres;

create function pg_catalog.timetz_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_ge() is 'implementation of >= operator';

alter function pg_catalog.timetz_ge() owner to postgres;

create function pg_catalog.timetz_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_gt() is 'implementation of > operator';

alter function pg_catalog.timetz_gt() owner to postgres;

create function pg_catalog.timetz_cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_cmp() is 'less-equal-greater';

alter function pg_catalog.timetz_cmp() owner to postgres;

create function pg_catalog.timestamptz()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz() is 'convert date and time with time zone to timestamp with time zone';

alter function pg_catalog.timestamptz() owner to postgres;

create function pg_catalog.hostmask()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hostmask() is 'hostmask of address';

alter function pg_catalog.hostmask() owner to postgres;

create function pg_catalog.textregexeq_support()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textregexeq_support() is 'planner support for textregexeq';

alter function pg_catalog.textregexeq_support() owner to postgres;

create function pg_catalog.makeaclitem()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.makeaclitem() is 'make ACL item';

alter function pg_catalog.makeaclitem() owner to postgres;

create function pg_catalog.character_length()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.character_length() is 'character length';

alter function pg_catalog.character_length() owner to postgres;

create function pg_catalog.power()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.power() is 'exponentiation';

alter function pg_catalog.power() owner to postgres;

create function pg_catalog.character_length()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.character_length() is 'character length';

alter function pg_catalog.character_length() owner to postgres;

create function pg_catalog.interval()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval() is 'convert time to interval';

alter function pg_catalog.interval() owner to postgres;

create function pg_catalog.pg_lock_status()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lock_status() is 'view system lock information';

alter function pg_catalog.pg_lock_status() owner to postgres;

create function pg_catalog.char_length()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char_length() is 'character length';

alter function pg_catalog.char_length() owner to postgres;

create function pg_catalog.isfinite()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite() is 'finite date?';

alter function pg_catalog.isfinite() owner to postgres;

create function pg_catalog.octet_length(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(text) is 'octet length';

alter function pg_catalog.octet_length(text) owner to postgres;

create function pg_catalog.octet_length()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length() is 'octet length';

alter function pg_catalog.octet_length() owner to postgres;

create function pg_catalog.factorial()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.factorial() is 'factorial';

alter function pg_catalog.factorial() owner to postgres;

create function pg_catalog.time_larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_larger() is 'larger of two';

alter function pg_catalog.time_larger() owner to postgres;

create function pg_catalog.time_smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_smaller() is 'smaller of two';

alter function pg_catalog.time_smaller() owner to postgres;

create function pg_catalog.timetz_larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_larger() is 'larger of two';

alter function pg_catalog.timetz_larger() owner to postgres;

create function pg_catalog.timetz_smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_smaller() is 'smaller of two';

alter function pg_catalog.timetz_smaller() owner to postgres;

create function pg_catalog.char_length()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char_length() is 'character length';

alter function pg_catalog.char_length() owner to postgres;

create function pg_catalog.date_part(text, date) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(date) is 'extract field from date';

alter function pg_catalog.date_part(date) owner to postgres;

create function pg_catalog.date_part(time)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(time) is 'extract field from time';

alter function pg_catalog.date_part(time) owner to postgres;

create function pg_catalog.pg_get_constraintdef()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_constraintdef() is 'constraint description';

alter function pg_catalog.pg_get_constraintdef() owner to postgres;

create function pg_catalog.timetz(timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz(timestamp with time zone) is 'convert timestamp with time zone to time with time zone';

alter function pg_catalog.timetz(timestamp with time zone) owner to postgres;

create function pg_catalog.isfinite(timestamp with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite(timestamp with time zone) is 'finite timestamp?';

alter function pg_catalog.isfinite(timestamp with time zone) owner to postgres;

create function pg_catalog.isfinite(interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite(interval) is 'finite interval?';

alter function pg_catalog.isfinite(interval) owner to postgres;

create function pg_catalog.pg_stat_get_backend_start()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_start() is 'statistics: start time for current backend session';

alter function pg_catalog.pg_stat_get_backend_start() owner to postgres;

create function pg_catalog.pg_stat_get_backend_client_addr()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_client_addr() is 'statistics: address of client connected to backend';

alter function pg_catalog.pg_stat_get_backend_client_addr() owner to postgres;

create function pg_catalog.pg_stat_get_backend_client_port()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_client_port() is 'statistics: port number of client connected to backend';

alter function pg_catalog.pg_stat_get_backend_client_port() owner to postgres;

create function pg_catalog.abs(real) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(real) is 'absolute value';

alter function pg_catalog.abs(real) owner to postgres;

create function pg_catalog.abs()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs() is 'absolute value';

alter function pg_catalog.abs() owner to postgres;

create function pg_catalog.abs(bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(bigint) is 'absolute value';

alter function pg_catalog.abs(bigint) owner to postgres;

create function pg_catalog.abs(integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(integer) is 'absolute value';

alter function pg_catalog.abs(integer) owner to postgres;

create function pg_catalog.abs(smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(smallint) is 'absolute value';

alter function pg_catalog.abs(smallint) owner to postgres;

create function pg_catalog.name()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.name() is 'convert varchar to name';

alter function pg_catalog.name() owner to postgres;

create function pg_catalog.varchar()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchar() is 'convert name to varchar';

alter function pg_catalog.varchar() owner to postgres;

create function pg_catalog."current_schema"()
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."current_schema"() is 'current schema name';

alter function pg_catalog."current_schema"() owner to postgres;

create function pg_catalog.current_schemas()
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_schemas() is 'current schema search list';

alter function pg_catalog.current_schemas() owner to postgres;

create function pg_catalog.overlay(text, text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(text, text, integer) is 'substitute portion of string';

alter function pg_catalog.overlay(text, text, integer) owner to postgres;

create function pg_catalog.overlay(text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(text, text) is 'substitute portion of string';

alter function pg_catalog.overlay(text, text) owner to postgres;

create function pg_catalog.isvertical(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isvertical(point, point) is 'vertically aligned';

alter function pg_catalog.isvertical(point, point) owner to postgres;

create function pg_catalog.ishorizontal(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ishorizontal(point, point) is 'horizontally aligned';

alter function pg_catalog.ishorizontal(point, point) owner to postgres;

create function pg_catalog.isparallel(lseg, lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isparallel(lseg, lseg) is 'parallel';

alter function pg_catalog.isparallel(lseg, lseg) owner to postgres;

create function pg_catalog.isperp(lseg, lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isperp(lseg, lseg) is 'perpendicular';

alter function pg_catalog.isperp(lseg, lseg) owner to postgres;

create function pg_catalog.isvertical()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isvertical() is 'vertical';

alter function pg_catalog.isvertical() owner to postgres;

create function pg_catalog.ishorizontal()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ishorizontal() is 'horizontal';

alter function pg_catalog.ishorizontal() owner to postgres;

create function pg_catalog.isparallel(line, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isparallel(line, line) is 'parallel';

alter function pg_catalog.isparallel(line, line) owner to postgres;

create function pg_catalog.isperp(line, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isperp(line, line) is 'perpendicular';

alter function pg_catalog.isperp(line, line) owner to postgres;

create function pg_catalog.isvertical(line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isvertical(line) is 'vertical';

alter function pg_catalog.isvertical(line) owner to postgres;

create function pg_catalog.ishorizontal(line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ishorizontal(line) is 'horizontal';

alter function pg_catalog.ishorizontal(line) owner to postgres;

create function pg_catalog.point(circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(circle) is 'center of';

alter function pg_catalog.point(circle) owner to postgres;

create function pg_catalog.time()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time() is 'convert interval to time';

alter function pg_catalog.time() owner to postgres;

create function pg_catalog.box(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(point, point) is 'convert points to box';

alter function pg_catalog.box(point, point) owner to postgres;

create function pg_catalog.box_add()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_add() is 'implementation of + operator';

alter function pg_catalog.box_add() owner to postgres;

create function pg_catalog.box_sub()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_sub() is 'implementation of - operator';

alter function pg_catalog.box_sub() owner to postgres;

create function pg_catalog.box_mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_mul() is 'implementation of * operator';

alter function pg_catalog.box_mul() owner to postgres;

create function pg_catalog.box_div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_div() is 'implementation of / operator';

alter function pg_catalog.box_div() owner to postgres;

create function pg_catalog.path_contain_pt(path, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_contain_pt() is 'implementation of @> operator';

alter function pg_catalog.path_contain_pt() owner to postgres;

create function pg_catalog.cidr_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_out() is 'I/O';

alter function pg_catalog.cidr_out() owner to postgres;

create function pg_catalog.poly_contain_pt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_contain_pt() is 'implementation of @> operator';

alter function pg_catalog.poly_contain_pt() owner to postgres;

create function pg_catalog.pt_contained_poly()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pt_contained_poly() is 'implementation of <@ operator';

alter function pg_catalog.pt_contained_poly() owner to postgres;

create function pg_catalog.isclosed()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isclosed() is 'path closed?';

alter function pg_catalog.isclosed() owner to postgres;

create function pg_catalog.isopen()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isopen() is 'path open?';

alter function pg_catalog.isopen() owner to postgres;

create function pg_catalog.path_npoints()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_npoints() is 'implementation of # operator';

alter function pg_catalog.path_npoints() owner to postgres;

create function pg_catalog.pclose()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pclose() is 'close path';

alter function pg_catalog.pclose() owner to postgres;

create function pg_catalog.popen()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.popen() is 'open path';

alter function pg_catalog.popen() owner to postgres;

create function pg_catalog.path_add()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_add() is 'implementation of + operator';

alter function pg_catalog.path_add() owner to postgres;

create function pg_catalog.path_add_pt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_add_pt() is 'implementation of + operator';

alter function pg_catalog.path_add_pt() owner to postgres;

create function pg_catalog.path_sub_pt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_sub_pt() is 'implementation of - operator';

alter function pg_catalog.path_sub_pt() owner to postgres;

create function pg_catalog.path_mul_pt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_mul_pt() is 'implementation of * operator';

alter function pg_catalog.path_mul_pt() owner to postgres;

create function pg_catalog.path_div_pt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_div_pt() is 'implementation of / operator';

alter function pg_catalog.path_div_pt() owner to postgres;

create function pg_catalog.point(double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(double precision, double precision) is 'convert x, y to point';

alter function pg_catalog.point(double precision, double precision) owner to postgres;

create function pg_catalog.point_add()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_add() is 'implementation of + operator';

alter function pg_catalog.point_add() owner to postgres;

create function pg_catalog.point_sub()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_sub() is 'implementation of - operator';

alter function pg_catalog.point_sub() owner to postgres;

create function pg_catalog.point_mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_mul() is 'implementation of * operator';

alter function pg_catalog.point_mul() owner to postgres;

create function pg_catalog.point_div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_div() is 'implementation of / operator';

alter function pg_catalog.point_div() owner to postgres;

create function pg_catalog.poly_npoints()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_npoints() is 'implementation of # operator';

alter function pg_catalog.poly_npoints() owner to postgres;

create function pg_catalog.box(polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(polygon) is 'convert polygon to bounding box';

alter function pg_catalog.box(polygon) owner to postgres;

create function pg_catalog.path()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path() is 'convert polygon to path';

alter function pg_catalog.path() owner to postgres;

create function pg_catalog.polygon()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon() is 'convert box to polygon';

alter function pg_catalog.polygon() owner to postgres;

create function pg_catalog.polygon(circle) returns polygon
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon(path) is 'convert path to polygon';

alter function pg_catalog.polygon(path) owner to postgres;

create function pg_catalog.circle_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_in() is 'I/O';

alter function pg_catalog.circle_in() owner to postgres;

create function pg_catalog.circle_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_out() is 'I/O';

alter function pg_catalog.circle_out() owner to postgres;

create function pg_catalog.circle_same()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_same() is 'implementation of ~= operator';

alter function pg_catalog.circle_same() owner to postgres;

create function pg_catalog.circle_contain()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_contain() is 'implementation of @> operator';

alter function pg_catalog.circle_contain() owner to postgres;

create function pg_catalog.circle_left()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_left() is 'implementation of << operator';

alter function pg_catalog.circle_left() owner to postgres;

create function pg_catalog.circle_overleft()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overleft() is 'implementation of &< operator';

alter function pg_catalog.circle_overleft() owner to postgres;

create function pg_catalog.circle_overright()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overright() is 'implementation of &> operator';

alter function pg_catalog.circle_overright() owner to postgres;

create function pg_catalog.circle_right()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_right() is 'implementation of >> operator';

alter function pg_catalog.circle_right() owner to postgres;

create function pg_catalog.circle_contained()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_contained() is 'implementation of <@ operator';

alter function pg_catalog.circle_contained() owner to postgres;

create function pg_catalog.circle_overlap()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overlap() is 'implementation of && operator';

alter function pg_catalog.circle_overlap() owner to postgres;

create function pg_catalog.circle_below()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_below() is 'implementation of <<| operator';

alter function pg_catalog.circle_below() owner to postgres;

create function pg_catalog.circle_above()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_above() is 'implementation of |>> operator';

alter function pg_catalog.circle_above() owner to postgres;

create function pg_catalog.circle_eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_eq() is 'implementation of = operator';

alter function pg_catalog.circle_eq() owner to postgres;

create function pg_catalog.circle_ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_ne() is 'implementation of <> operator';

alter function pg_catalog.circle_ne() owner to postgres;

create function pg_catalog.circle_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_lt() is 'implementation of < operator';

alter function pg_catalog.circle_lt() owner to postgres;

create function pg_catalog.circle_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_gt() is 'implementation of > operator';

alter function pg_catalog.circle_gt() owner to postgres;

create function pg_catalog.circle_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_le() is 'implementation of <= operator';

alter function pg_catalog.circle_le() owner to postgres;

create function pg_catalog.circle_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_ge() is 'implementation of >= operator';

alter function pg_catalog.circle_ge() owner to postgres;

create function pg_catalog.area(circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.area(circle) is 'area of circle';

alter function pg_catalog.area(circle) owner to postgres;

create function pg_catalog.diameter()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.diameter() is 'diameter of circle';

alter function pg_catalog.diameter() owner to postgres;

create function pg_catalog.radius()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.radius() is 'radius of circle';

alter function pg_catalog.radius() owner to postgres;

create function pg_catalog.circle_distance()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_distance() is 'implementation of <-> operator';

alter function pg_catalog.circle_distance() owner to postgres;

create function pg_catalog.circle_center()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_center() is 'implementation of @@ operator';

alter function pg_catalog.circle_center() owner to postgres;

create function pg_catalog.circle(point, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle(point, double precision) is 'convert point and radius to circle';

alter function pg_catalog.circle(point, double precision) owner to postgres;

create function pg_catalog.circle(polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle(polygon) is 'convert polygon to circle';

alter function pg_catalog.circle(polygon) owner to postgres;

create function pg_catalog.polygon(integer, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon(integer, circle) is 'convert vertex count and circle to polygon';

alter function pg_catalog.polygon(integer, circle) owner to postgres;

create function pg_catalog.dist_pc()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pc() is 'implementation of <-> operator';

alter function pg_catalog.dist_pc() owner to postgres;

create function pg_catalog.circle_contain_pt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_contain_pt() is 'implementation of @> operator';

alter function pg_catalog.circle_contain_pt() owner to postgres;

create function pg_catalog.pt_contained_circle()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pt_contained_circle() is 'implementation of <@ operator';

alter function pg_catalog.pt_contained_circle() owner to postgres;

create function pg_catalog.circle(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle(box) is 'convert box to circle';

alter function pg_catalog.circle(box) owner to postgres;

create function pg_catalog.box(circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(circle) is 'convert circle to box';

alter function pg_catalog.box(circle) owner to postgres;

create function pg_catalog.log10(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$select pg_catalog.log(10, $1)$$;

comment on function pg_catalog.log10(numeric) is 'base 10 logarithm';

alter function pg_catalog.log10(numeric) owner to postgres;

create function pg_catalog.lseg_ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_ne() is 'implementation of <> operator';

alter function pg_catalog.lseg_ne() owner to postgres;

create function pg_catalog.lseg_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_lt() is 'implementation of < operator';

alter function pg_catalog.lseg_lt() owner to postgres;

create function pg_catalog.lseg_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_le() is 'implementation of <= operator';

alter function pg_catalog.lseg_le() owner to postgres;

create function pg_catalog.lseg_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_gt() is 'implementation of > operator';

alter function pg_catalog.lseg_gt() owner to postgres;

create function pg_catalog.lseg_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_ge() is 'implementation of >= operator';

alter function pg_catalog.lseg_ge() owner to postgres;

create function pg_catalog.lseg_length()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_length() is 'implementation of @-@ operator';

alter function pg_catalog.lseg_length() owner to postgres;

create function pg_catalog.close_ls()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_ls() is 'implementation of ## operator';

alter function pg_catalog.close_ls() owner to postgres;

create function pg_catalog.close_lseg()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_lseg() is 'implementation of ## operator';

alter function pg_catalog.close_lseg() owner to postgres;

create function pg_catalog.line_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_in() is 'I/O';

alter function pg_catalog.line_in() owner to postgres;

create function pg_catalog.line_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_out() is 'I/O';

alter function pg_catalog.line_out() owner to postgres;

create function pg_catalog.line_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_eq() is 'implementation of = operator';

alter function pg_catalog.line_eq() owner to postgres;

create function pg_catalog.line()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line() is 'construct line from points';

alter function pg_catalog.line() owner to postgres;

create function pg_catalog.line_interpt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_interpt() is 'implementation of # operator';

alter function pg_catalog.line_interpt() owner to postgres;

create function pg_catalog.line_intersect()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_intersect() is 'implementation of ?# operator';

alter function pg_catalog.line_intersect() owner to postgres;

create function pg_catalog.line_parallel()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_parallel() is 'implementation of ?|| operator';

alter function pg_catalog.line_parallel() owner to postgres;

create function pg_catalog.line_perp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_perp() is 'implementation of ?-| operator';

alter function pg_catalog.line_perp() owner to postgres;

create function pg_catalog.line_vertical()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_vertical() is 'implementation of ?| operator';

alter function pg_catalog.line_vertical() owner to postgres;

create function pg_catalog.line_horizontal()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_horizontal() is 'implementation of ?- operator';

alter function pg_catalog.line_horizontal() owner to postgres;

create function pg_catalog.length()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length() is 'distance between endpoints';

alter function pg_catalog.length() owner to postgres;

create function pg_catalog.length(path) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(path) is 'sum of path segments';

alter function pg_catalog.length(path) owner to postgres;

create function pg_catalog.point()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point() is 'center of';

alter function pg_catalog.point() owner to postgres;

create function pg_catalog.point()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point() is 'center of';

alter function pg_catalog.point() owner to postgres;

create function pg_catalog.point(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(box) is 'center of';

alter function pg_catalog.point(box) owner to postgres;

create function pg_catalog.point(polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(polygon) is 'center of';

alter function pg_catalog.point(polygon) owner to postgres;

create function pg_catalog.lseg()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg() is 'diagonal of';

alter function pg_catalog.lseg() owner to postgres;

create function pg_catalog.center()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.center() is 'center of';

alter function pg_catalog.center() owner to postgres;

create function pg_catalog.center()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.center() is 'center of';

alter function pg_catalog.center() owner to postgres;

create function pg_catalog.polygon(circle) returns polygon
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon(circle) is 'convert circle to 12-vertex polygon';

alter function pg_catalog.polygon(circle) owner to postgres;

create function pg_catalog.npoints()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.npoints() is 'number of points';

alter function pg_catalog.npoints() owner to postgres;

create function pg_catalog.npoints()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.npoints() is 'number of points';

alter function pg_catalog.npoints() owner to postgres;

create function pg_catalog.bit_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_in() is 'I/O';

alter function pg_catalog.bit_in() owner to postgres;

create function pg_catalog.bit_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_out() is 'I/O';

alter function pg_catalog.bit_out() owner to postgres;

create function pg_catalog."like"(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."like"(text, text) is 'matches LIKE expression';

alter function pg_catalog."like"(text, text) owner to postgres;

create function pg_catalog.notlike(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.notlike(text, text) is 'does not match LIKE expression';

alter function pg_catalog.notlike(text, text) owner to postgres;

create function pg_catalog."like"()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."like"() is 'matches LIKE expression';

alter function pg_catalog."like"() owner to postgres;

create function pg_catalog.notlike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.notlike() is 'does not match LIKE expression';

alter function pg_catalog.notlike() owner to postgres;

create function pg_catalog.pg_get_ruledef()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_ruledef() is 'source text of a rule';

alter function pg_catalog.pg_get_ruledef() owner to postgres;

create function pg_catalog.nextval()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nextval() is 'sequence next value';

alter function pg_catalog.nextval() owner to postgres;

create function pg_catalog.currval()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.currval() is 'sequence current value';

alter function pg_catalog.currval() owner to postgres;

create function pg_catalog.setval()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setval() is 'set sequence value';

alter function pg_catalog.setval() owner to postgres;

create function pg_catalog.varbit_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_in() is 'I/O';

alter function pg_catalog.varbit_in() owner to postgres;

create function pg_catalog.varbit_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_out() is 'I/O';

alter function pg_catalog.varbit_out() owner to postgres;

create function pg_catalog.biteq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.biteq() is 'implementation of = operator';

alter function pg_catalog.biteq() owner to postgres;

create function pg_catalog.bitne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitne() is 'implementation of <> operator';

alter function pg_catalog.bitne() owner to postgres;

create function pg_catalog.bitge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitge() is 'implementation of >= operator';

alter function pg_catalog.bitge() owner to postgres;

create function pg_catalog.bitgt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitgt() is 'implementation of > operator';

alter function pg_catalog.bitgt() owner to postgres;

create function pg_catalog.bitle()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitle() is 'implementation of <= operator';

alter function pg_catalog.bitle() owner to postgres;

create function pg_catalog.bitlt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitlt() is 'implementation of < operator';

alter function pg_catalog.bitlt() owner to postgres;

create function pg_catalog.bitcmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitcmp() is 'less-equal-greater';

alter function pg_catalog.bitcmp() owner to postgres;

create function pg_catalog.pg_encoding_to_char()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_encoding_to_char() is 'convert encoding id to encoding name';

alter function pg_catalog.pg_encoding_to_char() owner to postgres;

create function pg_catalog.random()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.random() is 'random value';

alter function pg_catalog.random() owner to postgres;

create function pg_catalog.setseed()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setseed() is 'set random seed';

alter function pg_catalog.setseed() owner to postgres;

create function pg_catalog.asin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.asin() is 'arcsine';

alter function pg_catalog.asin() owner to postgres;

create function pg_catalog.acos()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acos() is 'arccosine';

alter function pg_catalog.acos() owner to postgres;

create function pg_catalog.atan()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atan() is 'arctangent';

alter function pg_catalog.atan() owner to postgres;

create function pg_catalog.atan2()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atan2() is 'arctangent, two arguments';

alter function pg_catalog.atan2() owner to postgres;

create function pg_catalog.sin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sin() is 'sine';

alter function pg_catalog.sin() owner to postgres;

create function pg_catalog.cos()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cos() is 'cosine';

alter function pg_catalog.cos() owner to postgres;

create function pg_catalog.tan()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tan() is 'tangent';

alter function pg_catalog.tan() owner to postgres;

create function pg_catalog.cot()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cot() is 'cotangent';

alter function pg_catalog.cot() owner to postgres;

create function pg_catalog.degrees()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.degrees() is 'radians to degrees';

alter function pg_catalog.degrees() owner to postgres;

create function pg_catalog.radians()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.radians() is 'degrees to radians';

alter function pg_catalog.radians() owner to postgres;

create function pg_catalog.pi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pi() is 'PI';

alter function pg_catalog.pi() owner to postgres;

create function pg_catalog.interval_mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_mul() is 'implementation of * operator';

alter function pg_catalog.interval_mul() owner to postgres;

create function pg_catalog.pg_typeof()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_typeof() is 'type of the argument';

alter function pg_catalog.pg_typeof() owner to postgres;

create function pg_catalog.ascii()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ascii() is 'convert first char to int4';

alter function pg_catalog.ascii() owner to postgres;

create function pg_catalog.chr()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.chr() is 'convert int4 to char';

alter function pg_catalog.chr() owner to postgres;

create function pg_catalog.repeat()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.repeat() is 'replicate string n times';

alter function pg_catalog.repeat() owner to postgres;

create function pg_catalog.similar_escape()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.similar_escape() is 'convert SQL99 regexp pattern to POSIX style';

alter function pg_catalog.similar_escape() owner to postgres;

create function pg_catalog.mul_d_interval()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mul_d_interval() is 'implementation of * operator';

alter function pg_catalog.mul_d_interval() owner to postgres;

create function pg_catalog.bpcharlike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharlike() is 'implementation of ~~ operator';

alter function pg_catalog.bpcharlike() owner to postgres;

create function pg_catalog.bpcharnlike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharnlike() is 'implementation of !~~ operator';

alter function pg_catalog.bpcharnlike() owner to postgres;

create function pg_catalog.texticlike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticlike() is 'implementation of ~~* operator';

alter function pg_catalog.texticlike() owner to postgres;

create function pg_catalog.texticnlike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticnlike() is 'implementation of !~~* operator';

alter function pg_catalog.texticnlike() owner to postgres;

create function pg_catalog.nameiclike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameiclike() is 'implementation of ~~* operator';

alter function pg_catalog.nameiclike() owner to postgres;

create function pg_catalog.nameicnlike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameicnlike() is 'implementation of !~~* operator';

alter function pg_catalog.nameicnlike() owner to postgres;

create function pg_catalog.like_escape(text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.like_escape(text, text) is 'convert LIKE pattern to use backslash escapes';

alter function pg_catalog.like_escape(text, text) owner to postgres;

create function pg_catalog.oidgt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidgt() is 'implementation of > operator';

alter function pg_catalog.oidgt() owner to postgres;

create function pg_catalog.oidge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidge() is 'implementation of >= operator';

alter function pg_catalog.oidge() owner to postgres;

create function pg_catalog.pg_get_userbyid()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_userbyid() is 'role name by OID (with fallback)';

alter function pg_catalog.pg_get_userbyid() owner to postgres;

create function pg_catalog.pg_get_indexdef()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_indexdef() is 'index description';

alter function pg_catalog.pg_get_indexdef() owner to postgres;

create function pg_catalog."RI_FKey_check_ins"()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_check_ins"() is 'referential integrity FOREIGN KEY ... REFERENCES';

alter function pg_catalog."RI_FKey_check_ins"() owner to postgres;

create function pg_catalog."RI_FKey_check_upd"()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_check_upd"() is 'referential integrity FOREIGN KEY ... REFERENCES';

alter function pg_catalog."RI_FKey_check_upd"() owner to postgres;

create function pg_catalog."RI_FKey_cascade_del"()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_cascade_del"() is 'referential integrity ON DELETE CASCADE';

alter function pg_catalog."RI_FKey_cascade_del"() owner to postgres;

create function pg_catalog."RI_FKey_cascade_upd"()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_cascade_upd"() is 'referential integrity ON UPDATE CASCADE';

alter function pg_catalog."RI_FKey_cascade_upd"() owner to postgres;

create function pg_catalog."RI_FKey_restrict_del"()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_restrict_del"() is 'referential integrity ON DELETE RESTRICT';

alter function pg_catalog."RI_FKey_restrict_del"() owner to postgres;

create function pg_catalog."RI_FKey_restrict_upd"()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_restrict_upd"() is 'referential integrity ON UPDATE RESTRICT';

alter function pg_catalog."RI_FKey_restrict_upd"() owner to postgres;

create function pg_catalog."RI_FKey_setnull_del"()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setnull_del"() is 'referential integrity ON DELETE SET NULL';

alter function pg_catalog."RI_FKey_setnull_del"() owner to postgres;

create function pg_catalog."RI_FKey_setnull_upd"()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setnull_upd"() is 'referential integrity ON UPDATE SET NULL';

alter function pg_catalog."RI_FKey_setnull_upd"() owner to postgres;

create function pg_catalog."RI_FKey_setdefault_del"()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setdefault_del"() is 'referential integrity ON DELETE SET DEFAULT';

alter function pg_catalog."RI_FKey_setdefault_del"() owner to postgres;

create function pg_catalog."RI_FKey_setdefault_upd"()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setdefault_upd"() is 'referential integrity ON UPDATE SET DEFAULT';

alter function pg_catalog."RI_FKey_setdefault_upd"() owner to postgres;

create function pg_catalog."RI_FKey_noaction_del"()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_noaction_del"() is 'referential integrity ON DELETE NO ACTION';

alter function pg_catalog."RI_FKey_noaction_del"() owner to postgres;

create function pg_catalog."RI_FKey_noaction_upd"()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_noaction_upd"() is 'referential integrity ON UPDATE NO ACTION';

alter function pg_catalog."RI_FKey_noaction_upd"() owner to postgres;

create function pg_catalog.bpcharicregexeq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharicregexeq() is 'implementation of ~* operator';

alter function pg_catalog.bpcharicregexeq() owner to postgres;

create function pg_catalog.bpcharicregexne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharicregexne() is 'implementation of !~* operator';

alter function pg_catalog.bpcharicregexne() owner to postgres;

create function pg_catalog.bpcharregexeq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharregexeq() is 'implementation of ~ operator';

alter function pg_catalog.bpcharregexeq() owner to postgres;

create function pg_catalog.bpcharregexne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharregexne() is 'implementation of !~ operator';

alter function pg_catalog.bpcharregexne() owner to postgres;

create function pg_catalog.bpchariclike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchariclike() is 'implementation of ~~* operator';

alter function pg_catalog.bpchariclike() owner to postgres;

create function pg_catalog.bpcharicnlike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharicnlike() is 'implementation of !~~* operator';

alter function pg_catalog.bpcharicnlike() owner to postgres;

create function pg_catalog.pg_get_triggerdef()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_triggerdef() is 'trigger description';

alter function pg_catalog.pg_get_triggerdef() owner to postgres;

create function pg_catalog.pg_get_serial_sequence()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_serial_sequence() is 'name of sequence for a serial column';

alter function pg_catalog.pg_get_serial_sequence() owner to postgres;

create function pg_catalog.varbiteq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbiteq() is 'implementation of = operator';

alter function pg_catalog.varbiteq() owner to postgres;

create function pg_catalog.varbitne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitne() is 'implementation of <> operator';

alter function pg_catalog.varbitne() owner to postgres;

create function pg_catalog.varbitge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitge() is 'implementation of >= operator';

alter function pg_catalog.varbitge() owner to postgres;

create function pg_catalog.varbitgt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitgt() is 'implementation of > operator';

alter function pg_catalog.varbitgt() owner to postgres;

create function pg_catalog.varbitle()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitle() is 'implementation of <= operator';

alter function pg_catalog.varbitle() owner to postgres;

create function pg_catalog.varbitlt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitlt() is 'implementation of < operator';

alter function pg_catalog.varbitlt() owner to postgres;

create function pg_catalog.varbitcmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitcmp() is 'less-equal-greater';

alter function pg_catalog.varbitcmp() owner to postgres;

create function pg_catalog.bitand()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitand() is 'implementation of & operator';

alter function pg_catalog.bitand() owner to postgres;

create function pg_catalog.bitor()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitor() is 'implementation of | operator';

alter function pg_catalog.bitor() owner to postgres;

create function pg_catalog.bitxor()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitxor() is 'implementation of # operator';

alter function pg_catalog.bitxor() owner to postgres;

create function pg_catalog.bitnot()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitnot() is 'implementation of ~ operator';

alter function pg_catalog.bitnot() owner to postgres;

create function pg_catalog.bitshiftleft()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitshiftleft() is 'implementation of << operator';

alter function pg_catalog.bitshiftleft() owner to postgres;

create function pg_catalog.bitshiftright()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitshiftright() is 'implementation of >> operator';

alter function pg_catalog.bitshiftright() owner to postgres;

create function pg_catalog.bitcat()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitcat() is 'implementation of || operator';

alter function pg_catalog.bitcat() owner to postgres;

create function pg_catalog.substring(bit, integer) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(bit, integer) is 'extract portion of bitstring';

alter function pg_catalog.substring(bit, integer) owner to postgres;

create function pg_catalog.length(bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(bit) is 'bitstring length';

alter function pg_catalog.length(bit) owner to postgres;

create function pg_catalog.octet_length(bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(bit) is 'octet length';

alter function pg_catalog.octet_length(bit) owner to postgres;

create function pg_catalog.bit(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit(integer) is 'convert int4 to bitstring';

alter function pg_catalog.bit(integer) owner to postgres;

create function pg_catalog.int4(bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(bit) is 'convert bitstring to int4';

alter function pg_catalog.int4(bit) owner to postgres;

create function pg_catalog.bit(bit, boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit(bit, boolean) is 'adjust bit() to typmod length';

alter function pg_catalog.bit(bit, boolean) owner to postgres;

create function pg_catalog.pg_get_keywords()
    stable
    strict
    parallel safe
    cost 10
    rows 400
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_keywords() is 'list of SQL keywords';

alter function pg_catalog.pg_get_keywords() owner to postgres;

create function pg_catalog.varbit()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit() is 'adjust varbit() to typmod length';

alter function pg_catalog.varbit() owner to postgres;

create function pg_catalog.time_hash()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_hash() is 'hash';

alter function pg_catalog.time_hash() owner to postgres;

create function pg_catalog.aclexplode()
    stable
    strict
    parallel safe
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclexplode() is 'convert ACL item array to table, primarily for use by information schema';

alter function pg_catalog.aclexplode() owner to postgres;

create function pg_catalog.time_mi_time()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_mi_time() is 'implementation of - operator';

alter function pg_catalog.time_mi_time() owner to postgres;

create function pg_catalog.boolle()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolle() is 'implementation of <= operator';

alter function pg_catalog.boolle() owner to postgres;

create function pg_catalog.boolge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolge() is 'implementation of >= operator';

alter function pg_catalog.boolge() owner to postgres;

create function pg_catalog.btboolcmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btboolcmp() is 'less-equal-greater';

alter function pg_catalog.btboolcmp() owner to postgres;

create function pg_catalog.timetz_hash()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_hash() is 'hash';

alter function pg_catalog.timetz_hash() owner to postgres;

create function pg_catalog.interval_hash()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_hash() is 'hash';

alter function pg_catalog.interval_hash() owner to postgres;

create function pg_catalog.position(bit, bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.position(bit, bit) is 'position of sub-bitstring';

alter function pg_catalog.position(bit, bit) owner to postgres;

create function pg_catalog.substring(bit) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(bit) is 'extract portion of bitstring';

alter function pg_catalog.substring(bit) owner to postgres;

create function pg_catalog.numeric_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_in() is 'I/O';

alter function pg_catalog.numeric_in() owner to postgres;

create function pg_catalog.numeric_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_out() is 'I/O';

alter function pg_catalog.numeric_out() owner to postgres;

create function pg_catalog.numeric(numeric, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(numeric, integer) is 'adjust numeric to typmod precision/scale';

alter function pg_catalog.numeric(numeric, integer) owner to postgres;

create function pg_catalog.numeric_abs()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_abs() is 'implementation of @ operator';

alter function pg_catalog.numeric_abs() owner to postgres;

create function pg_catalog.abs(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(numeric) is 'absolute value';

alter function pg_catalog.abs(numeric) owner to postgres;

create function pg_catalog.sign()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sign() is 'sign of value';

alter function pg_catalog.sign() owner to postgres;

create function pg_catalog.round()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.round() is 'value rounded to ''scale''';

alter function pg_catalog.round() owner to postgres;

create function pg_catalog.round(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.round() is 'value rounded to ''scale'' of zero';

alter function pg_catalog.round() owner to postgres;

create function pg_catalog.trunc(numeric, integer) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(numeric, integer) is 'value truncated to ''scale''';

alter function pg_catalog.trunc(numeric, integer) owner to postgres;

create function pg_catalog.trunc(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$select pg_catalog.trunc($1,0)$$;

comment on function pg_catalog.trunc(numeric) is 'value truncated to ''scale'' of zero';

alter function pg_catalog.trunc(numeric) owner to postgres;

create function pg_catalog.ceil()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceil() is 'nearest integer >= value';

alter function pg_catalog.ceil() owner to postgres;

create function pg_catalog.floor()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.floor() is 'nearest integer <= value';

alter function pg_catalog.floor() owner to postgres;

create function pg_catalog.length()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length() is 'length of string in specified encoding';

alter function pg_catalog.length() owner to postgres;

create function pg_catalog.convert_from()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.convert_from() is 'convert string with specified source encoding name';

alter function pg_catalog.convert_from() owner to postgres;

create function pg_catalog.cidr()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr() is 'convert inet to cidr';

alter function pg_catalog.cidr() owner to postgres;

create function pg_catalog.pg_get_expr()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_expr() is 'deparse an encoded expression';

alter function pg_catalog.pg_get_expr() owner to postgres;

create function pg_catalog.convert_to()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.convert_to() is 'convert string with specified destination encoding name';

alter function pg_catalog.convert_to() owner to postgres;

create function pg_catalog.numeric_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_eq() is 'implementation of = operator';

alter function pg_catalog.numeric_eq() owner to postgres;

create function pg_catalog.numeric_ne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_ne() is 'implementation of <> operator';

alter function pg_catalog.numeric_ne() owner to postgres;

create function pg_catalog.numeric_gt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_gt() is 'implementation of > operator';

alter function pg_catalog.numeric_gt() owner to postgres;

create function pg_catalog.numeric_ge()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_ge() is 'implementation of >= operator';

alter function pg_catalog.numeric_ge() owner to postgres;

create function pg_catalog.numeric_lt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_lt() is 'implementation of < operator';

alter function pg_catalog.numeric_lt() owner to postgres;

create function pg_catalog.numeric_le()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_le() is 'implementation of <= operator';

alter function pg_catalog.numeric_le() owner to postgres;

create function pg_catalog.numeric_add()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_add() is 'implementation of + operator';

alter function pg_catalog.numeric_add() owner to postgres;

create function pg_catalog.numeric_sub()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sub() is 'implementation of - operator';

alter function pg_catalog.numeric_sub() owner to postgres;

create function pg_catalog.numeric_mul()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_mul() is 'implementation of * operator';

alter function pg_catalog.numeric_mul() owner to postgres;

create function pg_catalog.numeric_div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_div() is 'implementation of / operator';

alter function pg_catalog.numeric_div() owner to postgres;

create function pg_catalog.mod(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(numeric, numeric) is 'modulus';

alter function pg_catalog.mod(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_mod()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_mod() is 'implementation of % operator';

alter function pg_catalog.numeric_mod() owner to postgres;

create function pg_catalog.sqrt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sqrt() is 'square root';

alter function pg_catalog.sqrt() owner to postgres;

create function pg_catalog.numeric_sqrt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sqrt() is 'square root';

alter function pg_catalog.numeric_sqrt() owner to postgres;

create function pg_catalog.exp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.exp() is 'natural exponential (e^x)';

alter function pg_catalog.exp() owner to postgres;

create function pg_catalog.numeric_exp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_exp() is 'natural exponential (e^x)';

alter function pg_catalog.numeric_exp() owner to postgres;

create function pg_catalog.ln()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ln() is 'natural logarithm';

alter function pg_catalog.ln() owner to postgres;

create function pg_catalog.numeric_ln()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_ln() is 'natural logarithm';

alter function pg_catalog.numeric_ln() owner to postgres;

create function pg_catalog.log()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.log() is 'logarithm base m of n';

alter function pg_catalog.log() owner to postgres;

create function pg_catalog.numeric_log()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_log() is 'logarithm base m of n';

alter function pg_catalog.numeric_log() owner to postgres;

create function pg_catalog.pow()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pow() is 'exponentiation';

alter function pg_catalog.pow() owner to postgres;

create function pg_catalog.numeric_power()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_power() is 'implementation of ^ operator';

alter function pg_catalog.numeric_power() owner to postgres;

create function pg_catalog.numeric(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(integer) is 'convert int4 to numeric';

alter function pg_catalog.numeric(integer) owner to postgres;

create function pg_catalog.log(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.log() is 'base 10 logarithm';

alter function pg_catalog.log() owner to postgres;

create function pg_catalog.numeric(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(real) is 'convert float4 to numeric';

alter function pg_catalog.numeric(real) owner to postgres;

create function pg_catalog.numeric(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(double precision) is 'convert float8 to numeric';

alter function pg_catalog.numeric(double precision) owner to postgres;

create function pg_catalog.int4(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(numeric) is 'convert numeric to int4';

alter function pg_catalog.int4(numeric) owner to postgres;

create function pg_catalog.float4()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4() is 'convert numeric to float4';

alter function pg_catalog.float4() owner to postgres;

create function pg_catalog.float8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8() is 'convert numeric to float8';

alter function pg_catalog.float8() owner to postgres;

create function pg_catalog.time_pl_interval()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_pl_interval() is 'implementation of + operator';

alter function pg_catalog.time_pl_interval() owner to postgres;

create function pg_catalog.time_mi_interval()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_mi_interval() is 'implementation of - operator';

alter function pg_catalog.time_mi_interval() owner to postgres;

create function pg_catalog.timetz_pl_interval()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_pl_interval() is 'implementation of + operator';

alter function pg_catalog.timetz_pl_interval() owner to postgres;

create function pg_catalog.timetz_mi_interval()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_mi_interval() is 'implementation of - operator';

alter function pg_catalog.timetz_mi_interval() owner to postgres;

create function pg_catalog.numeric_inc()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_inc() is 'increment by one';

alter function pg_catalog.numeric_inc() owner to postgres;

create function pg_catalog.setval()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setval() is 'set sequence value and is_called status';

alter function pg_catalog.setval() owner to postgres;

create function pg_catalog.numeric_smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_smaller() is 'smaller of two';

alter function pg_catalog.numeric_smaller() owner to postgres;

create function pg_catalog.numeric_larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_larger() is 'larger of two';

alter function pg_catalog.numeric_larger() owner to postgres;

create function pg_catalog.to_char(interval)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(interval) is 'format interval to text';

alter function pg_catalog.to_char(interval) owner to postgres;

create function pg_catalog.numeric_cmp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_cmp() is 'less-equal-greater';

alter function pg_catalog.numeric_cmp() owner to postgres;

create function pg_catalog.to_char(timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(timestamp with time zone) is 'format timestamp with time zone to text';

alter function pg_catalog.to_char(timestamp with time zone) owner to postgres;

create function pg_catalog.numeric_uminus()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_uminus() is 'implementation of - operator';

alter function pg_catalog.numeric_uminus() owner to postgres;

create function pg_catalog.to_char(numeric)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(numeric) is 'format numeric to text';

alter function pg_catalog.to_char(numeric) owner to postgres;

create function pg_catalog.to_char()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char() is 'format int4 to text';

alter function pg_catalog.to_char() owner to postgres;

create function pg_catalog.to_char()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char() is 'format int8 to text';

alter function pg_catalog.to_char() owner to postgres;

create function pg_catalog.to_char(real)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(real) is 'format float4 to text';

alter function pg_catalog.to_char(real) owner to postgres;

create function pg_catalog.to_char(double precision)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(double precision) is 'format float8 to text';

alter function pg_catalog.to_char(double precision) owner to postgres;

create function pg_catalog.to_number()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_number() is 'convert text to numeric';

alter function pg_catalog.to_number() owner to postgres;

create function pg_catalog.to_timestamp(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_timestamp(text, text) is 'convert text to timestamp with time zone';

alter function pg_catalog.to_timestamp(text, text) owner to postgres;

create function pg_catalog.int8(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(numeric) is 'convert numeric to int8';

alter function pg_catalog.int8(numeric) owner to postgres;

create function pg_catalog.to_date()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_date() is 'convert text to date';

alter function pg_catalog.to_date() owner to postgres;

create function pg_catalog.numeric()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric() is 'convert int8 to numeric';

alter function pg_catalog.numeric() owner to postgres;

create function pg_catalog.numeric(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(smallint) is 'convert int2 to numeric';

alter function pg_catalog.numeric(smallint) owner to postgres;

create function pg_catalog.int2()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2() is 'convert numeric to int2';

alter function pg_catalog.int2() owner to postgres;

create function pg_catalog.oidin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidin() is 'I/O';

alter function pg_catalog.oidin() owner to postgres;

create function pg_catalog.oidout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidout() is 'I/O';

alter function pg_catalog.oidout() owner to postgres;

create function pg_catalog.bit_length(bytea) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$select pg_catalog.octet_length($1) * 8$$;

comment on function pg_catalog.bit_length(bytea) is 'length in bits';

alter function pg_catalog.bit_length(bytea) owner to postgres;

create function pg_catalog.bit_length(text) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$select pg_catalog.octet_length($1) * 8$$;

comment on function pg_catalog.bit_length(text) is 'length in bits';

alter function pg_catalog.bit_length(text) owner to postgres;

create function pg_catalog.bit_length(bit) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$select pg_catalog.length($1)$$;

comment on function pg_catalog.bit_length(bit) is 'length in bits';

alter function pg_catalog.bit_length(bit) owner to postgres;

create function pg_catalog.convert()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.convert() is 'convert string with specified encoding names';

alter function pg_catalog.convert() owner to postgres;

create function pg_catalog.iclikesel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iclikesel() is 'restriction selectivity of ILIKE';

alter function pg_catalog.iclikesel() owner to postgres;

create function pg_catalog.icnlikesel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icnlikesel() is 'restriction selectivity of NOT ILIKE';

alter function pg_catalog.icnlikesel() owner to postgres;

create function pg_catalog.iclikejoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iclikejoinsel() is 'join selectivity of ILIKE';

alter function pg_catalog.iclikejoinsel() owner to postgres;

create function pg_catalog.icnlikejoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icnlikejoinsel() is 'join selectivity of NOT ILIKE';

alter function pg_catalog.icnlikejoinsel() owner to postgres;

create function pg_catalog.regexeqsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexeqsel() is 'restriction selectivity of regex match';

alter function pg_catalog.regexeqsel() owner to postgres;

create function pg_catalog.likesel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.likesel() is 'restriction selectivity of LIKE';

alter function pg_catalog.likesel() owner to postgres;

create function pg_catalog.icregexeqsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexeqsel() is 'restriction selectivity of case-insensitive regex match';

alter function pg_catalog.icregexeqsel() owner to postgres;

create function pg_catalog.regexnesel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexnesel() is 'restriction selectivity of regex non-match';

alter function pg_catalog.regexnesel() owner to postgres;

create function pg_catalog.nlikesel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nlikesel() is 'restriction selectivity of NOT LIKE';

alter function pg_catalog.nlikesel() owner to postgres;

create function pg_catalog.icregexnesel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexnesel() is 'restriction selectivity of case-insensitive regex non-match';

alter function pg_catalog.icregexnesel() owner to postgres;

create function pg_catalog.regexeqjoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexeqjoinsel() is 'join selectivity of regex match';

alter function pg_catalog.regexeqjoinsel() owner to postgres;

create function pg_catalog.likejoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.likejoinsel() is 'join selectivity of LIKE';

alter function pg_catalog.likejoinsel() owner to postgres;

create function pg_catalog.icregexeqjoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexeqjoinsel() is 'join selectivity of case-insensitive regex match';

alter function pg_catalog.icregexeqjoinsel() owner to postgres;

create function pg_catalog.regexnejoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexnejoinsel() is 'join selectivity of regex non-match';

alter function pg_catalog.regexnejoinsel() owner to postgres;

create function pg_catalog.nlikejoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nlikejoinsel() is 'join selectivity of NOT LIKE';

alter function pg_catalog.nlikejoinsel() owner to postgres;

create function pg_catalog.icregexnejoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexnejoinsel() is 'join selectivity of case-insensitive regex non-match';

alter function pg_catalog.icregexnejoinsel() owner to postgres;

create function pg_catalog.float8_avg()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_avg() is 'aggregate final function';

alter function pg_catalog.float8_avg() owner to postgres;

create function pg_catalog.float8_var_samp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_var_samp() is 'aggregate final function';

alter function pg_catalog.float8_var_samp() owner to postgres;

create function pg_catalog.float8_stddev_samp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_stddev_samp() is 'aggregate final function';

alter function pg_catalog.float8_stddev_samp() owner to postgres;

create function pg_catalog.numeric_accum()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_accum() is 'aggregate transition function';

alter function pg_catalog.numeric_accum() owner to postgres;

create function pg_catalog.int2_accum()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_accum() is 'aggregate transition function';

alter function pg_catalog.int2_accum() owner to postgres;

create function pg_catalog.int4_accum()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_accum() is 'aggregate transition function';

alter function pg_catalog.int4_accum() owner to postgres;

create function pg_catalog.int8_accum()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_accum() is 'aggregate transition function';

alter function pg_catalog.int8_accum() owner to postgres;

create function pg_catalog.numeric_avg()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg() is 'aggregate final function';

alter function pg_catalog.numeric_avg() owner to postgres;

create function pg_catalog.numeric_var_samp()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_var_samp() is 'aggregate final function';

alter function pg_catalog.numeric_var_samp() owner to postgres;

create function pg_catalog.numeric_stddev_samp()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_stddev_samp() is 'aggregate final function';

alter function pg_catalog.numeric_stddev_samp() owner to postgres;

create function pg_catalog.int2_sum()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_sum() is 'aggregate transition function';

alter function pg_catalog.int2_sum() owner to postgres;

create function pg_catalog.int4_sum()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_sum() is 'aggregate transition function';

alter function pg_catalog.int4_sum() owner to postgres;

create function pg_catalog.int8_sum()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_sum() is 'aggregate transition function';

alter function pg_catalog.int8_sum() owner to postgres;

create function pg_catalog.interval_accum()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_accum() is 'aggregate transition function';

alter function pg_catalog.interval_accum() owner to postgres;

create function pg_catalog.interval_avg()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_avg() is 'aggregate final function';

alter function pg_catalog.interval_avg() owner to postgres;

create function pg_catalog.to_ascii()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_ascii() is 'encode text from DB encoding to ASCII text';

alter function pg_catalog.to_ascii() owner to postgres;

create function pg_catalog.to_ascii()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_ascii() is 'encode text from encoding to ASCII text';

alter function pg_catalog.to_ascii() owner to postgres;

create function pg_catalog.to_ascii()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_ascii() is 'encode text from encoding to ASCII text';

alter function pg_catalog.to_ascii() owner to postgres;

create function pg_catalog.interval_pl_time(interval, time without time zone) returns time without time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_time() is 'implementation of + operator';

alter function pg_catalog.interval_pl_time() owner to postgres;

create function pg_catalog.int28eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28eq() is 'implementation of = operator';

alter function pg_catalog.int28eq() owner to postgres;

create function pg_catalog.int28ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28ne() is 'implementation of <> operator';

alter function pg_catalog.int28ne() owner to postgres;

create function pg_catalog.int28lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28lt() is 'implementation of < operator';

alter function pg_catalog.int28lt() owner to postgres;

create function pg_catalog.int28gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28gt() is 'implementation of > operator';

alter function pg_catalog.int28gt() owner to postgres;

create function pg_catalog.int28le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28le() is 'implementation of <= operator';

alter function pg_catalog.int28le() owner to postgres;

create function pg_catalog.int28ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28ge() is 'implementation of >= operator';

alter function pg_catalog.int28ge() owner to postgres;

create function pg_catalog.int82eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82eq() is 'implementation of = operator';

alter function pg_catalog.int82eq() owner to postgres;

create function pg_catalog.int82ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82ne() is 'implementation of <> operator';

alter function pg_catalog.int82ne() owner to postgres;

create function pg_catalog.int82lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82lt() is 'implementation of < operator';

alter function pg_catalog.int82lt() owner to postgres;

create function pg_catalog.int82gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82gt() is 'implementation of > operator';

alter function pg_catalog.int82gt() owner to postgres;

create function pg_catalog.int82le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82le() is 'implementation of <= operator';

alter function pg_catalog.int82le() owner to postgres;

create function pg_catalog.int82ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82ge() is 'implementation of >= operator';

alter function pg_catalog.int82ge() owner to postgres;

create function pg_catalog.int2and()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2and() is 'implementation of & operator';

alter function pg_catalog.int2and() owner to postgres;

create function pg_catalog.int2or()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2or() is 'implementation of | operator';

alter function pg_catalog.int2or() owner to postgres;

create function pg_catalog.int2xor()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2xor() is 'implementation of # operator';

alter function pg_catalog.int2xor() owner to postgres;

create function pg_catalog.int2not()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2not() is 'implementation of ~ operator';

alter function pg_catalog.int2not() owner to postgres;

create function pg_catalog.int2shl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2shl() is 'implementation of << operator';

alter function pg_catalog.int2shl() owner to postgres;

create function pg_catalog.int2shr()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2shr() is 'implementation of >> operator';

alter function pg_catalog.int2shr() owner to postgres;

create function pg_catalog.int4and()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4and() is 'implementation of & operator';

alter function pg_catalog.int4and() owner to postgres;

create function pg_catalog.int4or()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4or() is 'implementation of | operator';

alter function pg_catalog.int4or() owner to postgres;

create function pg_catalog.int4xor()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4xor() is 'implementation of # operator';

alter function pg_catalog.int4xor() owner to postgres;

create function pg_catalog.int4not()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4not() is 'implementation of ~ operator';

alter function pg_catalog.int4not() owner to postgres;

create function pg_catalog.int4shl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4shl() is 'implementation of << operator';

alter function pg_catalog.int4shl() owner to postgres;

create function pg_catalog.int4shr()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4shr() is 'implementation of >> operator';

alter function pg_catalog.int4shr() owner to postgres;

create function pg_catalog.int8and()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8and() is 'implementation of & operator';

alter function pg_catalog.int8and() owner to postgres;

create function pg_catalog.int8or()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8or() is 'implementation of | operator';

alter function pg_catalog.int8or() owner to postgres;

create function pg_catalog.int8xor()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8xor() is 'implementation of # operator';

alter function pg_catalog.int8xor() owner to postgres;

create function pg_catalog.int8not()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8not() is 'implementation of ~ operator';

alter function pg_catalog.int8not() owner to postgres;

create function pg_catalog.int8shl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8shl() is 'implementation of << operator';

alter function pg_catalog.int8shl() owner to postgres;

create function pg_catalog.int8shr()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8shr() is 'implementation of >> operator';

alter function pg_catalog.int8shr() owner to postgres;

create function pg_catalog.int8up()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8up() is 'implementation of + operator';

alter function pg_catalog.int8up() owner to postgres;

create function pg_catalog.int2up()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2up() is 'implementation of + operator';

alter function pg_catalog.int2up() owner to postgres;

create function pg_catalog.int4up()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4up() is 'implementation of + operator';

alter function pg_catalog.int4up() owner to postgres;

create function pg_catalog.float4up()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4up() is 'implementation of + operator';

alter function pg_catalog.float4up() owner to postgres;

create function pg_catalog.float8up()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8up() is 'implementation of + operator';

alter function pg_catalog.float8up() owner to postgres;

create function pg_catalog.numeric_uplus()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_uplus() is 'implementation of + operator';

alter function pg_catalog.numeric_uplus() owner to postgres;

create function pg_catalog.has_table_privilege(name, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(name, text) is 'user privilege on relation by username, rel name';

alter function pg_catalog.has_table_privilege(name, text) owner to postgres;

create function pg_catalog.has_table_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(name, oid, text) is 'user privilege on relation by username, rel oid';

alter function pg_catalog.has_table_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_table_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege() is 'user privilege on relation by user oid, rel name';

alter function pg_catalog.has_table_privilege() owner to postgres;

create function pg_catalog.has_table_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege() is 'user privilege on relation by user oid, rel oid';

alter function pg_catalog.has_table_privilege() owner to postgres;

create function pg_catalog.has_table_privilege(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(text) is 'current user privilege on relation by rel name';

alter function pg_catalog.has_table_privilege(text) owner to postgres;

create function pg_catalog.has_table_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(oid, text) is 'current user privilege on relation by rel oid';

alter function pg_catalog.has_table_privilege(oid, text) owner to postgres;

create function pg_catalog.pg_stat_get_numscans()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_numscans() is 'statistics: number of scans done for table/index';

alter function pg_catalog.pg_stat_get_numscans() owner to postgres;

create function pg_catalog.pg_stat_get_tuples_returned()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_returned() is 'statistics: number of tuples read by seqscan';

alter function pg_catalog.pg_stat_get_tuples_returned() owner to postgres;

create function pg_catalog.pg_stat_get_tuples_fetched()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_fetched() is 'statistics: number of tuples fetched by idxscan';

alter function pg_catalog.pg_stat_get_tuples_fetched() owner to postgres;

create function pg_catalog.pg_stat_get_tuples_inserted()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_inserted() is 'statistics: number of tuples inserted';

alter function pg_catalog.pg_stat_get_tuples_inserted() owner to postgres;

create function pg_catalog.pg_stat_get_tuples_updated()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_updated() is 'statistics: number of tuples updated';

alter function pg_catalog.pg_stat_get_tuples_updated() owner to postgres;

create function pg_catalog.pg_stat_get_tuples_deleted()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_deleted() is 'statistics: number of tuples deleted';

alter function pg_catalog.pg_stat_get_tuples_deleted() owner to postgres;

create function pg_catalog.pg_stat_get_blocks_fetched()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_blocks_fetched() is 'statistics: number of blocks fetched';

alter function pg_catalog.pg_stat_get_blocks_fetched() owner to postgres;

create function pg_catalog.pg_stat_get_blocks_hit()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_blocks_hit() is 'statistics: number of blocks found in cache';

alter function pg_catalog.pg_stat_get_blocks_hit() owner to postgres;

create function pg_catalog.pg_stat_get_backend_idset()
    stable
    strict
    parallel restricted
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_idset() is 'statistics: currently active backend IDs';

alter function pg_catalog.pg_stat_get_backend_idset() owner to postgres;

create function pg_catalog.pg_stat_get_backend_pid()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_pid() is 'statistics: PID of backend';

alter function pg_catalog.pg_stat_get_backend_pid() owner to postgres;

create function pg_catalog.pg_stat_get_backend_dbid()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_dbid() is 'statistics: database ID of backend';

alter function pg_catalog.pg_stat_get_backend_dbid() owner to postgres;

create function pg_catalog.pg_stat_get_backend_userid()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_userid() is 'statistics: user ID of backend';

alter function pg_catalog.pg_stat_get_backend_userid() owner to postgres;

create function pg_catalog.pg_stat_get_backend_activity()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_activity() is 'statistics: current query of backend';

alter function pg_catalog.pg_stat_get_backend_activity() owner to postgres;

create function pg_catalog.pg_stat_get_db_numbackends()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_numbackends() is 'statistics: number of backends in database';

alter function pg_catalog.pg_stat_get_db_numbackends() owner to postgres;

create function pg_catalog.pg_stat_get_db_xact_commit()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_xact_commit() is 'statistics: transactions committed';

alter function pg_catalog.pg_stat_get_db_xact_commit() owner to postgres;

create function pg_catalog.pg_stat_get_db_xact_rollback()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_xact_rollback() is 'statistics: transactions rolled back';

alter function pg_catalog.pg_stat_get_db_xact_rollback() owner to postgres;

create function pg_catalog.pg_stat_get_db_blocks_fetched()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blocks_fetched() is 'statistics: blocks fetched for database';

alter function pg_catalog.pg_stat_get_db_blocks_fetched() owner to postgres;

create function pg_catalog.pg_stat_get_db_blocks_hit()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blocks_hit() is 'statistics: blocks found in cache for database';

alter function pg_catalog.pg_stat_get_db_blocks_hit() owner to postgres;

create function pg_catalog.encode()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.encode() is 'convert bytea value into some ascii-only text string';

alter function pg_catalog.encode() owner to postgres;

create function pg_catalog.decode()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.decode() is 'convert ascii-encoded text string into bytea value';

alter function pg_catalog.decode() owner to postgres;

create function pg_catalog.byteaeq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteaeq() is 'implementation of = operator';

alter function pg_catalog.byteaeq() owner to postgres;

create function pg_catalog.bytealt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytealt() is 'implementation of < operator';

alter function pg_catalog.bytealt() owner to postgres;

create function pg_catalog.byteale()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteale() is 'implementation of <= operator';

alter function pg_catalog.byteale() owner to postgres;

create function pg_catalog.byteagt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteagt() is 'implementation of > operator';

alter function pg_catalog.byteagt() owner to postgres;

create function pg_catalog.byteage()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteage() is 'implementation of >= operator';

alter function pg_catalog.byteage() owner to postgres;

create function pg_catalog.byteane()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteane() is 'implementation of <> operator';

alter function pg_catalog.byteane() owner to postgres;

create function pg_catalog.byteacmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteacmp() is 'less-equal-greater';

alter function pg_catalog.byteacmp() owner to postgres;

create function pg_catalog.timestamp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp() is 'adjust timestamp precision';

alter function pg_catalog.timestamp() owner to postgres;

create function pg_catalog.int2_avg_accum()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_avg_accum() is 'aggregate transition function';

alter function pg_catalog.int2_avg_accum() owner to postgres;

create function pg_catalog.int4_avg_accum()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_avg_accum() is 'aggregate transition function';

alter function pg_catalog.int4_avg_accum() owner to postgres;

create function pg_catalog.int8_avg()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg() is 'aggregate final function';

alter function pg_catalog.int8_avg() owner to postgres;

create function pg_catalog.oidlarger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidlarger() is 'larger of two';

alter function pg_catalog.oidlarger() owner to postgres;

create function pg_catalog.oidsmaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidsmaller() is 'smaller of two';

alter function pg_catalog.oidsmaller() owner to postgres;

create function pg_catalog.timestamptz(timestamp with time zone, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(timestamp with time zone, integer) is 'adjust timestamptz precision';

alter function pg_catalog.timestamptz(timestamp with time zone, integer) owner to postgres;

create function pg_catalog.time(time, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(time, integer) is 'adjust time precision';

alter function pg_catalog.time(time, integer) owner to postgres;

create function pg_catalog.timetz(time with time zone, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz(time with time zone, integer) is 'adjust time with time zone precision';

alter function pg_catalog.timetz(time with time zone, integer) owner to postgres;

create function pg_catalog.pg_stat_get_tuples_hot_updated()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_hot_updated() is 'statistics: number of tuples hot updated';

alter function pg_catalog.pg_stat_get_tuples_hot_updated() owner to postgres;

create function pg_catalog.div()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.div() is 'trunc(x/y)';

alter function pg_catalog.div() owner to postgres;

create function pg_catalog.numeric_div_trunc()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_div_trunc() is 'trunc(x/y)';

alter function pg_catalog.numeric_div_trunc() owner to postgres;

create function pg_catalog.shobj_description(oid, name) returns text
    stable
    strict
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.shobj_description() is 'get description for object id and shared catalog name';

alter function pg_catalog.shobj_description() owner to postgres;

create function pg_catalog.textanycat(text, anynonarray) returns text
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.textanycat() is 'implementation of || operator';

alter function pg_catalog.textanycat() owner to postgres;

create function pg_catalog.anytextcat(anynonarray, text) returns text
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.anytextcat() is 'implementation of || operator';

alter function pg_catalog.anytextcat() owner to postgres;

create function pg_catalog.bytealike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytealike() is 'implementation of ~~ operator';

alter function pg_catalog.bytealike() owner to postgres;

create function pg_catalog.byteanlike()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteanlike() is 'implementation of !~~ operator';

alter function pg_catalog.byteanlike() owner to postgres;

create function pg_catalog."like"(bytea, bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."like"(bytea, bytea) is 'matches LIKE expression';

alter function pg_catalog."like"(bytea, bytea) owner to postgres;

create function pg_catalog.notlike(bytea, bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.notlike(bytea, bytea) is 'does not match LIKE expression';

alter function pg_catalog.notlike(bytea, bytea) owner to postgres;

create function pg_catalog.like_escape(bytea, bytea) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.like_escape(bytea, bytea) is 'convert LIKE pattern to use backslash escapes';

alter function pg_catalog.like_escape(bytea, bytea) owner to postgres;

create function pg_catalog.length()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length() is 'octet length';

alter function pg_catalog.length() owner to postgres;

create function pg_catalog.byteacat()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteacat() is 'implementation of || operator';

alter function pg_catalog.byteacat() owner to postgres;

create function pg_catalog.substring(bytea, integer) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(bytea, integer) is 'extract portion of string';

alter function pg_catalog.substring(bytea, integer) owner to postgres;

create function pg_catalog.substring(bytea) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(bytea) is 'extract portion of string';

alter function pg_catalog.substring(bytea) owner to postgres;

create function pg_catalog.position(bytea, bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.position(bytea, bytea) is 'position of substring';

alter function pg_catalog.position(bytea, bytea) owner to postgres;

create function pg_catalog.btrim(bytea, bytea) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrim(bytea, bytea) is 'trim both ends of string';

alter function pg_catalog.btrim(bytea, bytea) owner to postgres;

create function pg_catalog.time(timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(timestamp with time zone) is 'convert timestamp with time zone to time';

alter function pg_catalog.time(timestamp with time zone) owner to postgres;

create function pg_catalog.date_trunc(timestamp) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(timestamp) is 'truncate timestamp to specified units';

alter function pg_catalog.date_trunc(timestamp) owner to postgres;

create function pg_catalog.date_part(timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(timestamp) is 'extract field from timestamp';

alter function pg_catalog.date_part(timestamp) owner to postgres;

create function pg_catalog.pg_stat_get_activity()
    stable
    parallel restricted
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_activity() is 'statistics: information about currently active backends';

alter function pg_catalog.pg_stat_get_activity() owner to postgres;

create function pg_catalog.timestamp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp() is 'convert date to timestamp';

alter function pg_catalog.timestamp() owner to postgres;

create function pg_catalog.timestamp(time)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp(time) is 'convert date and time to timestamp';

alter function pg_catalog.timestamp(time) owner to postgres;

create function pg_catalog.pg_backend_pid()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_backend_pid() is 'statistics: current backend PID';

alter function pg_catalog.pg_backend_pid() owner to postgres;

create function pg_catalog.timestamp()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp() is 'convert timestamp with time zone to timestamp';

alter function pg_catalog.timestamp() owner to postgres;

create function pg_catalog.timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz() is 'convert timestamp to timestamp with time zone';

alter function pg_catalog.timestamptz() owner to postgres;

create function pg_catalog.date(timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date(timestamp) is 'convert timestamp to date';

alter function pg_catalog.date(timestamp) owner to postgres;

create function pg_catalog.timestamp_mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_mi() is 'implementation of - operator';

alter function pg_catalog.timestamp_mi() owner to postgres;

create function pg_catalog.timestamp_pl_interval()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_pl_interval() is 'implementation of + operator';

alter function pg_catalog.timestamp_pl_interval() owner to postgres;

create function pg_catalog.timestamp_mi_interval()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_mi_interval() is 'implementation of - operator';

alter function pg_catalog.timestamp_mi_interval() owner to postgres;

create function pg_catalog.pg_conf_load_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_conf_load_time() is 'configuration load time';

alter function pg_catalog.pg_conf_load_time() owner to postgres;

create function pg_catalog.timestamp_smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_smaller() is 'smaller of two';

alter function pg_catalog.timestamp_smaller() owner to postgres;

create function pg_catalog.timestamp_larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_larger() is 'larger of two';

alter function pg_catalog.timestamp_larger() owner to postgres;

create function pg_catalog.timezone(text, time with time zone) returns time with time zone
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(text, time with time zone) is 'adjust time with time zone to new zone';

alter function pg_catalog.timezone(text, time with time zone) owner to postgres;

create function pg_catalog.timezone(time with time zone) returns time with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(time with time zone) is 'adjust time with time zone to new zone';

alter function pg_catalog.timezone(time with time zone) owner to postgres;

create function pg_catalog.timestamp_hash()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_hash() is 'hash';

alter function pg_catalog.timestamp_hash() owner to postgres;

create function pg_catalog."overlaps"()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"() is 'intervals overlap?';

alter function pg_catalog."overlaps"() owner to postgres;

create function pg_catalog."overlaps"(timestamp without time zone, interval, timestamp without time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp, timestamp) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, timestamp) owner to postgres;

create function pg_catalog."overlaps"(timestamp without time zone, timestamp without time zone, timestamp without time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
as
$$select ($1, $2) overlaps ($3, ($3 + $4))$$;

comment on function pg_catalog."overlaps"(timestamp, timestamp, timestamp, interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, timestamp, timestamp, interval) owner to postgres;

create function pg_catalog."overlaps"(timestamp without time zone, interval, timestamp without time zone, timestamp without time zone) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
as
$$select ($1, ($1 + $2)) overlaps ($3, $4)$$;

comment on function pg_catalog."overlaps"(timestamp, interval, timestamp, timestamp) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, interval, timestamp, timestamp) owner to postgres;

create function pg_catalog.timestamp_cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_cmp() is 'less-equal-greater';

alter function pg_catalog.timestamp_cmp() owner to postgres;

create function pg_catalog.time(time with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(time with time zone) is 'convert time with time zone to time';

alter function pg_catalog.time(time with time zone) owner to postgres;

create function pg_catalog.timetz(time)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz(time) is 'convert time to time with time zone';

alter function pg_catalog.timetz(time) owner to postgres;

create function pg_catalog.isfinite()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite() is 'finite timestamp?';

alter function pg_catalog.isfinite() owner to postgres;

create function pg_catalog.to_char(timestamp)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(timestamp) is 'format timestamp to text';

alter function pg_catalog.to_char(timestamp) owner to postgres;

create function pg_catalog.timestamp_eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_eq() is 'implementation of = operator';

alter function pg_catalog.timestamp_eq() owner to postgres;

create function pg_catalog.timestamp_ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ne() is 'implementation of <> operator';

alter function pg_catalog.timestamp_ne() owner to postgres;

create function pg_catalog.timestamp_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_lt() is 'implementation of < operator';

alter function pg_catalog.timestamp_lt() owner to postgres;

create function pg_catalog.timestamp_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_le() is 'implementation of <= operator';

alter function pg_catalog.timestamp_le() owner to postgres;

create function pg_catalog.timestamp_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ge() is 'implementation of >= operator';

alter function pg_catalog.timestamp_ge() owner to postgres;

create function pg_catalog.timestamp_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_gt() is 'implementation of > operator';

alter function pg_catalog.timestamp_gt() owner to postgres;

create function pg_catalog.age(timestamp, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(timestamp, timestamp) is 'date difference preserving months and years';

alter function pg_catalog.age(timestamp, timestamp) owner to postgres;

create function pg_catalog.age(timestamp without time zone) returns interval
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.age() is 'date difference from today preserving months and years';

alter function pg_catalog.age() owner to postgres;

create function pg_catalog.timezone(timestamp) returns timestamp with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(timestamp) is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(timestamp) owner to postgres;

create function pg_catalog.timezone(interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(interval) is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(interval) owner to postgres;

create function pg_catalog.date_pl_interval()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_pl_interval() is 'implementation of + operator';

alter function pg_catalog.date_pl_interval() owner to postgres;

create function pg_catalog.date_mi_interval()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_mi_interval() is 'implementation of - operator';

alter function pg_catalog.date_mi_interval() owner to postgres;

create function pg_catalog.substring(text, text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring() is 'extract text matching regular expression';

alter function pg_catalog.substring() owner to postgres;

create function pg_catalog.bit()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit() is 'convert int8 to bitstring';

alter function pg_catalog.bit() owner to postgres;

create function pg_catalog.int8(bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(bit) is 'convert bitstring to int8';

alter function pg_catalog.int8(bit) owner to postgres;

create function pg_catalog.current_setting()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_setting() is 'SHOW X as a function';

alter function pg_catalog.current_setting() owner to postgres;

create function pg_catalog.set_config()
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_config() is 'SET X as a function';

alter function pg_catalog.set_config() owner to postgres;

create function pg_catalog.pg_table_is_visible()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_table_is_visible() is 'is table visible in search path?';

alter function pg_catalog.pg_table_is_visible() owner to postgres;

create function pg_catalog.pg_type_is_visible()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_type_is_visible() is 'is type visible in search path?';

alter function pg_catalog.pg_type_is_visible() owner to postgres;

create function pg_catalog.pg_function_is_visible()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_function_is_visible() is 'is function visible in search path?';

alter function pg_catalog.pg_function_is_visible() owner to postgres;

create function pg_catalog.pg_operator_is_visible()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_operator_is_visible() is 'is operator visible in search path?';

alter function pg_catalog.pg_operator_is_visible() owner to postgres;

create function pg_catalog.pg_opclass_is_visible()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_opclass_is_visible() is 'is opclass visible in search path?';

alter function pg_catalog.pg_opclass_is_visible() owner to postgres;

create function pg_catalog.pg_show_all_settings()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_show_all_settings() is 'SHOW ALL as a function';

alter function pg_catalog.pg_show_all_settings() owner to postgres;

create function pg_catalog.substr(bytea, integer) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(bytea, integer) is 'extract portion of string';

alter function pg_catalog.substr(bytea, integer) owner to postgres;

create function pg_catalog.substr(bytea) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(bytea) is 'extract portion of string';

alter function pg_catalog.substr(bytea) owner to postgres;

create function pg_catalog.replace()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.replace() is 'replace all occurrences in string of old_substr with new_substr';

alter function pg_catalog.replace() owner to postgres;

create function pg_catalog.split_part()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.split_part() is 'split string by field_sep and return field_num';

alter function pg_catalog.split_part() owner to postgres;

create function pg_catalog.to_hex()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_hex() is 'convert int4 number to hex';

alter function pg_catalog.to_hex() owner to postgres;

create function pg_catalog.to_hex()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_hex() is 'convert int8 number to hex';

alter function pg_catalog.to_hex() owner to postgres;

create function pg_catalog.array_lower()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_lower() is 'array lower dimension';

alter function pg_catalog.array_lower() owner to postgres;

create function pg_catalog.array_upper()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_upper() is 'array upper dimension';

alter function pg_catalog.array_upper() owner to postgres;

create function pg_catalog.pg_conversion_is_visible()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_conversion_is_visible() is 'is conversion visible in search path?';

alter function pg_catalog.pg_conversion_is_visible() owner to postgres;

create function pg_catalog.pg_stat_get_backend_activity_start()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_activity_start() is 'statistics: start time for current query of backend';

alter function pg_catalog.pg_stat_get_backend_activity_start() owner to postgres;

create function pg_catalog.pg_terminate_backend()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_terminate_backend() is 'terminate a server process';

alter function pg_catalog.pg_terminate_backend() owner to postgres;

create function pg_catalog.pg_get_functiondef()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_functiondef() is 'definition of a function';

alter function pg_catalog.pg_get_functiondef() owner to postgres;

create function pg_catalog.text_pattern_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_lt() is 'implementation of ~<~ operator';

alter function pg_catalog.text_pattern_lt() owner to postgres;

create function pg_catalog.text_pattern_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_le() is 'implementation of ~<=~ operator';

alter function pg_catalog.text_pattern_le() owner to postgres;

create function pg_catalog.pg_get_function_arguments()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_arguments() is 'argument list of a function';

alter function pg_catalog.pg_get_function_arguments() owner to postgres;

create function pg_catalog.text_pattern_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_ge() is 'implementation of ~>=~ operator';

alter function pg_catalog.text_pattern_ge() owner to postgres;

create function pg_catalog.text_pattern_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_gt() is 'implementation of ~>~ operator';

alter function pg_catalog.text_pattern_gt() owner to postgres;

create function pg_catalog.pg_get_function_result()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_result() is 'result type of a function';

alter function pg_catalog.pg_get_function_result() owner to postgres;

create function pg_catalog.bttext_pattern_cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttext_pattern_cmp() is 'less-equal-greater';

alter function pg_catalog.bttext_pattern_cmp() owner to postgres;

create function pg_catalog.ceiling()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceiling() is 'nearest integer >= value';

alter function pg_catalog.ceiling() owner to postgres;

create function pg_catalog.pg_database_size(name)
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_database_size(name) is 'total disk space usage for the specified database';

alter function pg_catalog.pg_database_size(name) owner to postgres;

create function pg_catalog.power()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.power() is 'exponentiation';

alter function pg_catalog.power() owner to postgres;

create function pg_catalog.width_bucket()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width_bucket() is 'bucket number of operand in equal-width histogram';

alter function pg_catalog.width_bucket() owner to postgres;

create function pg_catalog.pg_cancel_backend()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_cancel_backend() is 'cancel a server process'' current query';

alter function pg_catalog.pg_cancel_backend() owner to postgres;

create function pg_catalog.pg_start_backup()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_start_backup() is 'prepare for taking an online backup';

alter function pg_catalog.pg_start_backup() owner to postgres;

create function pg_catalog.pg_stop_backup()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stop_backup() is 'finish taking an online backup';

alter function pg_catalog.pg_stop_backup() owner to postgres;

create function pg_catalog.bpchar_pattern_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_lt() is 'implementation of ~<~ operator';

alter function pg_catalog.bpchar_pattern_lt() owner to postgres;

create function pg_catalog.bpchar_pattern_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_le() is 'implementation of ~<=~ operator';

alter function pg_catalog.bpchar_pattern_le() owner to postgres;

create function pg_catalog.array_length()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_length() is 'array length';

alter function pg_catalog.array_length() owner to postgres;

create function pg_catalog.bpchar_pattern_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_ge() is 'implementation of ~>=~ operator';

alter function pg_catalog.bpchar_pattern_ge() owner to postgres;

create function pg_catalog.bpchar_pattern_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_gt() is 'implementation of ~>~ operator';

alter function pg_catalog.bpchar_pattern_gt() owner to postgres;

create function pg_catalog.gist_point_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_consistent() is 'GiST support';

alter function pg_catalog.gist_point_consistent() owner to postgres;

create function pg_catalog.btbpchar_pattern_cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btbpchar_pattern_cmp() is 'less-equal-greater';

alter function pg_catalog.btbpchar_pattern_cmp() owner to postgres;

create function pg_catalog.has_sequence_privilege(name, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(name, text) is 'user privilege on sequence by username, seq name';

alter function pg_catalog.has_sequence_privilege(name, text) owner to postgres;

create function pg_catalog.has_sequence_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(name, oid, text) is 'user privilege on sequence by username, seq oid';

alter function pg_catalog.has_sequence_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_sequence_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege() is 'user privilege on sequence by user oid, seq name';

alter function pg_catalog.has_sequence_privilege() owner to postgres;

create function pg_catalog.has_sequence_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege() is 'user privilege on sequence by user oid, seq oid';

alter function pg_catalog.has_sequence_privilege() owner to postgres;

create function pg_catalog.has_sequence_privilege(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(text) is 'current user privilege on sequence by seq name';

alter function pg_catalog.has_sequence_privilege(text) owner to postgres;

create function pg_catalog.has_sequence_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(oid, text) is 'current user privilege on sequence by seq oid';

alter function pg_catalog.has_sequence_privilege(oid, text) owner to postgres;

create function pg_catalog.btint48cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint48cmp() is 'less-equal-greater';

alter function pg_catalog.btint48cmp() owner to postgres;

create function pg_catalog.btint84cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint84cmp() is 'less-equal-greater';

alter function pg_catalog.btint84cmp() owner to postgres;

create function pg_catalog.btint24cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint24cmp() is 'less-equal-greater';

alter function pg_catalog.btint24cmp() owner to postgres;

create function pg_catalog.btint42cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint42cmp() is 'less-equal-greater';

alter function pg_catalog.btint42cmp() owner to postgres;

create function pg_catalog.btint28cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint28cmp() is 'less-equal-greater';

alter function pg_catalog.btint28cmp() owner to postgres;

create function pg_catalog.btint82cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint82cmp() is 'less-equal-greater';

alter function pg_catalog.btint82cmp() owner to postgres;

create function pg_catalog.btfloat48cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat48cmp() is 'less-equal-greater';

alter function pg_catalog.btfloat48cmp() owner to postgres;

create function pg_catalog.btfloat84cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat84cmp() is 'less-equal-greater';

alter function pg_catalog.btfloat84cmp() owner to postgres;

create function pg_catalog.inet_client_addr()
    stable
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_client_addr() is 'inet address of the client';

alter function pg_catalog.inet_client_addr() owner to postgres;

create function pg_catalog.inet_client_port()
    stable
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_client_port() is 'client''s port number for this connection';

alter function pg_catalog.inet_client_port() owner to postgres;

create function pg_catalog.inet_server_addr()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_server_addr() is 'inet address of the server';

alter function pg_catalog.inet_server_addr() owner to postgres;

create function pg_catalog.inet_server_port()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_server_port() is 'server''s port number for this connection';

alter function pg_catalog.inet_server_port() owner to postgres;

create function pg_catalog.regprocedurein()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocedurein() is 'I/O';

alter function pg_catalog.regprocedurein() owner to postgres;

create function pg_catalog.regprocedureout()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocedureout() is 'I/O';

alter function pg_catalog.regprocedureout() owner to postgres;

create function pg_catalog.regoperin()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperin() is 'I/O';

alter function pg_catalog.regoperin() owner to postgres;

create function pg_catalog.regoperout()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperout() is 'I/O';

alter function pg_catalog.regoperout() owner to postgres;

create function pg_catalog.regoperatorin()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorin() is 'I/O';

alter function pg_catalog.regoperatorin() owner to postgres;

create function pg_catalog.regoperatorout()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorout() is 'I/O';

alter function pg_catalog.regoperatorout() owner to postgres;

create function pg_catalog.regclassin()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclassin() is 'I/O';

alter function pg_catalog.regclassin() owner to postgres;

create function pg_catalog.regclassout()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclassout() is 'I/O';

alter function pg_catalog.regclassout() owner to postgres;

create function pg_catalog.regtypein()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtypein() is 'I/O';

alter function pg_catalog.regtypein() owner to postgres;

create function pg_catalog.regtypeout()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtypeout() is 'I/O';

alter function pg_catalog.regtypeout() owner to postgres;

create function pg_catalog.pg_stat_clear_snapshot()
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_clear_snapshot() is 'statistics: discard current transaction''s statistics snapshot';

alter function pg_catalog.pg_stat_clear_snapshot() owner to postgres;

create function pg_catalog.pg_get_function_identity_arguments()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_identity_arguments() is 'identity argument list of a function';

alter function pg_catalog.pg_get_function_identity_arguments() owner to postgres;

create function pg_catalog.hashtid()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtid() is 'hash';

alter function pg_catalog.hashtid() owner to postgres;

create function pg_catalog.hashtidextended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtidextended() is 'hash';

alter function pg_catalog.hashtidextended() owner to postgres;

create function pg_catalog.fmgr_internal_validator()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fmgr_internal_validator() is '(internal)';

alter function pg_catalog.fmgr_internal_validator() owner to postgres;

create function pg_catalog.fmgr_c_validator()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fmgr_c_validator() is '(internal)';

alter function pg_catalog.fmgr_c_validator() owner to postgres;

create function pg_catalog.fmgr_sql_validator()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fmgr_sql_validator() is '(internal)';

alter function pg_catalog.fmgr_sql_validator() owner to postgres;

create function pg_catalog.has_database_privilege(name, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(name, text) is 'user privilege on database by username, database name';

alter function pg_catalog.has_database_privilege(name, text) owner to postgres;

create function pg_catalog.has_database_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(name, oid, text) is 'user privilege on database by username, database oid';

alter function pg_catalog.has_database_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_database_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege() is 'user privilege on database by user oid, database name';

alter function pg_catalog.has_database_privilege() owner to postgres;

create function pg_catalog.has_database_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege() is 'user privilege on database by user oid, database oid';

alter function pg_catalog.has_database_privilege() owner to postgres;

create function pg_catalog.has_database_privilege(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(text) is 'current user privilege on database by database name';

alter function pg_catalog.has_database_privilege(text) owner to postgres;

create function pg_catalog.has_database_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(oid, text) is 'current user privilege on database by database oid';

alter function pg_catalog.has_database_privilege(oid, text) owner to postgres;

create function pg_catalog.has_function_privilege(name, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(name, text) is 'user privilege on function by username, function name';

alter function pg_catalog.has_function_privilege(name, text) owner to postgres;

create function pg_catalog.has_function_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(name, oid, text) is 'user privilege on function by username, function oid';

alter function pg_catalog.has_function_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_function_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege() is 'user privilege on function by user oid, function name';

alter function pg_catalog.has_function_privilege() owner to postgres;

create function pg_catalog.has_function_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege() is 'user privilege on function by user oid, function oid';

alter function pg_catalog.has_function_privilege() owner to postgres;

create function pg_catalog.has_function_privilege(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(text) is 'current user privilege on function by function name';

alter function pg_catalog.has_function_privilege(text) owner to postgres;

create function pg_catalog.has_function_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(oid, text) is 'current user privilege on function by function oid';

alter function pg_catalog.has_function_privilege(oid, text) owner to postgres;

create function pg_catalog.has_language_privilege(name, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(name, text) is 'user privilege on language by username, language name';

alter function pg_catalog.has_language_privilege(name, text) owner to postgres;

create function pg_catalog.has_language_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(name, oid, text) is 'user privilege on language by username, language oid';

alter function pg_catalog.has_language_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_language_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege() is 'user privilege on language by user oid, language name';

alter function pg_catalog.has_language_privilege() owner to postgres;

create function pg_catalog.has_language_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege() is 'user privilege on language by user oid, language oid';

alter function pg_catalog.has_language_privilege() owner to postgres;

create function pg_catalog.has_language_privilege(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(text) is 'current user privilege on language by language name';

alter function pg_catalog.has_language_privilege(text) owner to postgres;

create function pg_catalog.has_language_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(oid, text) is 'current user privilege on language by language oid';

alter function pg_catalog.has_language_privilege(oid, text) owner to postgres;

create function pg_catalog.has_schema_privilege(name, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(name, text) is 'user privilege on schema by username, schema name';

alter function pg_catalog.has_schema_privilege(name, text) owner to postgres;

create function pg_catalog.has_schema_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(name, oid, text) is 'user privilege on schema by username, schema oid';

alter function pg_catalog.has_schema_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_schema_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege() is 'user privilege on schema by user oid, schema name';

alter function pg_catalog.has_schema_privilege() owner to postgres;

create function pg_catalog.has_schema_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege() is 'user privilege on schema by user oid, schema oid';

alter function pg_catalog.has_schema_privilege() owner to postgres;

create function pg_catalog.has_schema_privilege(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(text) is 'current user privilege on schema by schema name';

alter function pg_catalog.has_schema_privilege(text) owner to postgres;

create function pg_catalog.has_schema_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(oid, text) is 'current user privilege on schema by schema oid';

alter function pg_catalog.has_schema_privilege(oid, text) owner to postgres;

create function pg_catalog.pg_stat_reset()
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset() is 'statistics: reset collected statistics for current database';

alter function pg_catalog.pg_stat_reset() owner to postgres;

create function pg_catalog.regexp_replace()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_replace() is 'replace text using regexp';

alter function pg_catalog.regexp_replace() owner to postgres;

create function pg_catalog.regexp_replace()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_replace() is 'replace text using regexp';

alter function pg_catalog.regexp_replace() owner to postgres;

create function pg_catalog.pg_total_relation_size()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_total_relation_size() is 'total disk space usage for the specified table and associated indexes';

alter function pg_catalog.pg_total_relation_size() owner to postgres;

create function pg_catalog.pg_size_pretty()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_size_pretty() is 'convert a long int to a human readable text using size units';

alter function pg_catalog.pg_size_pretty() owner to postgres;

create function pg_catalog.pg_options_to_table()
    stable
    strict
    parallel safe
    cost 1
    rows 3
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_options_to_table() is 'convert generic options array to name/value table';

alter function pg_catalog.pg_options_to_table() owner to postgres;

create function pg_catalog.record_in()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_in() is 'I/O';

alter function pg_catalog.record_in() owner to postgres;

create function pg_catalog.record_out()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_out() is 'I/O';

alter function pg_catalog.record_out() owner to postgres;

create function pg_catalog.cstring_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_in() is 'I/O';

alter function pg_catalog.cstring_in() owner to postgres;

create function pg_catalog.cstring_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_out() is 'I/O';

alter function pg_catalog.cstring_out() owner to postgres;

create function pg_catalog.any_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.any_in() is 'I/O';

alter function pg_catalog.any_in() owner to postgres;

create function pg_catalog.any_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.any_out() is 'I/O';

alter function pg_catalog.any_out() owner to postgres;

create function pg_catalog.anyarray_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_in() is 'I/O';

alter function pg_catalog.anyarray_in() owner to postgres;

create function pg_catalog.anyarray_out()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_out() is 'I/O';

alter function pg_catalog.anyarray_out() owner to postgres;

create function pg_catalog.void_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_in() is 'I/O';

alter function pg_catalog.void_in() owner to postgres;

create function pg_catalog.void_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_out() is 'I/O';

alter function pg_catalog.void_out() owner to postgres;

create function pg_catalog.trigger_in()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trigger_in() is 'I/O';

alter function pg_catalog.trigger_in() owner to postgres;

create function pg_catalog.trigger_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trigger_out() is 'I/O';

alter function pg_catalog.trigger_out() owner to postgres;

create function pg_catalog.language_handler_in()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.language_handler_in() is 'I/O';

alter function pg_catalog.language_handler_in() owner to postgres;

create function pg_catalog.language_handler_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.language_handler_out() is 'I/O';

alter function pg_catalog.language_handler_out() owner to postgres;

create function pg_catalog.internal_in()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.internal_in() is 'I/O';

alter function pg_catalog.internal_in() owner to postgres;

create function pg_catalog.internal_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.internal_out() is 'I/O';

alter function pg_catalog.internal_out() owner to postgres;

create function pg_catalog.opaque_in()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.opaque_in() is 'I/O';

alter function pg_catalog.opaque_in() owner to postgres;

create function pg_catalog.opaque_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.opaque_out() is 'I/O';

alter function pg_catalog.opaque_out() owner to postgres;

create function pg_catalog.ceil()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceil() is 'nearest integer >= value';

alter function pg_catalog.ceil() owner to postgres;

create function pg_catalog.floor()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.floor() is 'nearest integer <= value';

alter function pg_catalog.floor() owner to postgres;

create function pg_catalog.sign()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sign() is 'sign of value';

alter function pg_catalog.sign() owner to postgres;

create function pg_catalog.md5(text)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.md5(text) is 'MD5 hash';

alter function pg_catalog.md5(text) owner to postgres;

create function pg_catalog.anyelement_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyelement_in() is 'I/O';

alter function pg_catalog.anyelement_in() owner to postgres;

create function pg_catalog.anyelement_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyelement_out() is 'I/O';

alter function pg_catalog.anyelement_out() owner to postgres;

create function pg_catalog.postgresql_fdw_validator()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.postgresql_fdw_validator() is '(internal)';

alter function pg_catalog.postgresql_fdw_validator() owner to postgres;

create function pg_catalog.pg_encoding_max_length()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_encoding_max_length() is 'maximum octet length of a character in given encoding';

alter function pg_catalog.pg_encoding_max_length() owner to postgres;

create function pg_catalog.ceiling()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceiling() is 'nearest integer >= value';

alter function pg_catalog.ceiling() owner to postgres;

create function pg_catalog.md5(bytea)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.md5(bytea) is 'MD5 hash';

alter function pg_catalog.md5(bytea) owner to postgres;

create function pg_catalog.pg_tablespace_size(oid)
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_tablespace_size(oid) is 'total disk space usage for the specified tablespace';

alter function pg_catalog.pg_tablespace_size(oid) owner to postgres;

create function pg_catalog.pg_tablespace_size(name)
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_tablespace_size(name) is 'total disk space usage for the specified tablespace';

alter function pg_catalog.pg_tablespace_size(name) owner to postgres;

create function pg_catalog.pg_database_size(oid)
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_database_size(oid) is 'total disk space usage for the specified database';

alter function pg_catalog.pg_database_size(oid) owner to postgres;

create function pg_catalog.pg_relation_size(regclass) returns bigint
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_size() is 'disk space usage for the main fork of the specified table or index';

alter function pg_catalog.pg_relation_size() owner to postgres;

create function pg_catalog.unnest()
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unnest() is 'expand array to set of rows';

alter function pg_catalog.unnest() owner to postgres;

create function pg_catalog.pg_relation_size()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_size() is 'disk space usage for the specified fork of a table or index';

alter function pg_catalog.pg_relation_size() owner to postgres;

create function pg_catalog.array_agg_transfn()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_transfn() is 'aggregate transition function';

alter function pg_catalog.array_agg_transfn() owner to postgres;

create function pg_catalog.array_agg_finalfn()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_finalfn() is 'aggregate final function';

alter function pg_catalog.array_agg_finalfn() owner to postgres;

create function pg_catalog.date_lt_timestamp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_lt_timestamp() is 'implementation of < operator';

alter function pg_catalog.date_lt_timestamp() owner to postgres;

create function pg_catalog.date_le_timestamp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_le_timestamp() is 'implementation of <= operator';

alter function pg_catalog.date_le_timestamp() owner to postgres;

create function pg_catalog.date_eq_timestamp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_eq_timestamp() is 'implementation of = operator';

alter function pg_catalog.date_eq_timestamp() owner to postgres;

create function pg_catalog.date_gt_timestamp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_gt_timestamp() is 'implementation of > operator';

alter function pg_catalog.date_gt_timestamp() owner to postgres;

create function pg_catalog.date_ge_timestamp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ge_timestamp() is 'implementation of >= operator';

alter function pg_catalog.date_ge_timestamp() owner to postgres;

create function pg_catalog.date_ne_timestamp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ne_timestamp() is 'implementation of <> operator';

alter function pg_catalog.date_ne_timestamp() owner to postgres;

create function pg_catalog.date_cmp_timestamp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_cmp_timestamp() is 'less-equal-greater';

alter function pg_catalog.date_cmp_timestamp() owner to postgres;

create function pg_catalog.date_lt_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_lt_timestamptz() is 'implementation of < operator';

alter function pg_catalog.date_lt_timestamptz() owner to postgres;

create function pg_catalog.date_le_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_le_timestamptz() is 'implementation of <= operator';

alter function pg_catalog.date_le_timestamptz() owner to postgres;

create function pg_catalog.date_eq_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_eq_timestamptz() is 'implementation of = operator';

alter function pg_catalog.date_eq_timestamptz() owner to postgres;

create function pg_catalog.date_gt_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_gt_timestamptz() is 'implementation of > operator';

alter function pg_catalog.date_gt_timestamptz() owner to postgres;

create function pg_catalog.date_ge_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ge_timestamptz() is 'implementation of >= operator';

alter function pg_catalog.date_ge_timestamptz() owner to postgres;

create function pg_catalog.date_ne_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ne_timestamptz() is 'implementation of <> operator';

alter function pg_catalog.date_ne_timestamptz() owner to postgres;

create function pg_catalog.date_cmp_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_cmp_timestamptz() is 'less-equal-greater';

alter function pg_catalog.date_cmp_timestamptz() owner to postgres;

create function pg_catalog.timestamp_lt_date()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_lt_date() is 'implementation of < operator';

alter function pg_catalog.timestamp_lt_date() owner to postgres;

create function pg_catalog.timestamp_le_date()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_le_date() is 'implementation of <= operator';

alter function pg_catalog.timestamp_le_date() owner to postgres;

create function pg_catalog.timestamp_eq_date()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_eq_date() is 'implementation of = operator';

alter function pg_catalog.timestamp_eq_date() owner to postgres;

create function pg_catalog.timestamp_gt_date()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_gt_date() is 'implementation of > operator';

alter function pg_catalog.timestamp_gt_date() owner to postgres;

create function pg_catalog.timestamp_ge_date()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ge_date() is 'implementation of >= operator';

alter function pg_catalog.timestamp_ge_date() owner to postgres;

create function pg_catalog.timestamp_ne_date()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ne_date() is 'implementation of <> operator';

alter function pg_catalog.timestamp_ne_date() owner to postgres;

create function pg_catalog.timestamp_cmp_date()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_cmp_date() is 'less-equal-greater';

alter function pg_catalog.timestamp_cmp_date() owner to postgres;

create function pg_catalog.timestamptz_lt_date()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_lt_date() is 'implementation of < operator';

alter function pg_catalog.timestamptz_lt_date() owner to postgres;

create function pg_catalog.timestamptz_le_date()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_le_date() is 'implementation of <= operator';

alter function pg_catalog.timestamptz_le_date() owner to postgres;

create function pg_catalog.timestamptz_eq_date()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_eq_date() is 'implementation of = operator';

alter function pg_catalog.timestamptz_eq_date() owner to postgres;

create function pg_catalog.timestamptz_gt_date()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_gt_date() is 'implementation of > operator';

alter function pg_catalog.timestamptz_gt_date() owner to postgres;

create function pg_catalog.timestamptz_ge_date()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ge_date() is 'implementation of >= operator';

alter function pg_catalog.timestamptz_ge_date() owner to postgres;

create function pg_catalog.timestamptz_ne_date()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ne_date() is 'implementation of <> operator';

alter function pg_catalog.timestamptz_ne_date() owner to postgres;

create function pg_catalog.timestamptz_cmp_date()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_cmp_date() is 'less-equal-greater';

alter function pg_catalog.timestamptz_cmp_date() owner to postgres;

create function pg_catalog.has_tablespace_privilege(name, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(name, text) is 'user privilege on tablespace by username, tablespace name';

alter function pg_catalog.has_tablespace_privilege(name, text) owner to postgres;

create function pg_catalog.has_tablespace_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(name, oid, text) is 'user privilege on tablespace by username, tablespace oid';

alter function pg_catalog.has_tablespace_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_tablespace_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege() is 'user privilege on tablespace by user oid, tablespace name';

alter function pg_catalog.has_tablespace_privilege() owner to postgres;

create function pg_catalog.has_tablespace_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege() is 'user privilege on tablespace by user oid, tablespace oid';

alter function pg_catalog.has_tablespace_privilege() owner to postgres;

create function pg_catalog.has_tablespace_privilege(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(text) is 'current user privilege on tablespace by tablespace name';

alter function pg_catalog.has_tablespace_privilege(text) owner to postgres;

create function pg_catalog.has_tablespace_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(oid, text) is 'current user privilege on tablespace by tablespace oid';

alter function pg_catalog.has_tablespace_privilege(oid, text) owner to postgres;

create function pg_catalog.shell_in()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shell_in() is 'I/O';

alter function pg_catalog.shell_in() owner to postgres;

create function pg_catalog.shell_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shell_out() is 'I/O';

alter function pg_catalog.shell_out() owner to postgres;

create function pg_catalog.array_recv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_recv() is 'I/O';

alter function pg_catalog.array_recv() owner to postgres;

create function pg_catalog.array_send()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_send() is 'I/O';

alter function pg_catalog.array_send() owner to postgres;

create function pg_catalog.record_recv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_recv() is 'I/O';

alter function pg_catalog.record_recv() owner to postgres;

create function pg_catalog.record_send()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_send() is 'I/O';

alter function pg_catalog.record_send() owner to postgres;

create function pg_catalog.int2recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2recv() is 'I/O';

alter function pg_catalog.int2recv() owner to postgres;

create function pg_catalog.int2send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2send() is 'I/O';

alter function pg_catalog.int2send() owner to postgres;

create function pg_catalog.int4recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4recv() is 'I/O';

alter function pg_catalog.int4recv() owner to postgres;

create function pg_catalog.int4send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4send() is 'I/O';

alter function pg_catalog.int4send() owner to postgres;

create function pg_catalog.int8recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8recv() is 'I/O';

alter function pg_catalog.int8recv() owner to postgres;

create function pg_catalog.int8send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8send() is 'I/O';

alter function pg_catalog.int8send() owner to postgres;

create function pg_catalog.int2vectorrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorrecv() is 'I/O';

alter function pg_catalog.int2vectorrecv() owner to postgres;

create function pg_catalog.int2vectorsend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorsend() is 'I/O';

alter function pg_catalog.int2vectorsend() owner to postgres;

create function pg_catalog.bytearecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytearecv() is 'I/O';

alter function pg_catalog.bytearecv() owner to postgres;

create function pg_catalog.byteasend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteasend() is 'I/O';

alter function pg_catalog.byteasend() owner to postgres;

create function pg_catalog.textrecv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textrecv() is 'I/O';

alter function pg_catalog.textrecv() owner to postgres;

create function pg_catalog.textsend()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textsend() is 'I/O';

alter function pg_catalog.textsend() owner to postgres;

create function pg_catalog.unknownrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownrecv() is 'I/O';

alter function pg_catalog.unknownrecv() owner to postgres;

create function pg_catalog.unknownsend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownsend() is 'I/O';

alter function pg_catalog.unknownsend() owner to postgres;

create function pg_catalog.oidrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidrecv() is 'I/O';

alter function pg_catalog.oidrecv() owner to postgres;

create function pg_catalog.oidsend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidsend() is 'I/O';

alter function pg_catalog.oidsend() owner to postgres;

create function pg_catalog.oidvectorrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorrecv() is 'I/O';

alter function pg_catalog.oidvectorrecv() owner to postgres;

create function pg_catalog.oidvectorsend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorsend() is 'I/O';

alter function pg_catalog.oidvectorsend() owner to postgres;

create function pg_catalog.namerecv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namerecv() is 'I/O';

alter function pg_catalog.namerecv() owner to postgres;

create function pg_catalog.namesend()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namesend() is 'I/O';

alter function pg_catalog.namesend() owner to postgres;

create function pg_catalog.float4recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4recv() is 'I/O';

alter function pg_catalog.float4recv() owner to postgres;

create function pg_catalog.float4send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4send() is 'I/O';

alter function pg_catalog.float4send() owner to postgres;

create function pg_catalog.float8recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8recv() is 'I/O';

alter function pg_catalog.float8recv() owner to postgres;

create function pg_catalog.float8send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8send() is 'I/O';

alter function pg_catalog.float8send() owner to postgres;

create function pg_catalog.point_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_recv() is 'I/O';

alter function pg_catalog.point_recv() owner to postgres;

create function pg_catalog.point_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_send() is 'I/O';

alter function pg_catalog.point_send() owner to postgres;

create function pg_catalog.bpcharrecv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharrecv() is 'I/O';

alter function pg_catalog.bpcharrecv() owner to postgres;

create function pg_catalog.bpcharsend()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharsend() is 'I/O';

alter function pg_catalog.bpcharsend() owner to postgres;

create function pg_catalog.varcharrecv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharrecv() is 'I/O';

alter function pg_catalog.varcharrecv() owner to postgres;

create function pg_catalog.varcharsend()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharsend() is 'I/O';

alter function pg_catalog.varcharsend() owner to postgres;

create function pg_catalog.charrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charrecv() is 'I/O';

alter function pg_catalog.charrecv() owner to postgres;

create function pg_catalog.charsend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charsend() is 'I/O';

alter function pg_catalog.charsend() owner to postgres;

create function pg_catalog.boolrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolrecv() is 'I/O';

alter function pg_catalog.boolrecv() owner to postgres;

create function pg_catalog.boolsend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolsend() is 'I/O';

alter function pg_catalog.boolsend() owner to postgres;

create function pg_catalog.tidrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidrecv() is 'I/O';

alter function pg_catalog.tidrecv() owner to postgres;

create function pg_catalog.tidsend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidsend() is 'I/O';

alter function pg_catalog.tidsend() owner to postgres;

create function pg_catalog.xidrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidrecv() is 'I/O';

alter function pg_catalog.xidrecv() owner to postgres;

create function pg_catalog.xidsend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidsend() is 'I/O';

alter function pg_catalog.xidsend() owner to postgres;

create function pg_catalog.cidrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidrecv() is 'I/O';

alter function pg_catalog.cidrecv() owner to postgres;

create function pg_catalog.cidsend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidsend() is 'I/O';

alter function pg_catalog.cidsend() owner to postgres;

create function pg_catalog.regprocrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocrecv() is 'I/O';

alter function pg_catalog.regprocrecv() owner to postgres;

create function pg_catalog.regprocsend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocsend() is 'I/O';

alter function pg_catalog.regprocsend() owner to postgres;

create function pg_catalog.regprocedurerecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocedurerecv() is 'I/O';

alter function pg_catalog.regprocedurerecv() owner to postgres;

create function pg_catalog.regproceduresend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regproceduresend() is 'I/O';

alter function pg_catalog.regproceduresend() owner to postgres;

create function pg_catalog.regoperrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperrecv() is 'I/O';

alter function pg_catalog.regoperrecv() owner to postgres;

create function pg_catalog.regopersend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regopersend() is 'I/O';

alter function pg_catalog.regopersend() owner to postgres;

create function pg_catalog.regoperatorrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorrecv() is 'I/O';

alter function pg_catalog.regoperatorrecv() owner to postgres;

create function pg_catalog.regoperatorsend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorsend() is 'I/O';

alter function pg_catalog.regoperatorsend() owner to postgres;

create function pg_catalog.regclassrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclassrecv() is 'I/O';

alter function pg_catalog.regclassrecv() owner to postgres;

create function pg_catalog.regclasssend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclasssend() is 'I/O';

alter function pg_catalog.regclasssend() owner to postgres;

create function pg_catalog.regtyperecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtyperecv() is 'I/O';

alter function pg_catalog.regtyperecv() owner to postgres;

create function pg_catalog.regtypesend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtypesend() is 'I/O';

alter function pg_catalog.regtypesend() owner to postgres;

create function pg_catalog.bit_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_recv() is 'I/O';

alter function pg_catalog.bit_recv() owner to postgres;

create function pg_catalog.bit_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_send() is 'I/O';

alter function pg_catalog.bit_send() owner to postgres;

create function pg_catalog.varbit_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_recv() is 'I/O';

alter function pg_catalog.varbit_recv() owner to postgres;

create function pg_catalog.varbit_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_send() is 'I/O';

alter function pg_catalog.varbit_send() owner to postgres;

create function pg_catalog.numeric_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_recv() is 'I/O';

alter function pg_catalog.numeric_recv() owner to postgres;

create function pg_catalog.numeric_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_send() is 'I/O';

alter function pg_catalog.numeric_send() owner to postgres;

create function pg_catalog.sinh()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sinh() is 'hyperbolic sine';

alter function pg_catalog.sinh() owner to postgres;

create function pg_catalog.cosh()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cosh() is 'hyperbolic cosine';

alter function pg_catalog.cosh() owner to postgres;

create function pg_catalog.tanh()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tanh() is 'hyperbolic tangent';

alter function pg_catalog.tanh() owner to postgres;

create function pg_catalog.asinh()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.asinh() is 'inverse hyperbolic sine';

alter function pg_catalog.asinh() owner to postgres;

create function pg_catalog.acosh()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acosh() is 'inverse hyperbolic cosine';

alter function pg_catalog.acosh() owner to postgres;

create function pg_catalog.atanh()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atanh() is 'inverse hyperbolic tangent';

alter function pg_catalog.atanh() owner to postgres;

create function pg_catalog.date_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_recv() is 'I/O';

alter function pg_catalog.date_recv() owner to postgres;

create function pg_catalog.date_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_send() is 'I/O';

alter function pg_catalog.date_send() owner to postgres;

create function pg_catalog.time_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_recv() is 'I/O';

alter function pg_catalog.time_recv() owner to postgres;

create function pg_catalog.time_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_send() is 'I/O';

alter function pg_catalog.time_send() owner to postgres;

create function pg_catalog.timetz_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_recv() is 'I/O';

alter function pg_catalog.timetz_recv() owner to postgres;

create function pg_catalog.timetz_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_send() is 'I/O';

alter function pg_catalog.timetz_send() owner to postgres;

create function pg_catalog.timestamp_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_recv() is 'I/O';

alter function pg_catalog.timestamp_recv() owner to postgres;

create function pg_catalog.timestamp_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_send() is 'I/O';

alter function pg_catalog.timestamp_send() owner to postgres;

create function pg_catalog.timestamptz_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_recv() is 'I/O';

alter function pg_catalog.timestamptz_recv() owner to postgres;

create function pg_catalog.timestamptz_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_send() is 'I/O';

alter function pg_catalog.timestamptz_send() owner to postgres;

create function pg_catalog.interval_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_recv() is 'I/O';

alter function pg_catalog.interval_recv() owner to postgres;

create function pg_catalog.interval_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_send() is 'I/O';

alter function pg_catalog.interval_send() owner to postgres;

create function pg_catalog.lseg_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_recv() is 'I/O';

alter function pg_catalog.lseg_recv() owner to postgres;

create function pg_catalog.lseg_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_send() is 'I/O';

alter function pg_catalog.lseg_send() owner to postgres;

create function pg_catalog.path_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_recv() is 'I/O';

alter function pg_catalog.path_recv() owner to postgres;

create function pg_catalog.path_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_send() is 'I/O';

alter function pg_catalog.path_send() owner to postgres;

create function pg_catalog.box_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_recv() is 'I/O';

alter function pg_catalog.box_recv() owner to postgres;

create function pg_catalog.box_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_send() is 'I/O';

alter function pg_catalog.box_send() owner to postgres;

create function pg_catalog.poly_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_recv() is 'I/O';

alter function pg_catalog.poly_recv() owner to postgres;

create function pg_catalog.poly_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_send() is 'I/O';

alter function pg_catalog.poly_send() owner to postgres;

create function pg_catalog.line_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_recv() is 'I/O';

alter function pg_catalog.line_recv() owner to postgres;

create function pg_catalog.line_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_send() is 'I/O';

alter function pg_catalog.line_send() owner to postgres;

create function pg_catalog.circle_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_recv() is 'I/O';

alter function pg_catalog.circle_recv() owner to postgres;

create function pg_catalog.circle_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_send() is 'I/O';

alter function pg_catalog.circle_send() owner to postgres;

create function pg_catalog.cash_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_recv() is 'I/O';

alter function pg_catalog.cash_recv() owner to postgres;

create function pg_catalog.cash_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_send() is 'I/O';

alter function pg_catalog.cash_send() owner to postgres;

create function pg_catalog.macaddr_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_recv() is 'I/O';

alter function pg_catalog.macaddr_recv() owner to postgres;

create function pg_catalog.macaddr_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_send() is 'I/O';

alter function pg_catalog.macaddr_send() owner to postgres;

create function pg_catalog.inet_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_recv() is 'I/O';

alter function pg_catalog.inet_recv() owner to postgres;

create function pg_catalog.inet_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_send() is 'I/O';

alter function pg_catalog.inet_send() owner to postgres;

create function pg_catalog.cidr_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_recv() is 'I/O';

alter function pg_catalog.cidr_recv() owner to postgres;

create function pg_catalog.cidr_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_send() is 'I/O';

alter function pg_catalog.cidr_send() owner to postgres;

create function pg_catalog.cstring_recv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_recv() is 'I/O';

alter function pg_catalog.cstring_recv() owner to postgres;

create function pg_catalog.cstring_send()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_send() is 'I/O';

alter function pg_catalog.cstring_send() owner to postgres;

create function pg_catalog.anyarray_recv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_recv() is 'I/O';

alter function pg_catalog.anyarray_recv() owner to postgres;

create function pg_catalog.anyarray_send()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_send() is 'I/O';

alter function pg_catalog.anyarray_send() owner to postgres;

create function pg_catalog.pg_get_ruledef()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_ruledef() is 'source text of a rule with pretty-print option';

alter function pg_catalog.pg_get_ruledef() owner to postgres;

create function pg_catalog.pg_get_indexdef()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_indexdef() is 'index description (full create statement or single expression) with pretty-print option';

alter function pg_catalog.pg_get_indexdef() owner to postgres;

create function pg_catalog.pg_get_constraintdef()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_constraintdef() is 'constraint description with pretty-print option';

alter function pg_catalog.pg_get_constraintdef() owner to postgres;

create function pg_catalog.pg_get_expr()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_expr() is 'deparse an encoded expression with pretty-print option';

alter function pg_catalog.pg_get_expr() owner to postgres;

create function pg_catalog.pg_prepared_statement()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_prepared_statement() is 'get the prepared statements for this session';

alter function pg_catalog.pg_prepared_statement() owner to postgres;

create function pg_catalog.pg_cursor()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_cursor() is 'get the open cursors for this session';

alter function pg_catalog.pg_cursor() owner to postgres;

create function pg_catalog.float8_var_pop()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_var_pop() is 'aggregate final function';

alter function pg_catalog.float8_var_pop() owner to postgres;

create function pg_catalog.float8_stddev_pop()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_stddev_pop() is 'aggregate final function';

alter function pg_catalog.float8_stddev_pop() owner to postgres;

create function pg_catalog.numeric_var_pop()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_var_pop() is 'aggregate final function';

alter function pg_catalog.numeric_var_pop() owner to postgres;

create function pg_catalog.booland_statefunc()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.booland_statefunc() is 'aggregate transition function';

alter function pg_catalog.booland_statefunc() owner to postgres;

create function pg_catalog.boolor_statefunc()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolor_statefunc() is 'aggregate transition function';

alter function pg_catalog.boolor_statefunc() owner to postgres;

create function pg_catalog.timestamp_lt_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_lt_timestamptz() is 'implementation of < operator';

alter function pg_catalog.timestamp_lt_timestamptz() owner to postgres;

create function pg_catalog.timestamp_le_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_le_timestamptz() is 'implementation of <= operator';

alter function pg_catalog.timestamp_le_timestamptz() owner to postgres;

create function pg_catalog.timestamp_eq_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_eq_timestamptz() is 'implementation of = operator';

alter function pg_catalog.timestamp_eq_timestamptz() owner to postgres;

create function pg_catalog.timestamp_gt_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_gt_timestamptz() is 'implementation of > operator';

alter function pg_catalog.timestamp_gt_timestamptz() owner to postgres;

create function pg_catalog.timestamp_ge_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ge_timestamptz() is 'implementation of >= operator';

alter function pg_catalog.timestamp_ge_timestamptz() owner to postgres;

create function pg_catalog.timestamp_ne_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ne_timestamptz() is 'implementation of <> operator';

alter function pg_catalog.timestamp_ne_timestamptz() owner to postgres;

create function pg_catalog.timestamp_cmp_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_cmp_timestamptz() is 'less-equal-greater';

alter function pg_catalog.timestamp_cmp_timestamptz() owner to postgres;

create function pg_catalog.timestamptz_lt_timestamp()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_lt_timestamp() is 'implementation of < operator';

alter function pg_catalog.timestamptz_lt_timestamp() owner to postgres;

create function pg_catalog.timestamptz_le_timestamp()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_le_timestamp() is 'implementation of <= operator';

alter function pg_catalog.timestamptz_le_timestamp() owner to postgres;

create function pg_catalog.timestamptz_eq_timestamp()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_eq_timestamp() is 'implementation of = operator';

alter function pg_catalog.timestamptz_eq_timestamp() owner to postgres;

create function pg_catalog.timestamptz_gt_timestamp()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_gt_timestamp() is 'implementation of > operator';

alter function pg_catalog.timestamptz_gt_timestamp() owner to postgres;

create function pg_catalog.timestamptz_ge_timestamp()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ge_timestamp() is 'implementation of >= operator';

alter function pg_catalog.timestamptz_ge_timestamp() owner to postgres;

create function pg_catalog.timestamptz_ne_timestamp()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ne_timestamp() is 'implementation of <> operator';

alter function pg_catalog.timestamptz_ne_timestamp() owner to postgres;

create function pg_catalog.timestamptz_cmp_timestamp()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_cmp_timestamp() is 'less-equal-greater';

alter function pg_catalog.timestamptz_cmp_timestamp() owner to postgres;

create function pg_catalog.interval_pl_date(interval, date) returns timestamp without time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_date() is 'implementation of + operator';

alter function pg_catalog.interval_pl_date() owner to postgres;

create function pg_catalog.interval_pl_timetz(interval, time with time zone) returns time with time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_timetz() is 'implementation of + operator';

alter function pg_catalog.interval_pl_timetz() owner to postgres;

create function pg_catalog.interval_pl_timestamp(interval, timestamp without time zone) returns timestamp without time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_timestamp() is 'implementation of + operator';

alter function pg_catalog.interval_pl_timestamp() owner to postgres;

create function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_timestamptz() is 'implementation of + operator';

alter function pg_catalog.interval_pl_timestamptz() owner to postgres;

create function pg_catalog.integer_pl_date(integer, date) returns date
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.integer_pl_date() is 'implementation of + operator';

alter function pg_catalog.integer_pl_date() owner to postgres;

create function pg_catalog.pg_tablespace_databases()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_tablespace_databases() is 'get OIDs of databases in a tablespace';

alter function pg_catalog.pg_tablespace_databases() owner to postgres;

create function pg_catalog.bool(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool(integer) is 'convert int4 to boolean';

alter function pg_catalog.bool(integer) owner to postgres;

create function pg_catalog.int4(boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(boolean) is 'convert boolean to int4';

alter function pg_catalog.int4(boolean) owner to postgres;

create function pg_catalog.lastval()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lastval() is 'current value from last used sequence';

alter function pg_catalog.lastval() owner to postgres;

create function pg_catalog.pg_postmaster_start_time()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_postmaster_start_time() is 'postmaster start time';

alter function pg_catalog.pg_postmaster_start_time() owner to postgres;

create function pg_catalog.pg_blocking_pids()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_blocking_pids() is 'get array of PIDs of sessions blocking specified backend PID from acquiring a heavyweight lock';

alter function pg_catalog.pg_blocking_pids() owner to postgres;

create function pg_catalog.box_below()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_below() is 'implementation of <<| operator';

alter function pg_catalog.box_below() owner to postgres;

create function pg_catalog.box_overbelow()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overbelow() is 'implementation of &<| operator';

alter function pg_catalog.box_overbelow() owner to postgres;

create function pg_catalog.box_overabove()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overabove() is 'implementation of |&> operator';

alter function pg_catalog.box_overabove() owner to postgres;

create function pg_catalog.box_above()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_above() is 'implementation of |>> operator';

alter function pg_catalog.box_above() owner to postgres;

create function pg_catalog.poly_below()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_below() is 'implementation of <<| operator';

alter function pg_catalog.poly_below() owner to postgres;

create function pg_catalog.poly_overbelow()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overbelow() is 'implementation of &<| operator';

alter function pg_catalog.poly_overbelow() owner to postgres;

create function pg_catalog.poly_overabove()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overabove() is 'implementation of |&> operator';

alter function pg_catalog.poly_overabove() owner to postgres;

create function pg_catalog.poly_above()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_above() is 'implementation of |>> operator';

alter function pg_catalog.poly_above() owner to postgres;

create function pg_catalog.gist_box_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_consistent() is 'GiST support';

alter function pg_catalog.gist_box_consistent() owner to postgres;

create function pg_catalog.float8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8() is 'convert jsonb to float8';

alter function pg_catalog.float8() owner to postgres;

create function pg_catalog.gist_box_penalty()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_penalty() is 'GiST support';

alter function pg_catalog.gist_box_penalty() owner to postgres;

create function pg_catalog.gist_box_picksplit()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_picksplit() is 'GiST support';

alter function pg_catalog.gist_box_picksplit() owner to postgres;

create function pg_catalog.gist_box_union()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_union() is 'GiST support';

alter function pg_catalog.gist_box_union() owner to postgres;

create function pg_catalog.gist_box_same()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_same() is 'GiST support';

alter function pg_catalog.gist_box_same() owner to postgres;

create function pg_catalog.gist_poly_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_poly_consistent() is 'GiST support';

alter function pg_catalog.gist_poly_consistent() owner to postgres;

create function pg_catalog.gist_poly_compress()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_poly_compress() is 'GiST support';

alter function pg_catalog.gist_poly_compress() owner to postgres;

create function pg_catalog.circle_overbelow()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overbelow() is 'implementation of &<| operator';

alter function pg_catalog.circle_overbelow() owner to postgres;

create function pg_catalog.circle_overabove()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overabove() is 'implementation of |&> operator';

alter function pg_catalog.circle_overabove() owner to postgres;

create function pg_catalog.gist_circle_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_circle_consistent() is 'GiST support';

alter function pg_catalog.gist_circle_consistent() owner to postgres;

create function pg_catalog.gist_circle_compress()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_circle_compress() is 'GiST support';

alter function pg_catalog.gist_circle_compress() owner to postgres;

create function pg_catalog.numeric_stddev_pop()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_stddev_pop() is 'aggregate final function';

alter function pg_catalog.numeric_stddev_pop() owner to postgres;

create function pg_catalog.domain_in()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.domain_in() is 'I/O';

alter function pg_catalog.domain_in() owner to postgres;

create function pg_catalog.domain_recv()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.domain_recv() is 'I/O';

alter function pg_catalog.domain_recv() owner to postgres;

create function pg_catalog.pg_timezone_abbrevs()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_timezone_abbrevs() is 'get the available time zone abbreviations';

alter function pg_catalog.pg_timezone_abbrevs() owner to postgres;

create function pg_catalog.xmlexists()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlexists() is 'test XML value against XPath expression';

alter function pg_catalog.xmlexists() owner to postgres;

create function pg_catalog.pg_reload_conf()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_reload_conf() is 'reload configuration files';

alter function pg_catalog.pg_reload_conf() owner to postgres;

create function pg_catalog.pg_rotate_logfile()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_rotate_logfile() is 'rotate log file';

alter function pg_catalog.pg_rotate_logfile() owner to postgres;

create function pg_catalog.pg_stat_file()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_file() is 'get information about file';

alter function pg_catalog.pg_stat_file() owner to postgres;

create function pg_catalog.pg_read_file(bigint, bigint)
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file(bigint, bigint) is 'read text from a file';

alter function pg_catalog.pg_read_file(bigint, bigint) owner to postgres;

create function pg_catalog.pg_ls_dir()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ls_dir() is 'list all files in a directory';

alter function pg_catalog.pg_ls_dir() owner to postgres;

create function pg_catalog.pg_sleep()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sleep() is 'sleep for the specified time in seconds';

alter function pg_catalog.pg_sleep() owner to postgres;

create function pg_catalog.inetnot()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetnot() is 'implementation of ~ operator';

alter function pg_catalog.inetnot() owner to postgres;

create function pg_catalog.inetand()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetand() is 'implementation of & operator';

alter function pg_catalog.inetand() owner to postgres;

create function pg_catalog.inetor()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetor() is 'implementation of | operator';

alter function pg_catalog.inetor() owner to postgres;

create function pg_catalog.inetpl()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetpl() is 'implementation of + operator';

alter function pg_catalog.inetpl() owner to postgres;

create function pg_catalog.int8pl_inet(bigint, inet) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8pl_inet() is 'implementation of + operator';

alter function pg_catalog.int8pl_inet() owner to postgres;

create function pg_catalog.inetmi_int8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetmi_int8() is 'implementation of - operator';

alter function pg_catalog.inetmi_int8() owner to postgres;

create function pg_catalog.inetmi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetmi() is 'implementation of - operator';

alter function pg_catalog.inetmi() owner to postgres;

create function pg_catalog.transaction_timestamp()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.transaction_timestamp() is 'current transaction time';

alter function pg_catalog.transaction_timestamp() owner to postgres;

create function pg_catalog.statement_timestamp()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.statement_timestamp() is 'current statement time';

alter function pg_catalog.statement_timestamp() owner to postgres;

create function pg_catalog.clock_timestamp()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.clock_timestamp() is 'current clock time';

alter function pg_catalog.clock_timestamp() owner to postgres;

create function pg_catalog.gin_cmp_prefix()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_cmp_prefix() is 'GIN tsvector support';

alter function pg_catalog.gin_cmp_prefix() owner to postgres;

create function pg_catalog.pg_has_role(name, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(name, text) is 'user privilege on role by username, role name';

alter function pg_catalog.pg_has_role(name, text) owner to postgres;

create function pg_catalog.pg_has_role(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(name, oid, text) is 'user privilege on role by username, role oid';

alter function pg_catalog.pg_has_role(name, oid, text) owner to postgres;

create function pg_catalog.pg_has_role()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role() is 'user privilege on role by user oid, role name';

alter function pg_catalog.pg_has_role() owner to postgres;

create function pg_catalog.pg_has_role()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role() is 'user privilege on role by user oid, role oid';

alter function pg_catalog.pg_has_role() owner to postgres;

create function pg_catalog.pg_has_role(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(text) is 'current user privilege on role by role name';

alter function pg_catalog.pg_has_role(text) owner to postgres;

create function pg_catalog.pg_has_role(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(oid, text) is 'current user privilege on role by role oid';

alter function pg_catalog.pg_has_role(oid, text) owner to postgres;

create function pg_catalog.justify_interval()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.justify_interval() is 'promote groups of 24 hours to numbers of days and promote groups of 30 days to numbers of months';

alter function pg_catalog.justify_interval() owner to postgres;

create function pg_catalog.pg_get_triggerdef()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_triggerdef() is 'trigger description with pretty-print option';

alter function pg_catalog.pg_get_triggerdef() owner to postgres;

create function pg_catalog.asind()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.asind() is 'arcsine, degrees';

alter function pg_catalog.asind() owner to postgres;

create function pg_catalog.acosd()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acosd() is 'arccosine, degrees';

alter function pg_catalog.acosd() owner to postgres;

create function pg_catalog.atand()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atand() is 'arctangent, degrees';

alter function pg_catalog.atand() owner to postgres;

create function pg_catalog.atan2d()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atan2d() is 'arctangent, two arguments, degrees';

alter function pg_catalog.atan2d() owner to postgres;

create function pg_catalog.sind()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sind() is 'sine, degrees';

alter function pg_catalog.sind() owner to postgres;

create function pg_catalog.cosd()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cosd() is 'cosine, degrees';

alter function pg_catalog.cosd() owner to postgres;

create function pg_catalog.tand()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tand() is 'tangent, degrees';

alter function pg_catalog.tand() owner to postgres;

create function pg_catalog.cotd()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cotd() is 'cotangent, degrees';

alter function pg_catalog.cotd() owner to postgres;

create function pg_catalog.pg_stop_backup()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stop_backup() is 'finish taking an online backup';

alter function pg_catalog.pg_stop_backup() owner to postgres;

create function pg_catalog.numeric_avg_serialize()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_serialize() is 'aggregate serial function';

alter function pg_catalog.numeric_avg_serialize() owner to postgres;

create function pg_catalog.numeric_avg_deserialize()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_deserialize() is 'aggregate deserial function';

alter function pg_catalog.numeric_avg_deserialize() owner to postgres;

create function pg_catalog.ginarrayextract()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarrayextract() is 'GIN array support';

alter function pg_catalog.ginarrayextract() owner to postgres;

create function pg_catalog.ginarrayconsistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarrayconsistent() is 'GIN array support';

alter function pg_catalog.ginarrayconsistent() owner to postgres;

create function pg_catalog.int8_avg_accum()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_accum() is 'aggregate transition function';

alter function pg_catalog.int8_avg_accum() owner to postgres;

create function pg_catalog.arrayoverlap()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arrayoverlap() is 'implementation of && operator';

alter function pg_catalog.arrayoverlap() owner to postgres;

create function pg_catalog.arraycontains()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontains() is 'implementation of @> operator';

alter function pg_catalog.arraycontains() owner to postgres;

create function pg_catalog.arraycontained()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontained() is 'implementation of <@ operator';

alter function pg_catalog.arraycontained() owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_returned()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_returned() is 'statistics: tuples returned for database';

alter function pg_catalog.pg_stat_get_db_tuples_returned() owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_fetched()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_fetched() is 'statistics: tuples fetched for database';

alter function pg_catalog.pg_stat_get_db_tuples_fetched() owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_inserted()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_inserted() is 'statistics: tuples inserted in database';

alter function pg_catalog.pg_stat_get_db_tuples_inserted() owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_updated()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_updated() is 'statistics: tuples updated in database';

alter function pg_catalog.pg_stat_get_db_tuples_updated() owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_deleted()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_deleted() is 'statistics: tuples deleted in database';

alter function pg_catalog.pg_stat_get_db_tuples_deleted() owner to postgres;

create function pg_catalog.regexp_matches()
    immutable
    strict
    parallel safe
    cost 1
    rows 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_matches() is 'find match(es) for regexp';

alter function pg_catalog.regexp_matches() owner to postgres;

create function pg_catalog.regexp_matches()
    immutable
    strict
    parallel safe
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_matches() is 'find match(es) for regexp';

alter function pg_catalog.regexp_matches() owner to postgres;

create function pg_catalog.regexp_split_to_table()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_split_to_table() is 'split string by pattern';

alter function pg_catalog.regexp_split_to_table() owner to postgres;

create function pg_catalog.regexp_split_to_table()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_split_to_table() is 'split string by pattern';

alter function pg_catalog.regexp_split_to_table() owner to postgres;

create function pg_catalog.regexp_split_to_array()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_split_to_array() is 'split string by pattern';

alter function pg_catalog.regexp_split_to_array() owner to postgres;

create function pg_catalog.regexp_split_to_array()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_split_to_array() is 'split string by pattern';

alter function pg_catalog.regexp_split_to_array() owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints() is 'statistics: number of timed checkpoints started by the bgwriter';

alter function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints() owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints() is 'statistics: number of backend requested checkpoints started by the bgwriter';

alter function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints() owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints() is 'statistics: number of buffers written by the bgwriter during checkpoints';

alter function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints() owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_buf_written_clean()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_buf_written_clean() is 'statistics: number of buffers written by the bgwriter for cleaning dirty buffers';

alter function pg_catalog.pg_stat_get_bgwriter_buf_written_clean() owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean() is 'statistics: number of times the bgwriter stopped processing when it had written too many buffers while cleaning';

alter function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean() owner to postgres;

create function pg_catalog.ginqueryarrayextract()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginqueryarrayextract() is 'GIN array support';

alter function pg_catalog.ginqueryarrayextract() owner to postgres;

create function pg_catalog.pg_stat_get_buf_written_backend()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_buf_written_backend() is 'statistics: number of buffers written by backends';

alter function pg_catalog.pg_stat_get_buf_written_backend() owner to postgres;

create function pg_catalog.anynonarray_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anynonarray_in() is 'I/O';

alter function pg_catalog.anynonarray_in() owner to postgres;

create function pg_catalog.anynonarray_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anynonarray_out() is 'I/O';

alter function pg_catalog.anynonarray_out() owner to postgres;

create function pg_catalog.pg_stat_get_last_vacuum_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_vacuum_time() is 'statistics: last manual vacuum time for a table';

alter function pg_catalog.pg_stat_get_last_vacuum_time() owner to postgres;

create function pg_catalog.pg_stat_get_last_autovacuum_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_autovacuum_time() is 'statistics: last auto vacuum time for a table';

alter function pg_catalog.pg_stat_get_last_autovacuum_time() owner to postgres;

create function pg_catalog.pg_stat_get_last_analyze_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_analyze_time() is 'statistics: last manual analyze time for a table';

alter function pg_catalog.pg_stat_get_last_analyze_time() owner to postgres;

create function pg_catalog.pg_stat_get_last_autoanalyze_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_autoanalyze_time() is 'statistics: last auto analyze time for a table';

alter function pg_catalog.pg_stat_get_last_autoanalyze_time() owner to postgres;

create function pg_catalog.int8_avg_combine()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_combine() is 'aggregate combine function';

alter function pg_catalog.int8_avg_combine() owner to postgres;

create function pg_catalog.int8_avg_serialize()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_serialize() is 'aggregate serial function';

alter function pg_catalog.int8_avg_serialize() owner to postgres;

create function pg_catalog.int8_avg_deserialize()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_deserialize() is 'aggregate deserial function';

alter function pg_catalog.int8_avg_deserialize() owner to postgres;

create function pg_catalog.pg_stat_get_backend_wait_event_type()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_wait_event_type() is 'statistics: wait event type on which backend is currently waiting';

alter function pg_catalog.pg_stat_get_backend_wait_event_type() owner to postgres;

create function pg_catalog.tidgt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidgt() is 'implementation of > operator';

alter function pg_catalog.tidgt() owner to postgres;

create function pg_catalog.tidlt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidlt() is 'implementation of < operator';

alter function pg_catalog.tidlt() owner to postgres;

create function pg_catalog.tidge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidge() is 'implementation of >= operator';

alter function pg_catalog.tidge() owner to postgres;

create function pg_catalog.tidle()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidle() is 'implementation of <= operator';

alter function pg_catalog.tidle() owner to postgres;

create function pg_catalog.bttidcmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttidcmp() is 'less-equal-greater';

alter function pg_catalog.bttidcmp() owner to postgres;

create function pg_catalog.tidlarger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidlarger() is 'larger of two';

alter function pg_catalog.tidlarger() owner to postgres;

create function pg_catalog.tidsmaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidsmaller() is 'smaller of two';

alter function pg_catalog.tidsmaller() owner to postgres;

create function pg_catalog.int8inc_any()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8inc_any() is 'increment, ignores second argument';

alter function pg_catalog.int8inc_any() owner to postgres;

create function pg_catalog.int8inc_float8_float8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8inc_float8_float8() is 'aggregate transition function';

alter function pg_catalog.int8inc_float8_float8() owner to postgres;

create function pg_catalog.float8_regr_accum()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_accum() is 'aggregate transition function';

alter function pg_catalog.float8_regr_accum() owner to postgres;

create function pg_catalog.float8_regr_sxx()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_sxx() is 'aggregate final function';

alter function pg_catalog.float8_regr_sxx() owner to postgres;

create function pg_catalog.float8_regr_syy()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_syy() is 'aggregate final function';

alter function pg_catalog.float8_regr_syy() owner to postgres;

create function pg_catalog.float8_regr_sxy()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_sxy() is 'aggregate final function';

alter function pg_catalog.float8_regr_sxy() owner to postgres;

create function pg_catalog.float8_regr_avgx()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_avgx() is 'aggregate final function';

alter function pg_catalog.float8_regr_avgx() owner to postgres;

create function pg_catalog.float8_regr_avgy()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_avgy() is 'aggregate final function';

alter function pg_catalog.float8_regr_avgy() owner to postgres;

create function pg_catalog.float8_regr_r2()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_r2() is 'aggregate final function';

alter function pg_catalog.float8_regr_r2() owner to postgres;

create function pg_catalog.float8_regr_slope()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_slope() is 'aggregate final function';

alter function pg_catalog.float8_regr_slope() owner to postgres;

create function pg_catalog.float8_regr_intercept()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_intercept() is 'aggregate final function';

alter function pg_catalog.float8_regr_intercept() owner to postgres;

create function pg_catalog.float8_covar_pop()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_covar_pop() is 'aggregate final function';

alter function pg_catalog.float8_covar_pop() owner to postgres;

create function pg_catalog.float8_covar_samp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_covar_samp() is 'aggregate final function';

alter function pg_catalog.float8_covar_samp() owner to postgres;

create function pg_catalog.float8_corr()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_corr() is 'aggregate final function';

alter function pg_catalog.float8_corr() owner to postgres;

create function pg_catalog.pg_stat_get_db_blk_read_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blk_read_time() is 'statistics: block read time, in milliseconds';

alter function pg_catalog.pg_stat_get_db_blk_read_time() owner to postgres;

create function pg_catalog.pg_stat_get_db_blk_write_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blk_write_time() is 'statistics: block write time, in milliseconds';

alter function pg_catalog.pg_stat_get_db_blk_write_time() owner to postgres;

create function pg_catalog.pg_switch_wal()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_switch_wal() is 'switch to new wal file';

alter function pg_catalog.pg_switch_wal() owner to postgres;

create function pg_catalog.pg_current_wal_lsn()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_wal_lsn() is 'current wal write location';

alter function pg_catalog.pg_current_wal_lsn() owner to postgres;

create function pg_catalog.pg_walfile_name_offset()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_walfile_name_offset() is 'wal filename and byte offset, given a wal location';

alter function pg_catalog.pg_walfile_name_offset() owner to postgres;

create function pg_catalog.pg_walfile_name()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_walfile_name() is 'wal filename, given a wal location';

alter function pg_catalog.pg_walfile_name() owner to postgres;

create function pg_catalog.pg_current_wal_insert_lsn()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_wal_insert_lsn() is 'current wal insert location';

alter function pg_catalog.pg_current_wal_insert_lsn() owner to postgres;

create function pg_catalog.pg_stat_get_backend_wait_event()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_wait_event() is 'statistics: wait event on which backend is currently waiting';

alter function pg_catalog.pg_stat_get_backend_wait_event() owner to postgres;

create function pg_catalog.pg_my_temp_schema()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_my_temp_schema() is 'get OID of current session''s temp schema, if any';

alter function pg_catalog.pg_my_temp_schema() owner to postgres;

create function pg_catalog.pg_is_other_temp_schema()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_other_temp_schema() is 'is schema another session''s temp schema?';

alter function pg_catalog.pg_is_other_temp_schema() owner to postgres;

create function pg_catalog.pg_timezone_names()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_timezone_names() is 'get the available time zone names';

alter function pg_catalog.pg_timezone_names() owner to postgres;

create function pg_catalog.pg_stat_get_backend_xact_start()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_xact_start() is 'statistics: start time for backend''s current transaction';

alter function pg_catalog.pg_stat_get_backend_xact_start() owner to postgres;

create function pg_catalog.numeric_avg_accum()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_accum() is 'aggregate transition function';

alter function pg_catalog.numeric_avg_accum() owner to postgres;

create function pg_catalog.pg_stat_get_buf_alloc()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_buf_alloc() is 'statistics: number of buffer allocations';

alter function pg_catalog.pg_stat_get_buf_alloc() owner to postgres;

create function pg_catalog.pg_stat_get_live_tuples()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_live_tuples() is 'statistics: number of live tuples';

alter function pg_catalog.pg_stat_get_live_tuples() owner to postgres;

create function pg_catalog.pg_stat_get_dead_tuples()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_dead_tuples() is 'statistics: number of dead tuples';

alter function pg_catalog.pg_stat_get_dead_tuples() owner to postgres;

create function pg_catalog.pg_advisory_lock()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock() is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_lock() owner to postgres;

create function pg_catalog.pg_advisory_lock_shared()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock_shared() is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_lock_shared() owner to postgres;

create function pg_catalog.pg_try_advisory_lock()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock() is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock() owner to postgres;

create function pg_catalog.pg_try_advisory_lock_shared()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock_shared() is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock_shared() owner to postgres;

create function pg_catalog.pg_advisory_unlock()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock() is 'release exclusive advisory lock';

alter function pg_catalog.pg_advisory_unlock() owner to postgres;

create function pg_catalog.pg_advisory_unlock_shared()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock_shared() is 'release shared advisory lock';

alter function pg_catalog.pg_advisory_unlock_shared() owner to postgres;

create function pg_catalog.pg_advisory_lock()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock() is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_lock() owner to postgres;

create function pg_catalog.pg_advisory_lock_shared()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock_shared() is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_lock_shared() owner to postgres;

create function pg_catalog.pg_try_advisory_lock()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock() is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock() owner to postgres;

create function pg_catalog.pg_try_advisory_lock_shared()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock_shared() is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock_shared() owner to postgres;

create function pg_catalog.pg_advisory_unlock()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock() is 'release exclusive advisory lock';

alter function pg_catalog.pg_advisory_unlock() owner to postgres;

create function pg_catalog.pg_advisory_unlock_shared()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock_shared() is 'release shared advisory lock';

alter function pg_catalog.pg_advisory_unlock_shared() owner to postgres;

create function pg_catalog.pg_advisory_unlock_all()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock_all() is 'release all advisory locks';

alter function pg_catalog.pg_advisory_unlock_all() owner to postgres;

create function pg_catalog.xml_in()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_in() is 'I/O';

alter function pg_catalog.xml_in() owner to postgres;

create function pg_catalog.xml_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_out() is 'I/O';

alter function pg_catalog.xml_out() owner to postgres;

create function pg_catalog.xmlcomment()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlcomment() is 'generate XML comment';

alter function pg_catalog.xmlcomment() owner to postgres;

create function pg_catalog.xml()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml() is 'perform a non-validating parse of a character string to produce an XML value';

alter function pg_catalog.xml() owner to postgres;

create function pg_catalog.xmlvalidate()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlvalidate() is 'validate an XML value';

alter function pg_catalog.xmlvalidate() owner to postgres;

create function pg_catalog.xml_recv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_recv() is 'I/O';

alter function pg_catalog.xml_recv() owner to postgres;

create function pg_catalog.xml_send()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_send() is 'I/O';

alter function pg_catalog.xml_send() owner to postgres;

create function pg_catalog.xmlconcat2()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlconcat2() is 'aggregate transition function';

alter function pg_catalog.xmlconcat2() owner to postgres;

create function pg_catalog.varbittypmodin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbittypmodin() is 'I/O typmod';

alter function pg_catalog.varbittypmodin() owner to postgres;

create function pg_catalog.intervaltypmodin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.intervaltypmodin() is 'I/O typmod';

alter function pg_catalog.intervaltypmodin() owner to postgres;

create function pg_catalog.intervaltypmodout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.intervaltypmodout() is 'I/O typmod';

alter function pg_catalog.intervaltypmodout() owner to postgres;

create function pg_catalog.timestamptypmodin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptypmodin() is 'I/O typmod';

alter function pg_catalog.timestamptypmodin() owner to postgres;

create function pg_catalog.timestamptypmodout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptypmodout() is 'I/O typmod';

alter function pg_catalog.timestamptypmodout() owner to postgres;

create function pg_catalog.timestamptztypmodin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptztypmodin() is 'I/O typmod';

alter function pg_catalog.timestamptztypmodin() owner to postgres;

create function pg_catalog.timestamptztypmodout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptztypmodout() is 'I/O typmod';

alter function pg_catalog.timestamptztypmodout() owner to postgres;

create function pg_catalog.timetypmodin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetypmodin() is 'I/O typmod';

alter function pg_catalog.timetypmodin() owner to postgres;

create function pg_catalog.timetypmodout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetypmodout() is 'I/O typmod';

alter function pg_catalog.timetypmodout() owner to postgres;

create function pg_catalog.timetztypmodin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetztypmodin() is 'I/O typmod';

alter function pg_catalog.timetztypmodin() owner to postgres;

create function pg_catalog.timetztypmodout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetztypmodout() is 'I/O typmod';

alter function pg_catalog.timetztypmodout() owner to postgres;

create function pg_catalog.bpchartypmodin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchartypmodin() is 'I/O typmod';

alter function pg_catalog.bpchartypmodin() owner to postgres;

create function pg_catalog.bpchartypmodout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchartypmodout() is 'I/O typmod';

alter function pg_catalog.bpchartypmodout() owner to postgres;

create function pg_catalog.varchartypmodin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchartypmodin() is 'I/O typmod';

alter function pg_catalog.varchartypmodin() owner to postgres;

create function pg_catalog.varchartypmodout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchartypmodout() is 'I/O typmod';

alter function pg_catalog.varchartypmodout() owner to postgres;

create function pg_catalog.numerictypmodin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numerictypmodin() is 'I/O typmod';

alter function pg_catalog.numerictypmodin() owner to postgres;

create function pg_catalog.numerictypmodout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numerictypmodout() is 'I/O typmod';

alter function pg_catalog.numerictypmodout() owner to postgres;

create function pg_catalog.bittypmodin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bittypmodin() is 'I/O typmod';

alter function pg_catalog.bittypmodin() owner to postgres;

create function pg_catalog.bittypmodout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bittypmodout() is 'I/O typmod';

alter function pg_catalog.bittypmodout() owner to postgres;

create function pg_catalog.varbittypmodout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbittypmodout() is 'I/O typmod';

alter function pg_catalog.varbittypmodout() owner to postgres;

create function pg_catalog.text(xml)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(xml) is 'serialize an XML value to a character string';

alter function pg_catalog.text(xml) owner to postgres;

create function pg_catalog.table_to_xml()
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_to_xml() is 'map table contents to XML';

alter function pg_catalog.table_to_xml() owner to postgres;

create function pg_catalog.query_to_xml()
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.query_to_xml() is 'map query result to XML';

alter function pg_catalog.query_to_xml() owner to postgres;

create function pg_catalog.cursor_to_xml()
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cursor_to_xml() is 'map rows from cursor to XML';

alter function pg_catalog.cursor_to_xml() owner to postgres;

create function pg_catalog.table_to_xmlschema()
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_to_xmlschema() is 'map table structure to XML Schema';

alter function pg_catalog.table_to_xmlschema() owner to postgres;

create function pg_catalog.query_to_xmlschema()
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.query_to_xmlschema() is 'map query result structure to XML Schema';

alter function pg_catalog.query_to_xmlschema() owner to postgres;

create function pg_catalog.cursor_to_xmlschema()
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cursor_to_xmlschema() is 'map cursor structure to XML Schema';

alter function pg_catalog.cursor_to_xmlschema() owner to postgres;

create function pg_catalog.table_to_xml_and_xmlschema()
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_to_xml_and_xmlschema() is 'map table contents and structure to XML and XML Schema';

alter function pg_catalog.table_to_xml_and_xmlschema() owner to postgres;

create function pg_catalog.query_to_xml_and_xmlschema()
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.query_to_xml_and_xmlschema() is 'map query result and structure to XML and XML Schema';

alter function pg_catalog.query_to_xml_and_xmlschema() owner to postgres;

create function pg_catalog.xpath(text, xml) returns xml[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xpath(text[]) is 'evaluate XPath expression, with namespaces support';

alter function pg_catalog.xpath(text[]) owner to postgres;

create function pg_catalog.xpath(text, xml) returns xml[]
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.xpath() is 'evaluate XPath expression';

alter function pg_catalog.xpath() owner to postgres;

create function pg_catalog.schema_to_xml()
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.schema_to_xml() is 'map schema contents to XML';

alter function pg_catalog.schema_to_xml() owner to postgres;

create function pg_catalog.schema_to_xmlschema()
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.schema_to_xmlschema() is 'map schema structure to XML Schema';

alter function pg_catalog.schema_to_xmlschema() owner to postgres;

create function pg_catalog.schema_to_xml_and_xmlschema()
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.schema_to_xml_and_xmlschema() is 'map schema contents and structure to XML and XML Schema';

alter function pg_catalog.schema_to_xml_and_xmlschema() owner to postgres;

create function pg_catalog.database_to_xml()
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.database_to_xml() is 'map database contents to XML';

alter function pg_catalog.database_to_xml() owner to postgres;

create function pg_catalog.database_to_xmlschema()
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.database_to_xmlschema() is 'map database structure to XML Schema';

alter function pg_catalog.database_to_xmlschema() owner to postgres;

create function pg_catalog.database_to_xml_and_xmlschema()
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.database_to_xml_and_xmlschema() is 'map database contents and structure to XML and XML Schema';

alter function pg_catalog.database_to_xml_and_xmlschema() owner to postgres;

create function pg_catalog.txid_snapshot_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_in() is 'I/O';

alter function pg_catalog.txid_snapshot_in() owner to postgres;

create function pg_catalog.txid_snapshot_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_out() is 'I/O';

alter function pg_catalog.txid_snapshot_out() owner to postgres;

create function pg_catalog.txid_snapshot_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_recv() is 'I/O';

alter function pg_catalog.txid_snapshot_recv() owner to postgres;

create function pg_catalog.txid_snapshot_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_send() is 'I/O';

alter function pg_catalog.txid_snapshot_send() owner to postgres;

create function pg_catalog.txid_current()
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_current() is 'get current transaction ID';

alter function pg_catalog.txid_current() owner to postgres;

create function pg_catalog.txid_current_snapshot()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_current_snapshot() is 'get current snapshot';

alter function pg_catalog.txid_current_snapshot() owner to postgres;

create function pg_catalog.txid_snapshot_xmin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_xmin() is 'get xmin of snapshot';

alter function pg_catalog.txid_snapshot_xmin() owner to postgres;

create function pg_catalog.txid_snapshot_xmax()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_xmax() is 'get xmax of snapshot';

alter function pg_catalog.txid_snapshot_xmax() owner to postgres;

create function pg_catalog.txid_snapshot_xip()
    immutable
    strict
    parallel safe
    cost 1
    rows 50
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_xip() is 'get set of in-progress txids in snapshot';

alter function pg_catalog.txid_snapshot_xip() owner to postgres;

create function pg_catalog.txid_visible_in_snapshot()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_visible_in_snapshot() is 'is txid visible in snapshot?';

alter function pg_catalog.txid_visible_in_snapshot() owner to postgres;

create function pg_catalog.uuid_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_in() is 'I/O';

alter function pg_catalog.uuid_in() owner to postgres;

create function pg_catalog.uuid_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_out() is 'I/O';

alter function pg_catalog.uuid_out() owner to postgres;

create function pg_catalog.uuid_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_lt() is 'implementation of < operator';

alter function pg_catalog.uuid_lt() owner to postgres;

create function pg_catalog.uuid_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_le() is 'implementation of <= operator';

alter function pg_catalog.uuid_le() owner to postgres;

create function pg_catalog.uuid_eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_eq() is 'implementation of = operator';

alter function pg_catalog.uuid_eq() owner to postgres;

create function pg_catalog.uuid_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_ge() is 'implementation of >= operator';

alter function pg_catalog.uuid_ge() owner to postgres;

create function pg_catalog.uuid_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_gt() is 'implementation of > operator';

alter function pg_catalog.uuid_gt() owner to postgres;

create function pg_catalog.uuid_ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_ne() is 'implementation of <> operator';

alter function pg_catalog.uuid_ne() owner to postgres;

create function pg_catalog.uuid_cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_cmp() is 'less-equal-greater';

alter function pg_catalog.uuid_cmp() owner to postgres;

create function pg_catalog.uuid_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_recv() is 'I/O';

alter function pg_catalog.uuid_recv() owner to postgres;

create function pg_catalog.uuid_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_send() is 'I/O';

alter function pg_catalog.uuid_send() owner to postgres;

create function pg_catalog.uuid_hash()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_hash() is 'hash';

alter function pg_catalog.uuid_hash() owner to postgres;

create function pg_catalog.text(boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(boolean) is 'convert boolean to text';

alter function pg_catalog.text(boolean) owner to postgres;

create function pg_catalog.pg_stat_get_function_calls()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_function_calls() is 'statistics: number of function calls';

alter function pg_catalog.pg_stat_get_function_calls() owner to postgres;

create function pg_catalog.pg_stat_get_function_total_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_function_total_time() is 'statistics: total execution time of function, in milliseconds';

alter function pg_catalog.pg_stat_get_function_total_time() owner to postgres;

create function pg_catalog.pg_stat_get_function_self_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_function_self_time() is 'statistics: self execution time of function, in milliseconds';

alter function pg_catalog.pg_stat_get_function_self_time() owner to postgres;

create function pg_catalog.record_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_eq() is 'implementation of = operator';

alter function pg_catalog.record_eq() owner to postgres;

create function pg_catalog.record_ne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_ne() is 'implementation of <> operator';

alter function pg_catalog.record_ne() owner to postgres;

create function pg_catalog.record_lt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_lt() is 'implementation of < operator';

alter function pg_catalog.record_lt() owner to postgres;

create function pg_catalog.record_gt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_gt() is 'implementation of > operator';

alter function pg_catalog.record_gt() owner to postgres;

create function pg_catalog.record_le()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_le() is 'implementation of <= operator';

alter function pg_catalog.record_le() owner to postgres;

create function pg_catalog.record_ge()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_ge() is 'implementation of >= operator';

alter function pg_catalog.record_ge() owner to postgres;

create function pg_catalog.btrecordcmp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrecordcmp() is 'less-equal-greater';

alter function pg_catalog.btrecordcmp() owner to postgres;

create function pg_catalog.pg_table_size()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_table_size() is 'disk space usage for the specified table, including TOAST, free space and visibility map';

alter function pg_catalog.pg_table_size() owner to postgres;

create function pg_catalog.pg_indexes_size()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_indexes_size() is 'disk space usage for all indexes attached to the specified table';

alter function pg_catalog.pg_indexes_size() owner to postgres;

create function pg_catalog.pg_relation_filenode()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_filenode() is 'filenode identifier of relation';

alter function pg_catalog.pg_relation_filenode() owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(name, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(name, text) is 'user privilege on foreign data wrapper by username, foreign data wrapper name';

alter function pg_catalog.has_foreign_data_wrapper_privilege(name, text) owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text) is 'user privilege on foreign data wrapper by username, foreign data wrapper oid';

alter function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege() is 'user privilege on foreign data wrapper by user oid, foreign data wrapper name';

alter function pg_catalog.has_foreign_data_wrapper_privilege() owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege() is 'user privilege on foreign data wrapper by user oid, foreign data wrapper oid';

alter function pg_catalog.has_foreign_data_wrapper_privilege() owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(text) is 'current user privilege on foreign data wrapper by foreign data wrapper name';

alter function pg_catalog.has_foreign_data_wrapper_privilege(text) owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, text) is 'current user privilege on foreign data wrapper by foreign data wrapper oid';

alter function pg_catalog.has_foreign_data_wrapper_privilege(oid, text) owner to postgres;

create function pg_catalog.has_server_privilege(name, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(name, text) is 'user privilege on server by username, server name';

alter function pg_catalog.has_server_privilege(name, text) owner to postgres;

create function pg_catalog.has_server_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(name, oid, text) is 'user privilege on server by username, server oid';

alter function pg_catalog.has_server_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_server_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege() is 'user privilege on server by user oid, server name';

alter function pg_catalog.has_server_privilege() owner to postgres;

create function pg_catalog.has_server_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege() is 'user privilege on server by user oid, server oid';

alter function pg_catalog.has_server_privilege() owner to postgres;

create function pg_catalog.has_server_privilege(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(text) is 'current user privilege on server by server name';

alter function pg_catalog.has_server_privilege(text) owner to postgres;

create function pg_catalog.has_server_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(oid, text) is 'current user privilege on server by server oid';

alter function pg_catalog.has_server_privilege(oid, text) owner to postgres;

create function pg_catalog.has_column_privilege(name, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(name, text, text) is 'user privilege on column by username, rel name, col name';

alter function pg_catalog.has_column_privilege(name, text, text) owner to postgres;

create function pg_catalog.has_column_privilege(name, smallint, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(name, smallint, text) is 'user privilege on column by username, rel name, col attnum';

alter function pg_catalog.has_column_privilege(name, smallint, text) owner to postgres;

create function pg_catalog.has_column_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(name, oid, text) is 'user privilege on column by username, rel oid, col name';

alter function pg_catalog.has_column_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_column_privilege(name, oid, smallint, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(name, oid, smallint, text) is 'user privilege on column by username, rel oid, col attnum';

alter function pg_catalog.has_column_privilege(name, oid, smallint, text) owner to postgres;

create function pg_catalog.has_column_privilege(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(text, text) is 'current user privilege on column by rel name, col name';

alter function pg_catalog.has_column_privilege(text, text) owner to postgres;

create function pg_catalog.has_column_privilege(text, smallint)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(text, smallint) is 'current user privilege on column by rel name, col attnum';

alter function pg_catalog.has_column_privilege(text, smallint) owner to postgres;

create function pg_catalog.has_column_privilege(oid, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(oid, text, text) is 'current user privilege on column by rel oid, col name';

alter function pg_catalog.has_column_privilege(oid, text, text) owner to postgres;

create function pg_catalog.has_column_privilege(oid, smallint)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(oid, smallint) is 'current user privilege on column by rel oid, col attnum';

alter function pg_catalog.has_column_privilege(oid, smallint) owner to postgres;

create function pg_catalog.has_any_column_privilege(name, text)
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(name, text) is 'user privilege on any column by username, rel name';

alter function pg_catalog.has_any_column_privilege(name, text) owner to postgres;

create function pg_catalog.has_any_column_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(name, oid, text) is 'user privilege on any column by username, rel oid';

alter function pg_catalog.has_any_column_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_any_column_privilege()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege() is 'user privilege on any column by user oid, rel name';

alter function pg_catalog.has_any_column_privilege() owner to postgres;

create function pg_catalog.has_any_column_privilege()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege() is 'user privilege on any column by user oid, rel oid';

alter function pg_catalog.has_any_column_privilege() owner to postgres;

create function pg_catalog.has_any_column_privilege(text)
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(text) is 'current user privilege on any column by rel name';

alter function pg_catalog.has_any_column_privilege(text) owner to postgres;

create function pg_catalog.has_any_column_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(oid, text) is 'current user privilege on any column by rel oid';

alter function pg_catalog.has_any_column_privilege(oid, text) owner to postgres;

create function pg_catalog.overlay(bit, bit, integer) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(bit, bit, integer) is 'substitute portion of bitstring';

alter function pg_catalog.overlay(bit, bit, integer) owner to postgres;

create function pg_catalog.overlay(bit, bit) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(bit, bit) is 'substitute portion of bitstring';

alter function pg_catalog.overlay(bit, bit) owner to postgres;

create function pg_catalog.get_bit(bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_bit(bit) is 'get bit';

alter function pg_catalog.get_bit(bit) owner to postgres;

create function pg_catalog.set_bit(bit) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_bit(bit) is 'set bit';

alter function pg_catalog.set_bit(bit) owner to postgres;

create function pg_catalog.pg_relation_filepath()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_filepath() is 'file path of relation';

alter function pg_catalog.pg_relation_filepath() owner to postgres;

create function pg_catalog.pg_listening_channels()
    stable
    strict
    parallel restricted
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_listening_channels() is 'get the channels that the current backend listens to';

alter function pg_catalog.pg_listening_channels() owner to postgres;

create function pg_catalog.pg_notify()
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_notify() is 'send a notification event';

alter function pg_catalog.pg_notify() owner to postgres;

create function pg_catalog.pg_stat_get_xact_numscans()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_numscans() is 'statistics: number of scans done for table/index in current transaction';

alter function pg_catalog.pg_stat_get_xact_numscans() owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_returned()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_returned() is 'statistics: number of tuples read by seqscan in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_returned() owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_fetched()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_fetched() is 'statistics: number of tuples fetched by idxscan in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_fetched() owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_inserted()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_inserted() is 'statistics: number of tuples inserted in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_inserted() owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_updated()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_updated() is 'statistics: number of tuples updated in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_updated() owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_deleted()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_deleted() is 'statistics: number of tuples deleted in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_deleted() owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_hot_updated()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_hot_updated() is 'statistics: number of tuples hot updated in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_hot_updated() owner to postgres;

create function pg_catalog.pg_stat_get_xact_blocks_fetched()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_blocks_fetched() is 'statistics: number of blocks fetched in current transaction';

alter function pg_catalog.pg_stat_get_xact_blocks_fetched() owner to postgres;

create function pg_catalog.pg_stat_get_xact_blocks_hit()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_blocks_hit() is 'statistics: number of blocks found in cache in current transaction';

alter function pg_catalog.pg_stat_get_xact_blocks_hit() owner to postgres;

create function pg_catalog.pg_stat_get_xact_function_calls()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_function_calls() is 'statistics: number of function calls in current transaction';

alter function pg_catalog.pg_stat_get_xact_function_calls() owner to postgres;

create function pg_catalog.pg_stat_get_xact_function_total_time()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_function_total_time() is 'statistics: total execution time of function in current transaction, in milliseconds';

alter function pg_catalog.pg_stat_get_xact_function_total_time() owner to postgres;

create function pg_catalog.pg_stat_get_xact_function_self_time()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_function_self_time() is 'statistics: self execution time of function in current transaction, in milliseconds';

alter function pg_catalog.pg_stat_get_xact_function_self_time() owner to postgres;

create function pg_catalog.xpath_exists(text, xml) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xpath_exists(text[]) is 'test XML value against XPath expression, with namespace support';

alter function pg_catalog.xpath_exists(text[]) owner to postgres;

create function pg_catalog.xpath_exists(text, xml) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.xpath_exists() is 'test XML value against XPath expression';

alter function pg_catalog.xpath_exists() owner to postgres;

create function pg_catalog.xml_is_well_formed()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_is_well_formed() is 'determine if a string is well formed XML';

alter function pg_catalog.xml_is_well_formed() owner to postgres;

create function pg_catalog.xml_is_well_formed_document()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_is_well_formed_document() is 'determine if a string is well formed XML document';

alter function pg_catalog.xml_is_well_formed_document() owner to postgres;

create function pg_catalog.xml_is_well_formed_content()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_is_well_formed_content() is 'determine if a string is well formed XML content';

alter function pg_catalog.xml_is_well_formed_content() owner to postgres;

create function pg_catalog.pg_stat_get_vacuum_count()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_vacuum_count() is 'statistics: number of manual vacuums for a table';

alter function pg_catalog.pg_stat_get_vacuum_count() owner to postgres;

create function pg_catalog.pg_stat_get_autovacuum_count()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_autovacuum_count() is 'statistics: number of auto vacuums for a table';

alter function pg_catalog.pg_stat_get_autovacuum_count() owner to postgres;

create function pg_catalog.pg_stat_get_analyze_count()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_analyze_count() is 'statistics: number of manual analyzes for a table';

alter function pg_catalog.pg_stat_get_analyze_count() owner to postgres;

create function pg_catalog.pg_stat_get_autoanalyze_count()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_autoanalyze_count() is 'statistics: number of auto analyzes for a table';

alter function pg_catalog.pg_stat_get_autoanalyze_count() owner to postgres;

create function pg_catalog.concat()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.concat() is 'concatenate values';

alter function pg_catalog.concat() owner to postgres;

create function pg_catalog.concat_ws()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.concat_ws() is 'concatenate values with separators';

alter function pg_catalog.concat_ws() owner to postgres;

create function pg_catalog."left"()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."left"() is 'extract the first n characters';

alter function pg_catalog."left"() owner to postgres;

create function pg_catalog."right"()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."right"() is 'extract the last n characters';

alter function pg_catalog."right"() owner to postgres;

create function pg_catalog.reverse()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.reverse() is 'reverse text';

alter function pg_catalog.reverse() owner to postgres;

create function pg_catalog.pg_stat_get_buf_fsync_backend()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_buf_fsync_backend() is 'statistics: number of backend buffer writes that did their own fsync';

alter function pg_catalog.pg_stat_get_buf_fsync_backend() owner to postgres;

create function pg_catalog.gist_point_distance()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_distance() is 'GiST support';

alter function pg_catalog.gist_point_distance() owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_tablespace()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_tablespace() is 'statistics: recovery conflicts in database caused by drop tablespace';

alter function pg_catalog.pg_stat_get_db_conflict_tablespace() owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_lock()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_lock() is 'statistics: recovery conflicts in database caused by relation lock';

alter function pg_catalog.pg_stat_get_db_conflict_lock() owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_snapshot()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_snapshot() is 'statistics: recovery conflicts in database caused by snapshot expiry';

alter function pg_catalog.pg_stat_get_db_conflict_snapshot() owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_bufferpin()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_bufferpin() is 'statistics: recovery conflicts in database caused by shared buffer pin';

alter function pg_catalog.pg_stat_get_db_conflict_bufferpin() owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_startup_deadlock()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_startup_deadlock() is 'statistics: recovery conflicts in database caused by buffer deadlock';

alter function pg_catalog.pg_stat_get_db_conflict_startup_deadlock() owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_all()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_all() is 'statistics: recovery conflicts in database';

alter function pg_catalog.pg_stat_get_db_conflict_all() owner to postgres;

create function pg_catalog.pg_wal_replay_pause()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_wal_replay_pause() is 'pause wal replay';

alter function pg_catalog.pg_wal_replay_pause() owner to postgres;

create function pg_catalog.pg_wal_replay_resume()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_wal_replay_resume() is 'resume wal replay, if it was paused';

alter function pg_catalog.pg_wal_replay_resume() owner to postgres;

create function pg_catalog.pg_is_wal_replay_paused()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_wal_replay_paused() is 'true if wal replay is paused';

alter function pg_catalog.pg_is_wal_replay_paused() owner to postgres;

create function pg_catalog.pg_stat_get_db_stat_reset_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_stat_reset_time() is 'statistics: last reset for a database';

alter function pg_catalog.pg_stat_get_db_stat_reset_time() owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_stat_reset_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_stat_reset_time() is 'statistics: last reset for the bgwriter';

alter function pg_catalog.pg_stat_get_bgwriter_stat_reset_time() owner to postgres;

create function pg_catalog.ginarrayextract()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarrayextract() is 'GIN array support (obsolete)';

alter function pg_catalog.ginarrayextract() owner to postgres;

create function pg_catalog.gin_extract_tsvector()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsvector() is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_extract_tsvector() owner to postgres;

create function pg_catalog.pg_sequence_parameters()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sequence_parameters() is 'sequence parameters, for use by information schema';

alter function pg_catalog.pg_sequence_parameters() owner to postgres;

create function pg_catalog.pg_available_extensions()
    stable
    strict
    parallel safe
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_available_extensions() is 'list available extensions';

alter function pg_catalog.pg_available_extensions() owner to postgres;

create function pg_catalog.pg_available_extension_versions()
    stable
    strict
    parallel safe
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_available_extension_versions() is 'list available extension versions';

alter function pg_catalog.pg_available_extension_versions() owner to postgres;

create function pg_catalog.pg_extension_update_paths()
    stable
    strict
    parallel safe
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_extension_update_paths() is 'list an extension''s version update paths';

alter function pg_catalog.pg_extension_update_paths() owner to postgres;

create function pg_catalog.pg_extension_config_dump()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_extension_config_dump() is 'flag an extension''s table contents to be emitted by pg_dump';

alter function pg_catalog.pg_extension_config_dump() owner to postgres;

create function pg_catalog.gin_extract_tsquery(tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsquery(tsquery) is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_extract_tsquery(tsquery) owner to postgres;

create function pg_catalog.gin_tsquery_consistent(tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_consistent(tsquery) is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_tsquery_consistent(tsquery) owner to postgres;

create function pg_catalog.pg_advisory_xact_lock()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock() is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_xact_lock() owner to postgres;

create function pg_catalog.pg_advisory_xact_lock_shared()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock_shared() is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_xact_lock_shared() owner to postgres;

create function pg_catalog.pg_try_advisory_xact_lock()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock() is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock() owner to postgres;

create function pg_catalog.pg_try_advisory_xact_lock_shared()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock_shared() is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock_shared() owner to postgres;

create function pg_catalog.pg_advisory_xact_lock()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock() is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_xact_lock() owner to postgres;

create function pg_catalog.pg_advisory_xact_lock_shared()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock_shared() is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_xact_lock_shared() owner to postgres;

create function pg_catalog.pg_try_advisory_xact_lock()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock() is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock() owner to postgres;

create function pg_catalog.pg_try_advisory_xact_lock_shared()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock_shared() is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock_shared() owner to postgres;

create function pg_catalog.varchar_support()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchar_support() is 'planner support for varchar length coercion';

alter function pg_catalog.varchar_support() owner to postgres;

create function pg_catalog.pg_create_restore_point()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_create_restore_point() is 'create a named restore point';

alter function pg_catalog.pg_create_restore_point() owner to postgres;

create function pg_catalog.pg_stat_get_wal_senders()
    stable
    parallel restricted
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_wal_senders() is 'statistics: information about currently active replication';

alter function pg_catalog.pg_stat_get_wal_senders() owner to postgres;

create function pg_catalog.row_number()
    immutable
    window
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_number() is 'row number within partition';

alter function pg_catalog.row_number() owner to postgres;

create function pg_catalog.rank()
    immutable
    window
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rank() is 'integer rank with gaps';

alter function pg_catalog.rank() owner to postgres;

create function pg_catalog.dense_rank()
    immutable
    window
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dense_rank() is 'integer rank without gaps';

alter function pg_catalog.dense_rank() owner to postgres;

create function pg_catalog.percent_rank()
    immutable
    window
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percent_rank() is 'fractional rank within partition';

alter function pg_catalog.percent_rank() owner to postgres;

create function pg_catalog.cume_dist()
    immutable
    window
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cume_dist() is 'fractional row number within partition';

alter function pg_catalog.cume_dist() owner to postgres;

create function pg_catalog.ntile()
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ntile() is 'split rows into N groups';

alter function pg_catalog.ntile() owner to postgres;

create function pg_catalog.lag()
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lag() is 'fetch the preceding row value';

alter function pg_catalog.lag() owner to postgres;

create function pg_catalog.lag()
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lag() is 'fetch the Nth preceding row value';

alter function pg_catalog.lag() owner to postgres;

create function pg_catalog.lag(integer, anyelement)
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lag(integer, anyelement) is 'fetch the Nth preceding row value with default';

alter function pg_catalog.lag(integer, anyelement) owner to postgres;

create function pg_catalog.lead()
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lead() is 'fetch the following row value';

alter function pg_catalog.lead() owner to postgres;

create function pg_catalog.lead()
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lead() is 'fetch the Nth following row value';

alter function pg_catalog.lead() owner to postgres;

create function pg_catalog.lead(integer, anyelement)
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lead(integer, anyelement) is 'fetch the Nth following row value with default';

alter function pg_catalog.lead(integer, anyelement) owner to postgres;

create function pg_catalog.first_value()
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.first_value() is 'fetch the first row value';

alter function pg_catalog.first_value() owner to postgres;

create function pg_catalog.last_value()
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.last_value() is 'fetch the last row value';

alter function pg_catalog.last_value() owner to postgres;

create function pg_catalog.nth_value()
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nth_value() is 'fetch the Nth row value';

alter function pg_catalog.nth_value() owner to postgres;

create function pg_catalog.fdw_handler_in()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fdw_handler_in() is 'I/O';

alter function pg_catalog.fdw_handler_in() owner to postgres;

create function pg_catalog.fdw_handler_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fdw_handler_out() is 'I/O';

alter function pg_catalog.fdw_handler_out() owner to postgres;

create function pg_catalog.void_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_recv() is 'I/O';

alter function pg_catalog.void_recv() owner to postgres;

create function pg_catalog.void_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_send() is 'I/O';

alter function pg_catalog.void_send() owner to postgres;

create function pg_catalog.btint2sortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint2sortsupport() is 'sort support';

alter function pg_catalog.btint2sortsupport() owner to postgres;

create function pg_catalog.btint4sortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint4sortsupport() is 'sort support';

alter function pg_catalog.btint4sortsupport() owner to postgres;

create function pg_catalog.btint8sortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint8sortsupport() is 'sort support';

alter function pg_catalog.btint8sortsupport() owner to postgres;

create function pg_catalog.btfloat4sortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat4sortsupport() is 'sort support';

alter function pg_catalog.btfloat4sortsupport() owner to postgres;

create function pg_catalog.btfloat8sortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat8sortsupport() is 'sort support';

alter function pg_catalog.btfloat8sortsupport() owner to postgres;

create function pg_catalog.btoidsortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btoidsortsupport() is 'sort support';

alter function pg_catalog.btoidsortsupport() owner to postgres;

create function pg_catalog.btnamesortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btnamesortsupport() is 'sort support';

alter function pg_catalog.btnamesortsupport() owner to postgres;

create function pg_catalog.date_sortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_sortsupport() is 'sort support';

alter function pg_catalog.date_sortsupport() owner to postgres;

create function pg_catalog.timestamp_sortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_sortsupport() is 'sort support';

alter function pg_catalog.timestamp_sortsupport() owner to postgres;

create function pg_catalog.has_type_privilege(name, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(name, text) is 'user privilege on type by username, type name';

alter function pg_catalog.has_type_privilege(name, text) owner to postgres;

create function pg_catalog.has_type_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(name, oid, text) is 'user privilege on type by username, type oid';

alter function pg_catalog.has_type_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_type_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege() is 'user privilege on type by user oid, type name';

alter function pg_catalog.has_type_privilege() owner to postgres;

create function pg_catalog.has_type_privilege()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege() is 'user privilege on type by user oid, type oid';

alter function pg_catalog.has_type_privilege() owner to postgres;

create function pg_catalog.has_type_privilege(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(text) is 'current user privilege on type by type name';

alter function pg_catalog.has_type_privilege(text) owner to postgres;

create function pg_catalog.has_type_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(oid, text) is 'current user privilege on type by type oid';

alter function pg_catalog.has_type_privilege(oid, text) owner to postgres;

create function pg_catalog.macaddr_not()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_not() is 'implementation of ~ operator';

alter function pg_catalog.macaddr_not() owner to postgres;

create function pg_catalog.macaddr_and()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_and() is 'implementation of & operator';

alter function pg_catalog.macaddr_and() owner to postgres;

create function pg_catalog.macaddr_or()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_or() is 'implementation of | operator';

alter function pg_catalog.macaddr_or() owner to postgres;

create function pg_catalog.pg_stat_get_db_temp_files()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_temp_files() is 'statistics: number of temporary files written';

alter function pg_catalog.pg_stat_get_db_temp_files() owner to postgres;

create function pg_catalog.pg_stat_get_db_temp_bytes()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_temp_bytes() is 'statistics: number of bytes in temporary files written';

alter function pg_catalog.pg_stat_get_db_temp_bytes() owner to postgres;

create function pg_catalog.pg_stat_get_db_deadlocks()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_deadlocks() is 'statistics: deadlocks detected in database';

alter function pg_catalog.pg_stat_get_db_deadlocks() owner to postgres;

create function pg_catalog.array_to_json()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_json() is 'map array to json';

alter function pg_catalog.array_to_json() owner to postgres;

create function pg_catalog.array_to_json()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_json() is 'map array to json with optional pretty printing';

alter function pg_catalog.array_to_json() owner to postgres;

create function pg_catalog.row_to_json()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_to_json() is 'map row to json';

alter function pg_catalog.row_to_json() owner to postgres;

create function pg_catalog.row_to_json()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_to_json() is 'map row to json with optional pretty printing';

alter function pg_catalog.row_to_json() owner to postgres;

create function pg_catalog.numeric_support()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_support() is 'planner support for numeric length coercion';

alter function pg_catalog.numeric_support() owner to postgres;

create function pg_catalog.varbit_support()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_support() is 'planner support for varbit length coercion';

alter function pg_catalog.varbit_support() owner to postgres;

create function pg_catalog.pg_get_viewdef()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef() is 'select statement of a view with pretty-printing and specified line wrapping';

alter function pg_catalog.pg_get_viewdef() owner to postgres;

create function pg_catalog.pg_stat_get_checkpoint_write_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_checkpoint_write_time() is 'statistics: checkpoint time spent writing buffers to disk, in milliseconds';

alter function pg_catalog.pg_stat_get_checkpoint_write_time() owner to postgres;

create function pg_catalog.pg_stat_get_checkpoint_sync_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_checkpoint_sync_time() is 'statistics: checkpoint time spent synchronizing buffers to disk, in milliseconds';

alter function pg_catalog.pg_stat_get_checkpoint_sync_time() owner to postgres;

create function pg_catalog.pg_collation_for()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_collation_for() is 'collation of the argument; implementation of the COLLATION FOR expression';

alter function pg_catalog.pg_collation_for() owner to postgres;

create function pg_catalog.pg_trigger_depth()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_trigger_depth() is 'current trigger depth';

alter function pg_catalog.pg_trigger_depth() owner to postgres;

create function pg_catalog.pg_wal_lsn_diff()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_wal_lsn_diff() is 'difference in bytes, given two wal locations';

alter function pg_catalog.pg_wal_lsn_diff() owner to postgres;

create function pg_catalog.pg_size_pretty()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_size_pretty() is 'convert a numeric to a human readable text using size units';

alter function pg_catalog.pg_size_pretty() owner to postgres;

create function pg_catalog.array_remove()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_remove() is 'remove any occurrences of an element from an array';

alter function pg_catalog.array_remove() owner to postgres;

create function pg_catalog.array_replace()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_replace() is 'replace any occurrences of an element in an array';

alter function pg_catalog.array_replace() owner to postgres;

create function pg_catalog.rangesel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rangesel() is 'restriction selectivity for range operators';

alter function pg_catalog.rangesel() owner to postgres;

create function pg_catalog.lo_lseek64()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_lseek64() is 'large object seek (64 bit)';

alter function pg_catalog.lo_lseek64() owner to postgres;

create function pg_catalog.lo_tell64()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_tell64() is 'large object position (64 bit)';

alter function pg_catalog.lo_tell64() owner to postgres;

create function pg_catalog.lo_truncate64()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_truncate64() is 'truncate large object (64 bit)';

alter function pg_catalog.lo_truncate64() owner to postgres;

create function pg_catalog.json_agg_transfn()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_agg_transfn() is 'json aggregate transition function';

alter function pg_catalog.json_agg_transfn() owner to postgres;

create function pg_catalog.json_agg_finalfn()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_agg_finalfn() is 'json aggregate final function';

alter function pg_catalog.json_agg_finalfn() owner to postgres;

create function pg_catalog.to_json()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_json() is 'map input to json';

alter function pg_catalog.to_json() owner to postgres;

create function pg_catalog.pg_stat_get_mod_since_analyze()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_mod_since_analyze() is 'statistics: number of tuples changed since last analyze';

alter function pg_catalog.pg_stat_get_mod_since_analyze() owner to postgres;

create function pg_catalog.numeric_sum()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sum() is 'aggregate final function';

alter function pg_catalog.numeric_sum() owner to postgres;

create function pg_catalog.cardinality()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cardinality() is 'array cardinality';

alter function pg_catalog.cardinality() owner to postgres;

create function pg_catalog.json_object_agg_transfn()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_agg_transfn() is 'json object aggregate transition function';

alter function pg_catalog.json_object_agg_transfn() owner to postgres;

create function pg_catalog.record_image_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_eq() is 'implementation of *= operator';

alter function pg_catalog.record_image_eq() owner to postgres;

create function pg_catalog.record_image_ne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_ne() is 'implementation of *<> operator';

alter function pg_catalog.record_image_ne() owner to postgres;

create function pg_catalog.record_image_lt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_lt() is 'implementation of *< operator';

alter function pg_catalog.record_image_lt() owner to postgres;

create function pg_catalog.record_image_gt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_gt() is 'implementation of *> operator';

alter function pg_catalog.record_image_gt() owner to postgres;

create function pg_catalog.record_image_le()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_le() is 'implementation of *<= operator';

alter function pg_catalog.record_image_le() owner to postgres;

create function pg_catalog.record_image_ge()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_ge() is 'implementation of *>= operator';

alter function pg_catalog.record_image_ge() owner to postgres;

create function pg_catalog.btrecordimagecmp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrecordimagecmp() is 'less-equal-greater based on byte images';

alter function pg_catalog.btrecordimagecmp() owner to postgres;

create function pg_catalog.pg_stat_get_archiver()
    stable
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_archiver() is 'statistics: information about WAL archiver';

alter function pg_catalog.pg_stat_get_archiver() owner to postgres;

create function pg_catalog.json_object_agg_finalfn()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_agg_finalfn() is 'json object aggregate final function';

alter function pg_catalog.json_object_agg_finalfn() owner to postgres;

create function pg_catalog.json_build_array()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_array() is 'build a json array from any inputs';

alter function pg_catalog.json_build_array() owner to postgres;

create function pg_catalog.json_build_array()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_array() is 'build an empty json array';

alter function pg_catalog.json_build_array() owner to postgres;

create function pg_catalog.json_build_object()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_object() is 'build a json object from pairwise key/value inputs';

alter function pg_catalog.json_build_object() owner to postgres;

create function pg_catalog.json_build_object()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_object() is 'build an empty json object';

alter function pg_catalog.json_build_object() owner to postgres;

create function pg_catalog.json_object()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object() is 'map text array of key value pairs to json object';

alter function pg_catalog.json_object() owner to postgres;

create function pg_catalog.json_object()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object() is 'map text arrays of keys and values to json object';

alter function pg_catalog.json_object() owner to postgres;

create function pg_catalog.json_to_record()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_to_record() is 'get record fields from a json object';

alter function pg_catalog.json_to_record() owner to postgres;

create function pg_catalog.json_to_recordset()
    stable
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_to_recordset() is 'get set of records with fields from a json array of objects';

alter function pg_catalog.json_to_recordset() owner to postgres;

create function pg_catalog.jsonb_array_length()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_length() is 'length of jsonb array';

alter function pg_catalog.jsonb_array_length() owner to postgres;

create function pg_catalog.jsonb_each()
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_each() is 'key value pairs of a jsonb object';

alter function pg_catalog.jsonb_each() owner to postgres;

create function pg_catalog.jsonb_populate_record()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_populate_record() is 'get record fields from a jsonb object';

alter function pg_catalog.jsonb_populate_record() owner to postgres;

create function pg_catalog.jsonb_typeof()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_typeof() is 'get the type of a jsonb value';

alter function pg_catalog.jsonb_typeof() owner to postgres;

create function pg_catalog.jsonb_object_field_text()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_field_text() is 'implementation of ->> operator';

alter function pg_catalog.jsonb_object_field_text() owner to postgres;

create function pg_catalog.jsonb_array_element()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_element() is 'implementation of -> operator';

alter function pg_catalog.jsonb_array_element() owner to postgres;

create function pg_catalog.jsonb_array_element_text()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_element_text() is 'implementation of ->> operator';

alter function pg_catalog.jsonb_array_element_text() owner to postgres;

create function pg_catalog.jsonb_extract_path()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_extract_path() is 'get value from jsonb with path elements';

alter function pg_catalog.jsonb_extract_path() owner to postgres;

create function pg_catalog.width_bucket(anyelement, anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width_bucket(anyelement, anyarray) is 'bucket number of operand given a sorted array of bucket lower bounds';

alter function pg_catalog.width_bucket(anyelement, anyarray) owner to postgres;

create function pg_catalog.jsonb_array_elements()
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_elements() is 'elements of a jsonb array';

alter function pg_catalog.jsonb_array_elements() owner to postgres;

create function pg_catalog.pg_lsn_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_in() is 'I/O';

alter function pg_catalog.pg_lsn_in() owner to postgres;

create function pg_catalog.pg_lsn_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_out() is 'I/O';

alter function pg_catalog.pg_lsn_out() owner to postgres;

create function pg_catalog.pg_lsn_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_lt() is 'implementation of < operator';

alter function pg_catalog.pg_lsn_lt() owner to postgres;

create function pg_catalog.pg_lsn_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_le() is 'implementation of <= operator';

alter function pg_catalog.pg_lsn_le() owner to postgres;

create function pg_catalog.pg_lsn_eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_eq() is 'implementation of = operator';

alter function pg_catalog.pg_lsn_eq() owner to postgres;

create function pg_catalog.pg_lsn_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_ge() is 'implementation of >= operator';

alter function pg_catalog.pg_lsn_ge() owner to postgres;

create function pg_catalog.pg_lsn_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_gt() is 'implementation of > operator';

alter function pg_catalog.pg_lsn_gt() owner to postgres;

create function pg_catalog.pg_lsn_ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_ne() is 'implementation of <> operator';

alter function pg_catalog.pg_lsn_ne() owner to postgres;

create function pg_catalog.pg_lsn_mi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_mi() is 'implementation of - operator';

alter function pg_catalog.pg_lsn_mi() owner to postgres;

create function pg_catalog.pg_lsn_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_recv() is 'I/O';

alter function pg_catalog.pg_lsn_recv() owner to postgres;

create function pg_catalog.pg_lsn_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_send() is 'I/O';

alter function pg_catalog.pg_lsn_send() owner to postgres;

create function pg_catalog.pg_lsn_cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_cmp() is 'less-equal-greater';

alter function pg_catalog.pg_lsn_cmp() owner to postgres;

create function pg_catalog.pg_lsn_hash()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_hash() is 'hash';

alter function pg_catalog.pg_lsn_hash() owner to postgres;

create function pg_catalog.bttextsortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttextsortsupport() is 'sort support';

alter function pg_catalog.bttextsortsupport() owner to postgres;

create function pg_catalog.generate_series(numeric, numeric, numeric) returns setof setof numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(numeric, numeric, numeric) is 'non-persistent series generator';

alter function pg_catalog.generate_series(numeric, numeric, numeric) owner to postgres;

create function pg_catalog.generate_series(numeric, numeric) returns setof setof numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(numeric, numeric) is 'non-persistent series generator';

alter function pg_catalog.generate_series(numeric, numeric) owner to postgres;

create function pg_catalog.json_strip_nulls()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_strip_nulls() is 'remove object fields with null values from json';

alter function pg_catalog.json_strip_nulls() owner to postgres;

create function pg_catalog.jsonb_strip_nulls()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_strip_nulls() is 'remove object fields with null values from jsonb';

alter function pg_catalog.jsonb_strip_nulls() owner to postgres;

create function pg_catalog.jsonb_object()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object() is 'map text array of key value pairs to jsonb object';

alter function pg_catalog.jsonb_object() owner to postgres;

create function pg_catalog.jsonb_object()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object() is 'map text array of key value pairs to jsonb object';

alter function pg_catalog.jsonb_object() owner to postgres;

create function pg_catalog.jsonb_agg_transfn()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_agg_transfn() is 'jsonb aggregate transition function';

alter function pg_catalog.jsonb_agg_transfn() owner to postgres;

create function pg_catalog.jsonb_agg_finalfn()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_agg_finalfn() is 'jsonb aggregate final function';

alter function pg_catalog.jsonb_agg_finalfn() owner to postgres;

create function pg_catalog.jsonb_object_agg_transfn()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_agg_transfn() is 'jsonb object aggregate transition function';

alter function pg_catalog.jsonb_object_agg_transfn() owner to postgres;

create function pg_catalog.jsonb_object_agg_finalfn()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_agg_finalfn() is 'jsonb object aggregate final function';

alter function pg_catalog.jsonb_object_agg_finalfn() owner to postgres;

create function pg_catalog.jsonb_build_array()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_array() is 'build a jsonb array from any inputs';

alter function pg_catalog.jsonb_build_array() owner to postgres;

create function pg_catalog.jsonb_build_array()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_array() is 'build an empty jsonb array';

alter function pg_catalog.jsonb_build_array() owner to postgres;

create function pg_catalog.jsonb_build_object()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_object() is 'build a jsonb object from pairwise key/value inputs';

alter function pg_catalog.jsonb_build_object() owner to postgres;

create function pg_catalog.jsonb_build_object()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_object() is 'build an empty jsonb object';

alter function pg_catalog.jsonb_build_object() owner to postgres;

create function pg_catalog.dist_ppoly()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ppoly() is 'implementation of <-> operator';

alter function pg_catalog.dist_ppoly() owner to postgres;

create function pg_catalog.array_position()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_position() is 'returns an offset of value in array';

alter function pg_catalog.array_position() owner to postgres;

create function pg_catalog.array_position()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_position() is 'returns an offset of value in array with start index';

alter function pg_catalog.array_position() owner to postgres;

create function pg_catalog.array_positions()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_positions() is 'returns an array of offsets of some value in array';

alter function pg_catalog.array_positions() owner to postgres;

create function pg_catalog.gist_circle_distance()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_circle_distance() is 'GiST support';

alter function pg_catalog.gist_circle_distance() owner to postgres;

create function pg_catalog.scale()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scale() is 'number of decimal digits in the fractional part';

alter function pg_catalog.scale() owner to postgres;

create function pg_catalog.gist_point_fetch()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_fetch() is 'GiST support';

alter function pg_catalog.gist_point_fetch() owner to postgres;

create function pg_catalog.numeric_sortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sortsupport() is 'sort support';

alter function pg_catalog.numeric_sortsupport() owner to postgres;

create function pg_catalog.gist_poly_distance()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_poly_distance() is 'GiST support';

alter function pg_catalog.gist_poly_distance() owner to postgres;

create function pg_catalog.dist_cpoint()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_cpoint() is 'implementation of <-> operator';

alter function pg_catalog.dist_cpoint() owner to postgres;

create function pg_catalog.dist_polyp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_polyp() is 'implementation of <-> operator';

alter function pg_catalog.dist_polyp() owner to postgres;

create function pg_catalog.pg_read_file()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file() is 'read text from a file';

alter function pg_catalog.pg_read_file() owner to postgres;

create function pg_catalog.current_setting()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_setting() is 'SHOW X as a function, optionally no error for missing variable';

alter function pg_catalog.current_setting() owner to postgres;

create function pg_catalog.pg_read_binary_file()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_binary_file() is 'read bytea from a file';

alter function pg_catalog.pg_read_binary_file() owner to postgres;

create function pg_catalog.pg_notification_queue_usage()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_notification_queue_usage() is 'get the fraction of the asynchronous notification queue currently in use';

alter function pg_catalog.pg_notification_queue_usage() owner to postgres;

create function pg_catalog.pg_ls_dir()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ls_dir() is 'list all files in a directory';

alter function pg_catalog.pg_ls_dir() owner to postgres;

create function pg_catalog.row_security_active(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_security_active(oid) is 'row security for current context active on table by table oid';

alter function pg_catalog.row_security_active(oid) owner to postgres;

create function pg_catalog.row_security_active(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_security_active(text) is 'row security for current context active on table by table name';

alter function pg_catalog.row_security_active(text) owner to postgres;

create function pg_catalog.uuid_sortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_sortsupport() is 'sort support';

alter function pg_catalog.uuid_sortsupport() owner to postgres;

create function pg_catalog.jsonb_concat()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_concat() is 'implementation of || operator';

alter function pg_catalog.jsonb_concat() owner to postgres;

create function pg_catalog.jsonb_delete(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete(text) is 'implementation of - operator';

alter function pg_catalog.jsonb_delete(text) owner to postgres;

create function pg_catalog.jsonb_delete(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete(integer) is 'implementation of - operator';

alter function pg_catalog.jsonb_delete(integer) owner to postgres;

create function pg_catalog.jsonb_delete_path()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete_path() is 'implementation of #- operator';

alter function pg_catalog.jsonb_delete_path() owner to postgres;

create function pg_catalog.jsonb_set()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_set() is 'Set part of a jsonb';

alter function pg_catalog.jsonb_set() owner to postgres;

create function pg_catalog.jsonb_pretty()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_pretty() is 'Indented text from jsonb';

alter function pg_catalog.jsonb_pretty() owner to postgres;

create function pg_catalog.pg_stat_file()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_file() is 'get information about file';

alter function pg_catalog.pg_stat_file() owner to postgres;

create function pg_catalog.xidneq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidneq() is 'implementation of <> operator';

alter function pg_catalog.xidneq() owner to postgres;

create function pg_catalog.xidneqint4()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidneqint4() is 'implementation of <> operator';

alter function pg_catalog.xidneqint4() owner to postgres;

create function pg_catalog.tsm_handler_in()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsm_handler_in() is 'I/O';

alter function pg_catalog.tsm_handler_in() owner to postgres;

create function pg_catalog.tsm_handler_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsm_handler_out() is 'I/O';

alter function pg_catalog.tsm_handler_out() owner to postgres;

create function pg_catalog.bernoulli()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bernoulli() is 'BERNOULLI tablesample method handler';

alter function pg_catalog.bernoulli() owner to postgres;

create function pg_catalog.system()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.system() is 'SYSTEM tablesample method handler';

alter function pg_catalog.system() owner to postgres;

create function pg_catalog.pg_stat_get_wal_receiver()
    stable
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_wal_receiver() is 'statistics: information about WAL receiver';

alter function pg_catalog.pg_stat_get_wal_receiver() owner to postgres;

create function pg_catalog.pg_stat_get_progress_info()
    stable
    strict
    parallel restricted
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_progress_info() is 'statistics: information about progress of backends running maintenance command';

alter function pg_catalog.pg_stat_get_progress_info() owner to postgres;

create function pg_catalog.ts_filter()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_filter() is 'delete lexemes that do not have one of the given weights';

alter function pg_catalog.ts_filter() owner to postgres;

create function pg_catalog.setweight(text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setweight(text[]) is 'set given weight for given lexemes';

alter function pg_catalog.setweight(text[]) owner to postgres;

create function pg_catalog.ts_delete(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_delete(text) is 'delete lexeme';

alter function pg_catalog.ts_delete(text) owner to postgres;

create function pg_catalog.unnest()
    immutable
    strict
    parallel safe
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unnest() is 'expand tsvector to set of rows';

alter function pg_catalog.unnest() owner to postgres;

create function pg_catalog.ts_delete(text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_delete(text[]) is 'delete given lexemes';

alter function pg_catalog.ts_delete(text[]) owner to postgres;

create function pg_catalog.int4_avg_combine()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_avg_combine() is 'aggregate combine function';

alter function pg_catalog.int4_avg_combine() owner to postgres;

create function pg_catalog.interval_combine()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_combine() is 'aggregate combine function';

alter function pg_catalog.interval_combine() owner to postgres;

create function pg_catalog.tsvector_to_array()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_to_array() is 'convert tsvector to array of lexemes';

alter function pg_catalog.tsvector_to_array() owner to postgres;

create function pg_catalog.array_to_tsvector()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_tsvector() is 'build tsvector from array of lexemes';

alter function pg_catalog.array_to_tsvector() owner to postgres;

create function pg_catalog.bpchar_sortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_sortsupport() is 'sort support';

alter function pg_catalog.bpchar_sortsupport() owner to postgres;

create function pg_catalog.pg_show_all_file_settings()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_show_all_file_settings() is 'show config file settings';

alter function pg_catalog.pg_show_all_file_settings() owner to postgres;

create function pg_catalog.pg_current_wal_flush_lsn()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_wal_flush_lsn() is 'current wal flush location';

alter function pg_catalog.pg_current_wal_flush_lsn() owner to postgres;

create function pg_catalog.bytea_sortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytea_sortsupport() is 'sort support';

alter function pg_catalog.bytea_sortsupport() owner to postgres;

create function pg_catalog.bttext_pattern_sortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttext_pattern_sortsupport() is 'sort support';

alter function pg_catalog.bttext_pattern_sortsupport() owner to postgres;

create function pg_catalog.btbpchar_pattern_sortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btbpchar_pattern_sortsupport() is 'sort support';

alter function pg_catalog.btbpchar_pattern_sortsupport() owner to postgres;

create function pg_catalog.pg_size_bytes()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_size_bytes() is 'convert a size in human-readable format with size units into bytes';

alter function pg_catalog.pg_size_bytes() owner to postgres;

create function pg_catalog.numeric_serialize()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_serialize() is 'aggregate serial function';

alter function pg_catalog.numeric_serialize() owner to postgres;

create function pg_catalog.numeric_deserialize()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_deserialize() is 'aggregate deserial function';

alter function pg_catalog.numeric_deserialize() owner to postgres;

create function pg_catalog.numeric_avg_combine()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_combine() is 'aggregate combine function';

alter function pg_catalog.numeric_avg_combine() owner to postgres;

create function pg_catalog.numeric_poly_combine()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_combine() is 'aggregate combine function';

alter function pg_catalog.numeric_poly_combine() owner to postgres;

create function pg_catalog.numeric_poly_serialize()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_serialize() is 'aggregate serial function';

alter function pg_catalog.numeric_poly_serialize() owner to postgres;

create function pg_catalog.numeric_poly_deserialize()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_deserialize() is 'aggregate deserial function';

alter function pg_catalog.numeric_poly_deserialize() owner to postgres;

create function pg_catalog.numeric_combine()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_combine() is 'aggregate combine function';

alter function pg_catalog.numeric_combine() owner to postgres;

create function pg_catalog.float8_regr_combine()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_combine() is 'aggregate combine function';

alter function pg_catalog.float8_regr_combine() owner to postgres;

create function pg_catalog.jsonb_delete()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete() is 'implementation of - operator';

alter function pg_catalog.jsonb_delete() owner to postgres;

create function pg_catalog.cash_mul_int8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_int8() is 'implementation of * operator';

alter function pg_catalog.cash_mul_int8() owner to postgres;

create function pg_catalog.cash_div_int8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_int8() is 'implementation of / operator';

alter function pg_catalog.cash_div_int8() owner to postgres;

create function pg_catalog.txid_current_if_assigned()
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_current_if_assigned() is 'get current transaction ID';

alter function pg_catalog.txid_current_if_assigned() owner to postgres;

create function pg_catalog.pg_get_partkeydef()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_partkeydef() is 'partition key description';

alter function pg_catalog.pg_get_partkeydef() owner to postgres;

create function pg_catalog.pg_ls_logdir()
    strict
    parallel safe
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ls_logdir() is 'list files in the log directory';

alter function pg_catalog.pg_ls_logdir() owner to postgres;

grant execute on function pg_catalog.pg_ls_logdir() to pg_monitor;

create function pg_catalog.pg_ls_waldir()
    strict
    parallel safe
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ls_waldir() is 'list of files in the WAL directory';

alter function pg_catalog.pg_ls_waldir() owner to postgres;

grant execute on function pg_catalog.pg_ls_waldir() to pg_monitor;

create function pg_catalog.pg_ndistinct_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_in() is 'I/O';

alter function pg_catalog.pg_ndistinct_in() owner to postgres;

create function pg_catalog.pg_ndistinct_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_out() is 'I/O';

alter function pg_catalog.pg_ndistinct_out() owner to postgres;

create function pg_catalog.pg_ndistinct_recv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_recv() is 'I/O';

alter function pg_catalog.pg_ndistinct_recv() owner to postgres;

create function pg_catalog.pg_ndistinct_send()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_send() is 'I/O';

alter function pg_catalog.pg_ndistinct_send() owner to postgres;

create function pg_catalog.macaddr_sortsupport()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_sortsupport() is 'sort support';

alter function pg_catalog.macaddr_sortsupport() owner to postgres;

create function pg_catalog.txid_status()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_status() is 'commit status of transaction';

alter function pg_catalog.txid_status() owner to postgres;

create function pg_catalog.pg_safe_snapshot_blocking_pids()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_safe_snapshot_blocking_pids() is 'get array of PIDs of sessions blocking specified backend PID from acquiring a safe snapshot';

alter function pg_catalog.pg_safe_snapshot_blocking_pids() owner to postgres;

create function pg_catalog.pg_isolation_test_session_is_blocked()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_isolation_test_session_is_blocked() is 'isolationtester support function';

alter function pg_catalog.pg_isolation_test_session_is_blocked() owner to postgres;

create function pg_catalog.pg_identify_object_as_address()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_identify_object_as_address() is 'get identification of SQL object for pg_get_object_address()';

alter function pg_catalog.pg_identify_object_as_address() owner to postgres;

create function pg_catalog.brin_minmax_opcinfo()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_opcinfo() is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_opcinfo() owner to postgres;

create function pg_catalog.brin_minmax_add_value()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_add_value() is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_add_value() owner to postgres;

create function pg_catalog.brin_minmax_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_consistent() is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_consistent() owner to postgres;

create function pg_catalog.brin_minmax_union()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_union() is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_union() owner to postgres;

create function pg_catalog.int8_avg_accum_inv()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_accum_inv() is 'aggregate transition function';

alter function pg_catalog.int8_avg_accum_inv() owner to postgres;

create function pg_catalog.numeric_poly_sum()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_sum() is 'aggregate final function';

alter function pg_catalog.numeric_poly_sum() owner to postgres;

create function pg_catalog.numeric_poly_avg()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_avg() is 'aggregate final function';

alter function pg_catalog.numeric_poly_avg() owner to postgres;

create function pg_catalog.numeric_poly_var_pop()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_var_pop() is 'aggregate final function';

alter function pg_catalog.numeric_poly_var_pop() owner to postgres;

create function pg_catalog.numeric_poly_var_samp()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_var_samp() is 'aggregate final function';

alter function pg_catalog.numeric_poly_var_samp() owner to postgres;

create function pg_catalog.numeric_poly_stddev_pop()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_stddev_pop() is 'aggregate final function';

alter function pg_catalog.numeric_poly_stddev_pop() owner to postgres;

create function pg_catalog.numeric_poly_stddev_samp()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_stddev_samp() is 'aggregate final function';

alter function pg_catalog.numeric_poly_stddev_samp() owner to postgres;

create function pg_catalog.regexp_match()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_match() is 'find first match for regexp';

alter function pg_catalog.regexp_match() owner to postgres;

create function pg_catalog.regexp_match()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_match() is 'find first match for regexp';

alter function pg_catalog.regexp_match() owner to postgres;

create function pg_catalog.int8_mul_cash()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_mul_cash() is 'implementation of * operator';

alter function pg_catalog.int8_mul_cash() owner to postgres;

create function pg_catalog.pg_config()
    stable
    strict
    parallel restricted
    cost 1
    rows 23
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_config() is 'pg_config binary as a function';

alter function pg_catalog.pg_config() owner to postgres;

create function pg_catalog.pg_hba_file_rules()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_hba_file_rules() is 'show pg_hba.conf rules';

alter function pg_catalog.pg_hba_file_rules() owner to postgres;

create function pg_catalog.pg_statistics_obj_is_visible()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_statistics_obj_is_visible() is 'is statistics object visible in search path?';

alter function pg_catalog.pg_statistics_obj_is_visible() owner to postgres;

create function pg_catalog.pg_dependencies_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_in() is 'I/O';

alter function pg_catalog.pg_dependencies_in() owner to postgres;

create function pg_catalog.pg_dependencies_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_out() is 'I/O';

alter function pg_catalog.pg_dependencies_out() owner to postgres;

create function pg_catalog.pg_dependencies_recv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_recv() is 'I/O';

alter function pg_catalog.pg_dependencies_recv() owner to postgres;

create function pg_catalog.pg_dependencies_send()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_send() is 'I/O';

alter function pg_catalog.pg_dependencies_send() owner to postgres;

create function pg_catalog.pg_get_partition_constraintdef()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_partition_constraintdef() is 'partition constraint description';

alter function pg_catalog.pg_get_partition_constraintdef() owner to postgres;

create function pg_catalog.time_hash_extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_hash_extended() is 'hash';

alter function pg_catalog.time_hash_extended() owner to postgres;

create function pg_catalog.timetz_hash_extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_hash_extended() is 'hash';

alter function pg_catalog.timetz_hash_extended() owner to postgres;

create function pg_catalog.timestamp_hash_extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_hash_extended() is 'hash';

alter function pg_catalog.timestamp_hash_extended() owner to postgres;

create function pg_catalog.uuid_hash_extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_hash_extended() is 'hash';

alter function pg_catalog.uuid_hash_extended() owner to postgres;

create function pg_catalog.pg_lsn_hash_extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_hash_extended() is 'hash';

alter function pg_catalog.pg_lsn_hash_extended() owner to postgres;

create function pg_catalog.hashenumextended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashenumextended() is 'hash';

alter function pg_catalog.hashenumextended() owner to postgres;

create function pg_catalog.pg_get_statisticsobjdef()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_statisticsobjdef() is 'extended statistics object description';

alter function pg_catalog.pg_get_statisticsobjdef() owner to postgres;

create function pg_catalog.jsonb_hash_extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_hash_extended() is 'hash';

alter function pg_catalog.jsonb_hash_extended() owner to postgres;

create function pg_catalog.hash_range_extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_range_extended() is 'hash a range';

alter function pg_catalog.hash_range_extended() owner to postgres;

create function pg_catalog.interval_hash_extended()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_hash_extended() is 'hash';

alter function pg_catalog.interval_hash_extended() owner to postgres;

create function pg_catalog.sha224()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha224() is 'SHA-224 hash';

alter function pg_catalog.sha224() owner to postgres;

create function pg_catalog.sha256()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha256() is 'SHA-256 hash';

alter function pg_catalog.sha256() owner to postgres;

create function pg_catalog.sha384()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha384() is 'SHA-384 hash';

alter function pg_catalog.sha384() owner to postgres;

create function pg_catalog.sha512()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha512() is 'SHA-512 hash';

alter function pg_catalog.sha512() owner to postgres;

create function pg_catalog.pg_partition_tree()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_partition_tree() is 'view partition tree tables';

alter function pg_catalog.pg_partition_tree() owner to postgres;

create function pg_catalog.pg_partition_root()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_partition_root() is 'get top-most partition root parent';

alter function pg_catalog.pg_partition_root() owner to postgres;

create function pg_catalog.pg_partition_ancestors()
    strict
    parallel safe
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_partition_ancestors() is 'view ancestors of the partition';

alter function pg_catalog.pg_partition_ancestors() owner to postgres;

create function pg_catalog.pg_stat_get_db_checksum_failures()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_checksum_failures() is 'statistics: checksum failures detected in database';

alter function pg_catalog.pg_stat_get_db_checksum_failures() owner to postgres;

create function pg_catalog.pg_mcv_list_items()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_items() is 'details about MCV list items';

alter function pg_catalog.pg_mcv_list_items() owner to postgres;

create function pg_catalog.pg_stat_get_db_checksum_last_failure()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_checksum_last_failure() is 'statistics: when last checksum failure was detected in database';

alter function pg_catalog.pg_stat_get_db_checksum_last_failure() owner to postgres;

create function pg_catalog.pg_promote()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_promote() is 'promote standby server';

alter function pg_catalog.pg_promote() owner to postgres;

create function pg_catalog.prefixsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prefixsel() is 'restriction selectivity of exact prefix';

alter function pg_catalog.prefixsel() owner to postgres;

create function pg_catalog.prefixjoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prefixjoinsel() is 'join selectivity of exact prefix';

alter function pg_catalog.prefixjoinsel() owner to postgres;

create function pg_catalog.pg_control_system()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_system() is 'pg_controldata general state information as a function';

alter function pg_catalog.pg_control_system() owner to postgres;

create function pg_catalog.pg_control_checkpoint()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_checkpoint() is 'pg_controldata checkpoint state information as a function';

alter function pg_catalog.pg_control_checkpoint() owner to postgres;

create function pg_catalog.pg_control_recovery()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_recovery() is 'pg_controldata recovery state information as a function';

alter function pg_catalog.pg_control_recovery() owner to postgres;

create function pg_catalog.pg_control_init()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_init() is 'pg_controldata init state information as a function';

alter function pg_catalog.pg_control_init() owner to postgres;

create function pg_catalog.pg_import_system_collations()
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_import_system_collations() is 'import collations from operating system';

alter function pg_catalog.pg_import_system_collations() owner to postgres;

create function pg_catalog.macaddr8_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_recv() is 'I/O';

alter function pg_catalog.macaddr8_recv() owner to postgres;

create function pg_catalog.macaddr8_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_send() is 'I/O';

alter function pg_catalog.macaddr8_send() owner to postgres;

create function pg_catalog.pg_collation_actual_version()
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_collation_actual_version() is 'get actual version of collation from operating system';

alter function pg_catalog.pg_collation_actual_version() owner to postgres;

create function pg_catalog.numeric()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric() is 'convert jsonb to numeric';

alter function pg_catalog.numeric() owner to postgres;

create function pg_catalog.int2()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2() is 'convert jsonb to int2';

alter function pg_catalog.int2() owner to postgres;

create function pg_catalog.int4(jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(jsonb) is 'convert jsonb to int4';

alter function pg_catalog.int4(jsonb) owner to postgres;

create function pg_catalog.int8(jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(jsonb) is 'convert jsonb to int8';

alter function pg_catalog.int8(jsonb) owner to postgres;

create function pg_catalog.float4()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4() is 'convert jsonb to float4';

alter function pg_catalog.float4() owner to postgres;

create function pg_catalog.pg_filenode_relation()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_filenode_relation() is 'relation OID for filenode and tablespace';

alter function pg_catalog.pg_filenode_relation() owner to postgres;

create function pg_catalog.lo_from_bytea()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_from_bytea() is 'create new large object with given content';

alter function pg_catalog.lo_from_bytea() owner to postgres;

create function pg_catalog.lo_get()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_get() is 'read entire large object';

alter function pg_catalog.lo_get() owner to postgres;

create function pg_catalog.lo_get()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_get() is 'read large object from offset for length';

alter function pg_catalog.lo_get() owner to postgres;

create function pg_catalog.lo_put()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_put() is 'write data at offset';

alter function pg_catalog.lo_put() owner to postgres;

create function pg_catalog.make_timestamp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_timestamp() is 'construct timestamp';

alter function pg_catalog.make_timestamp() owner to postgres;

create function pg_catalog.make_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_timestamptz() is 'construct timestamp with time zone';

alter function pg_catalog.make_timestamptz() owner to postgres;

create function pg_catalog.make_timestamptz()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_timestamptz() is 'construct timestamp with time zone';

alter function pg_catalog.make_timestamptz() owner to postgres;

create function pg_catalog.make_interval()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_interval() is 'construct interval';

alter function pg_catalog.make_interval() owner to postgres;

create function pg_catalog.jsonb_array_elements_text()
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_elements_text() is 'elements of jsonb array';

alter function pg_catalog.jsonb_array_elements_text() owner to postgres;

create function pg_catalog.spg_range_quad_config()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_config() is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_config() owner to postgres;

create function pg_catalog.spg_range_quad_choose()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_choose() is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_choose() owner to postgres;

create function pg_catalog.spg_range_quad_picksplit()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_picksplit() is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_picksplit() owner to postgres;

create function pg_catalog.spg_range_quad_inner_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_inner_consistent() is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_inner_consistent() owner to postgres;

create function pg_catalog.spg_range_quad_leaf_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_leaf_consistent() is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_leaf_consistent() owner to postgres;

create function pg_catalog.jsonb_populate_recordset()
    stable
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_populate_recordset() is 'get set of records with fields from a jsonb array of objects';

alter function pg_catalog.jsonb_populate_recordset() owner to postgres;

create function pg_catalog.to_regoperator()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regoperator() is 'convert operator name to regoperator';

alter function pg_catalog.to_regoperator() owner to postgres;

create function pg_catalog.jsonb_object_field()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_field() is 'implementation of -> operator';

alter function pg_catalog.jsonb_object_field() owner to postgres;

create function pg_catalog.to_regprocedure()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regprocedure() is 'convert proname to regprocedure';

alter function pg_catalog.to_regprocedure() owner to postgres;

create function pg_catalog.gin_compare_jsonb()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_compare_jsonb() is 'GIN support';

alter function pg_catalog.gin_compare_jsonb() owner to postgres;

create function pg_catalog.gin_extract_jsonb()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb() is 'GIN support';

alter function pg_catalog.gin_extract_jsonb() owner to postgres;

create function pg_catalog.gin_extract_jsonb_query()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb_query() is 'GIN support';

alter function pg_catalog.gin_extract_jsonb_query() owner to postgres;

create function pg_catalog.gin_consistent_jsonb()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_consistent_jsonb() is 'GIN support';

alter function pg_catalog.gin_consistent_jsonb() owner to postgres;

create function pg_catalog.gin_extract_jsonb_path()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb_path() is 'GIN support';

alter function pg_catalog.gin_extract_jsonb_path() owner to postgres;

create function pg_catalog.gin_extract_jsonb_query_path()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb_query_path() is 'GIN support';

alter function pg_catalog.gin_extract_jsonb_query_path() owner to postgres;

create function pg_catalog.gin_consistent_jsonb_path()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_consistent_jsonb_path() is 'GIN support';

alter function pg_catalog.gin_consistent_jsonb_path() owner to postgres;

create function pg_catalog.gin_triconsistent_jsonb()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_triconsistent_jsonb() is 'GIN support';

alter function pg_catalog.gin_triconsistent_jsonb() owner to postgres;

create function pg_catalog.gin_triconsistent_jsonb_path()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_triconsistent_jsonb_path() is 'GIN support';

alter function pg_catalog.gin_triconsistent_jsonb_path() owner to postgres;

create function pg_catalog.jsonb_to_record()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_to_record() is 'get record fields from a jsonb object';

alter function pg_catalog.jsonb_to_record() owner to postgres;

create function pg_catalog.jsonb_to_recordset()
    stable
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_to_recordset() is 'get set of records with fields from a jsonb array of objects';

alter function pg_catalog.jsonb_to_recordset() owner to postgres;

create function pg_catalog.to_regoper()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regoper() is 'convert operator name to regoper';

alter function pg_catalog.to_regoper() owner to postgres;

create function pg_catalog.to_regtype()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regtype() is 'convert type name to regtype';

alter function pg_catalog.to_regtype() owner to postgres;

create function pg_catalog.to_regproc()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regproc() is 'convert proname to regproc';

alter function pg_catalog.to_regproc() owner to postgres;

create function pg_catalog.to_regclass()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regclass() is 'convert classname to regclass';

alter function pg_catalog.to_regclass() owner to postgres;

create function pg_catalog.bool_accum()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_accum() is 'aggregate transition function';

alter function pg_catalog.bool_accum() owner to postgres;

create function pg_catalog.bool_accum_inv()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_accum_inv() is 'aggregate transition function';

alter function pg_catalog.bool_accum_inv() owner to postgres;

create function pg_catalog.bool_alltrue()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_alltrue() is 'aggregate final function';

alter function pg_catalog.bool_alltrue() owner to postgres;

create function pg_catalog.bool_anytrue()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_anytrue() is 'aggregate final function';

alter function pg_catalog.bool_anytrue() owner to postgres;

create function pg_catalog.anyenum_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyenum_in() is 'I/O';

alter function pg_catalog.anyenum_in() owner to postgres;

create function pg_catalog.anyenum_out()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyenum_out() is 'I/O';

alter function pg_catalog.anyenum_out() owner to postgres;

create function pg_catalog.enum_in()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_in() is 'I/O';

alter function pg_catalog.enum_in() owner to postgres;

create function pg_catalog.enum_out()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_out() is 'I/O';

alter function pg_catalog.enum_out() owner to postgres;

create function pg_catalog.enum_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_eq() is 'implementation of = operator';

alter function pg_catalog.enum_eq() owner to postgres;

create function pg_catalog.enum_ne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_ne() is 'implementation of <> operator';

alter function pg_catalog.enum_ne() owner to postgres;

create function pg_catalog.enum_lt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_lt() is 'implementation of < operator';

alter function pg_catalog.enum_lt() owner to postgres;

create function pg_catalog.enum_gt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_gt() is 'implementation of > operator';

alter function pg_catalog.enum_gt() owner to postgres;

create function pg_catalog.enum_le()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_le() is 'implementation of <= operator';

alter function pg_catalog.enum_le() owner to postgres;

create function pg_catalog.enum_ge()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_ge() is 'implementation of >= operator';

alter function pg_catalog.enum_ge() owner to postgres;

create function pg_catalog.enum_cmp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_cmp() is 'less-equal-greater';

alter function pg_catalog.enum_cmp() owner to postgres;

create function pg_catalog.hashenum()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashenum() is 'hash';

alter function pg_catalog.hashenum() owner to postgres;

create function pg_catalog.enum_smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_smaller() is 'smaller of two';

alter function pg_catalog.enum_smaller() owner to postgres;

create function pg_catalog.enum_larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_larger() is 'larger of two';

alter function pg_catalog.enum_larger() owner to postgres;

create function pg_catalog.enum_first()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_first() is 'first value of the input enum type';

alter function pg_catalog.enum_first() owner to postgres;

create function pg_catalog.enum_last()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_last() is 'last value of the input enum type';

alter function pg_catalog.enum_last() owner to postgres;

create function pg_catalog.enum_range()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_range() is 'range between the two given enum values, as an ordered array';

alter function pg_catalog.enum_range() owner to postgres;

create function pg_catalog.enum_range()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_range() is 'range of the given enum type, as an ordered array';

alter function pg_catalog.enum_range() owner to postgres;

create function pg_catalog.enum_recv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_recv() is 'I/O';

alter function pg_catalog.enum_recv() owner to postgres;

create function pg_catalog.enum_send()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_send() is 'I/O';

alter function pg_catalog.enum_send() owner to postgres;

create function pg_catalog.string_agg_transfn()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_agg_transfn() is 'aggregate transition function';

alter function pg_catalog.string_agg_transfn() owner to postgres;

create function pg_catalog.string_agg_finalfn()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_agg_finalfn() is 'aggregate final function';

alter function pg_catalog.string_agg_finalfn() owner to postgres;

create function pg_catalog.pg_describe_object()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_describe_object() is 'get identification of SQL object';

alter function pg_catalog.pg_describe_object() owner to postgres;

create function pg_catalog.format("any")
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.format("any") is 'format text message';

alter function pg_catalog.format("any") owner to postgres;

create function pg_catalog.format()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.format() is 'format text message';

alter function pg_catalog.format() owner to postgres;

create function pg_catalog.bytea_string_agg_transfn()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytea_string_agg_transfn() is 'aggregate transition function';

alter function pg_catalog.bytea_string_agg_transfn() owner to postgres;

create function pg_catalog.bytea_string_agg_finalfn()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytea_string_agg_finalfn() is 'aggregate final function';

alter function pg_catalog.bytea_string_agg_finalfn() owner to postgres;

create function pg_catalog.int8dec()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8dec() is 'decrement';

alter function pg_catalog.int8dec() owner to postgres;

create function pg_catalog.int8dec_any()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8dec_any() is 'decrement, ignores second argument';

alter function pg_catalog.int8dec_any() owner to postgres;

create function pg_catalog.numeric_accum_inv()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_accum_inv() is 'aggregate transition function';

alter function pg_catalog.numeric_accum_inv() owner to postgres;

create function pg_catalog.interval_accum_inv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_accum_inv() is 'aggregate transition function';

alter function pg_catalog.interval_accum_inv() owner to postgres;

create function pg_catalog.network_overlap()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_overlap() is 'implementation of && operator';

alter function pg_catalog.network_overlap() owner to postgres;

create function pg_catalog.inet_gist_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_consistent() is 'GiST support';

alter function pg_catalog.inet_gist_consistent() owner to postgres;

create function pg_catalog.inet_gist_union()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_union() is 'GiST support';

alter function pg_catalog.inet_gist_union() owner to postgres;

create function pg_catalog.inet_gist_compress()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_compress() is 'GiST support';

alter function pg_catalog.inet_gist_compress() owner to postgres;

create function pg_catalog.bool(jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool(jsonb) is 'convert jsonb to boolean';

alter function pg_catalog.bool(jsonb) owner to postgres;

create function pg_catalog.inet_gist_penalty()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_penalty() is 'GiST support';

alter function pg_catalog.inet_gist_penalty() owner to postgres;

create function pg_catalog.inet_gist_picksplit()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_picksplit() is 'GiST support';

alter function pg_catalog.inet_gist_picksplit() owner to postgres;

create function pg_catalog.inet_gist_same()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_same() is 'GiST support';

alter function pg_catalog.inet_gist_same() owner to postgres;

create function pg_catalog.networksel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.networksel() is 'restriction selectivity for network operators';

alter function pg_catalog.networksel() owner to postgres;

create function pg_catalog.networkjoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.networkjoinsel() is 'join selectivity for network operators';

alter function pg_catalog.networkjoinsel() owner to postgres;

create function pg_catalog.network_larger()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_larger() is 'larger of two';

alter function pg_catalog.network_larger() owner to postgres;

create function pg_catalog.network_smaller()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_smaller() is 'smaller of two';

alter function pg_catalog.network_smaller() owner to postgres;

create function pg_catalog.pg_event_trigger_dropped_objects()
    stable
    strict
    parallel restricted
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_event_trigger_dropped_objects() is 'list objects dropped by the current command';

alter function pg_catalog.pg_event_trigger_dropped_objects() owner to postgres;

create function pg_catalog.int2_accum_inv()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_accum_inv() is 'aggregate transition function';

alter function pg_catalog.int2_accum_inv() owner to postgres;

create function pg_catalog.int4_accum_inv()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_accum_inv() is 'aggregate transition function';

alter function pg_catalog.int4_accum_inv() owner to postgres;

create function pg_catalog.int8_accum_inv()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_accum_inv() is 'aggregate transition function';

alter function pg_catalog.int8_accum_inv() owner to postgres;

create function pg_catalog.int2_avg_accum_inv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_avg_accum_inv() is 'aggregate transition function';

alter function pg_catalog.int2_avg_accum_inv() owner to postgres;

create function pg_catalog.int4_avg_accum_inv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_avg_accum_inv() is 'aggregate transition function';

alter function pg_catalog.int4_avg_accum_inv() owner to postgres;

create function pg_catalog.int2int4_sum()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2int4_sum() is 'aggregate final function';

alter function pg_catalog.int2int4_sum() owner to postgres;

create function pg_catalog.inet_gist_fetch()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_fetch() is 'GiST support';

alter function pg_catalog.inet_gist_fetch() owner to postgres;

create function pg_catalog.pg_logical_emit_message(text)
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_emit_message(text) is 'emit a textual logical decoding message';

alter function pg_catalog.pg_logical_emit_message(text) owner to postgres;

create function pg_catalog.pg_logical_emit_message(bytea)
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_emit_message(bytea) is 'emit a binary logical decoding message';

alter function pg_catalog.pg_logical_emit_message(bytea) owner to postgres;

create function pg_catalog.jsonb_insert()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_insert() is 'Insert value into a jsonb';

alter function pg_catalog.jsonb_insert() owner to postgres;

create function pg_catalog.pg_xact_commit_timestamp()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_xact_commit_timestamp() is 'get commit timestamp of a transaction';

alter function pg_catalog.pg_xact_commit_timestamp() owner to postgres;

create function pg_catalog.binary_upgrade_set_next_pg_type_oid()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_pg_type_oid() is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_pg_type_oid() owner to postgres;

create function pg_catalog.pg_last_committed_xact()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_committed_xact() is 'get transaction Id and commit timestamp of latest transaction commit';

alter function pg_catalog.pg_last_committed_xact() owner to postgres;

create function pg_catalog.binary_upgrade_set_next_array_pg_type_oid()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_array_pg_type_oid() is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_array_pg_type_oid() owner to postgres;

create function pg_catalog.binary_upgrade_set_next_toast_pg_type_oid()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_toast_pg_type_oid() is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_toast_pg_type_oid() owner to postgres;

create function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid() is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid() owner to postgres;

create function pg_catalog.binary_upgrade_set_next_index_pg_class_oid()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_index_pg_class_oid() is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_index_pg_class_oid() owner to postgres;

create function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid() is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid() owner to postgres;

create function pg_catalog.binary_upgrade_set_next_pg_enum_oid()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_pg_enum_oid() is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_pg_enum_oid() owner to postgres;

create function pg_catalog.binary_upgrade_set_next_pg_authid_oid()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_pg_authid_oid() is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_pg_authid_oid() owner to postgres;

create function pg_catalog.binary_upgrade_create_empty_extension()
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_create_empty_extension() is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_create_empty_extension() owner to postgres;

create function pg_catalog.event_trigger_in()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.event_trigger_in() is 'I/O';

alter function pg_catalog.event_trigger_in() owner to postgres;

create function pg_catalog.event_trigger_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.event_trigger_out() is 'I/O';

alter function pg_catalog.event_trigger_out() owner to postgres;

create function pg_catalog.tsvectorin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorin() is 'I/O';

alter function pg_catalog.tsvectorin() owner to postgres;

create function pg_catalog.tsvectorout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorout() is 'I/O';

alter function pg_catalog.tsvectorout() owner to postgres;

create function pg_catalog.tsqueryin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsqueryin() is 'I/O';

alter function pg_catalog.tsqueryin() owner to postgres;

create function pg_catalog.tsqueryout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsqueryout() is 'I/O';

alter function pg_catalog.tsqueryout() owner to postgres;

create function pg_catalog.tsvector_lt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_lt() is 'implementation of < operator';

alter function pg_catalog.tsvector_lt() owner to postgres;

create function pg_catalog.tsvector_le()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_le() is 'implementation of <= operator';

alter function pg_catalog.tsvector_le() owner to postgres;

create function pg_catalog.tsvector_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_eq() is 'implementation of = operator';

alter function pg_catalog.tsvector_eq() owner to postgres;

create function pg_catalog.tsvector_ne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_ne() is 'implementation of <> operator';

alter function pg_catalog.tsvector_ne() owner to postgres;

create function pg_catalog.tsvector_ge()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_ge() is 'implementation of >= operator';

alter function pg_catalog.tsvector_ge() owner to postgres;

create function pg_catalog.tsvector_gt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_gt() is 'implementation of > operator';

alter function pg_catalog.tsvector_gt() owner to postgres;

create function pg_catalog.tsvector_cmp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_cmp() is 'less-equal-greater';

alter function pg_catalog.tsvector_cmp() owner to postgres;

create function pg_catalog.strip()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.strip() is 'strip position information';

alter function pg_catalog.strip() owner to postgres;

create function pg_catalog.setweight()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setweight() is 'set given weight for whole tsvector';

alter function pg_catalog.setweight() owner to postgres;

create function pg_catalog.tsvector_concat()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_concat() is 'implementation of || operator';

alter function pg_catalog.tsvector_concat() owner to postgres;

create function pg_catalog.ts_match_vq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_vq() is 'implementation of @@ operator';

alter function pg_catalog.ts_match_vq() owner to postgres;

create function pg_catalog.ts_match_qv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_qv() is 'implementation of @@ operator';

alter function pg_catalog.ts_match_qv() owner to postgres;

create function pg_catalog.tsvectorsend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorsend() is 'I/O';

alter function pg_catalog.tsvectorsend() owner to postgres;

create function pg_catalog.tsvectorrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorrecv() is 'I/O';

alter function pg_catalog.tsvectorrecv() owner to postgres;

create function pg_catalog.tsquerysend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquerysend() is 'I/O';

alter function pg_catalog.tsquerysend() owner to postgres;

create function pg_catalog.tsqueryrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsqueryrecv() is 'I/O';

alter function pg_catalog.tsqueryrecv() owner to postgres;

create function pg_catalog.gtsvectorin()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvectorin() is 'I/O';

alter function pg_catalog.gtsvectorin() owner to postgres;

create function pg_catalog.gtsvectorout()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvectorout() is 'I/O';

alter function pg_catalog.gtsvectorout() owner to postgres;

create function pg_catalog.gtsvector_compress()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_compress() is 'GiST tsvector support';

alter function pg_catalog.gtsvector_compress() owner to postgres;

create function pg_catalog.gtsvector_decompress()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_decompress() is 'GiST tsvector support';

alter function pg_catalog.gtsvector_decompress() owner to postgres;

create function pg_catalog.gtsvector_picksplit()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_picksplit() is 'GiST tsvector support';

alter function pg_catalog.gtsvector_picksplit() owner to postgres;

create function pg_catalog.gtsvector_union()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_union() is 'GiST tsvector support';

alter function pg_catalog.gtsvector_union() owner to postgres;

create function pg_catalog.gtsvector_same()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_same() is 'GiST tsvector support';

alter function pg_catalog.gtsvector_same() owner to postgres;

create function pg_catalog.gtsvector_penalty()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_penalty() is 'GiST tsvector support';

alter function pg_catalog.gtsvector_penalty() owner to postgres;

create function pg_catalog.gtsvector_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_consistent() is 'GiST tsvector support';

alter function pg_catalog.gtsvector_consistent() owner to postgres;

create function pg_catalog.gin_extract_tsvector()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsvector() is 'GIN tsvector support';

alter function pg_catalog.gin_extract_tsvector() owner to postgres;

create function pg_catalog.gin_extract_tsquery(tsvector, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsquery(tsvector, internal, internal) is 'GIN tsvector support';

alter function pg_catalog.gin_extract_tsquery(tsvector, internal, internal) owner to postgres;

create function pg_catalog.gin_tsquery_consistent(tsvector, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_consistent(tsvector, internal, internal) is 'GIN tsvector support';

alter function pg_catalog.gin_tsquery_consistent(tsvector, internal, internal) owner to postgres;

create function pg_catalog.tsquery_lt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_lt() is 'implementation of < operator';

alter function pg_catalog.tsquery_lt() owner to postgres;

create function pg_catalog.tsquery_le()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_le() is 'implementation of <= operator';

alter function pg_catalog.tsquery_le() owner to postgres;

create function pg_catalog.tsquery_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_eq() is 'implementation of = operator';

alter function pg_catalog.tsquery_eq() owner to postgres;

create function pg_catalog.tsquery_ne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_ne() is 'implementation of <> operator';

alter function pg_catalog.tsquery_ne() owner to postgres;

create function pg_catalog.tsquery_ge()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_ge() is 'implementation of >= operator';

alter function pg_catalog.tsquery_ge() owner to postgres;

create function pg_catalog.tsquery_gt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_gt() is 'implementation of > operator';

alter function pg_catalog.tsquery_gt() owner to postgres;

create function pg_catalog.tsquery_cmp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_cmp() is 'less-equal-greater';

alter function pg_catalog.tsquery_cmp() owner to postgres;

create function pg_catalog.tsquery_and()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_and() is 'implementation of && operator';

alter function pg_catalog.tsquery_and() owner to postgres;

create function pg_catalog.tsquery_or()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_or() is 'implementation of || operator';

alter function pg_catalog.tsquery_or() owner to postgres;

create function pg_catalog.tsquery_not()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_not() is 'implementation of !! operator';

alter function pg_catalog.tsquery_not() owner to postgres;

create function pg_catalog.numnode()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numnode() is 'number of nodes';

alter function pg_catalog.numnode() owner to postgres;

create function pg_catalog.querytree()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.querytree() is 'show real useful query for GiST index';

alter function pg_catalog.querytree() owner to postgres;

create function pg_catalog.ts_rewrite()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rewrite() is 'rewrite tsquery';

alter function pg_catalog.ts_rewrite() owner to postgres;

create function pg_catalog.ts_rewrite()
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rewrite() is 'rewrite tsquery';

alter function pg_catalog.ts_rewrite() owner to postgres;

create function pg_catalog.tsmatchsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsmatchsel() is 'restriction selectivity of tsvector @@ tsquery';

alter function pg_catalog.tsmatchsel() owner to postgres;

create function pg_catalog.tsmatchjoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsmatchjoinsel() is 'join selectivity of tsvector @@ tsquery';

alter function pg_catalog.tsmatchjoinsel() owner to postgres;

create function pg_catalog.ts_typanalyze()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_typanalyze() is 'tsvector typanalyze';

alter function pg_catalog.ts_typanalyze() owner to postgres;

create function pg_catalog.ts_stat()
    strict
    cost 10
    rows 10000
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_stat() is 'statistics of tsvector column';

alter function pg_catalog.ts_stat() owner to postgres;

create function pg_catalog.ts_stat()
    strict
    cost 10
    rows 10000
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_stat() is 'statistics of tsvector column';

alter function pg_catalog.ts_stat() owner to postgres;

create function pg_catalog.tsq_mcontains()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsq_mcontains() is 'implementation of @> operator';

alter function pg_catalog.tsq_mcontains() owner to postgres;

create function pg_catalog.tsq_mcontained()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsq_mcontained() is 'implementation of <@ operator';

alter function pg_catalog.tsq_mcontained() owner to postgres;

create function pg_catalog.gtsquery_compress()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_compress() is 'GiST tsquery support';

alter function pg_catalog.gtsquery_compress() owner to postgres;

create function pg_catalog.starts_with()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.starts_with() is 'implementation of ^@ operator';

alter function pg_catalog.starts_with() owner to postgres;

create function pg_catalog.gtsquery_picksplit()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_picksplit() is 'GiST tsquery support';

alter function pg_catalog.gtsquery_picksplit() owner to postgres;

create function pg_catalog.gtsquery_union()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_union() is 'GiST tsquery support';

alter function pg_catalog.gtsquery_union() owner to postgres;

create function pg_catalog.gtsquery_same()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_same() is 'GiST tsquery support';

alter function pg_catalog.gtsquery_same() owner to postgres;

create function pg_catalog.gtsquery_penalty()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_penalty() is 'GiST tsquery support';

alter function pg_catalog.gtsquery_penalty() owner to postgres;

create function pg_catalog.gtsquery_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_consistent() is 'GiST tsquery support';

alter function pg_catalog.gtsquery_consistent() owner to postgres;

create function pg_catalog.ts_rank()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank() is 'relevance';

alter function pg_catalog.ts_rank() owner to postgres;

create function pg_catalog.ts_rank()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank() is 'relevance';

alter function pg_catalog.ts_rank() owner to postgres;

create function pg_catalog.ts_rank_cd()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd() is 'relevance';

alter function pg_catalog.ts_rank_cd() owner to postgres;

create function pg_catalog.ts_rank_cd()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd() is 'relevance';

alter function pg_catalog.ts_rank_cd() owner to postgres;

create function pg_catalog.length(tsvector) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(tsvector) is 'number of lexemes';

alter function pg_catalog.length(tsvector) owner to postgres;

create function pg_catalog.ts_token_type()
    immutable
    strict
    parallel safe
    cost 1
    rows 16
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_token_type() is 'get parser''s token types';

alter function pg_catalog.ts_token_type() owner to postgres;

create function pg_catalog.ts_token_type()
    stable
    strict
    parallel safe
    cost 1
    rows 16
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_token_type() is 'get parser''s token types';

alter function pg_catalog.ts_token_type() owner to postgres;

create function pg_catalog.ts_parse()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_parse() is 'parse text to tokens';

alter function pg_catalog.ts_parse() owner to postgres;

create function pg_catalog.ts_parse()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_parse() is 'parse text to tokens';

alter function pg_catalog.ts_parse() owner to postgres;

create function pg_catalog.prsd_start()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_start() is '(internal)';

alter function pg_catalog.prsd_start() owner to postgres;

create function pg_catalog.prsd_nexttoken()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_nexttoken() is '(internal)';

alter function pg_catalog.prsd_nexttoken() owner to postgres;

create function pg_catalog.prsd_end()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_end() is '(internal)';

alter function pg_catalog.prsd_end() owner to postgres;

create function pg_catalog.prsd_headline()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_headline() is '(internal)';

alter function pg_catalog.prsd_headline() owner to postgres;

create function pg_catalog.prsd_lextype()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_lextype() is '(internal)';

alter function pg_catalog.prsd_lextype() owner to postgres;

create function pg_catalog.ts_lexize()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_lexize() is 'normalize one word by dictionary';

alter function pg_catalog.ts_lexize() owner to postgres;

create function pg_catalog.gin_cmp_tslexeme()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_cmp_tslexeme() is 'GIN tsvector support';

alter function pg_catalog.gin_cmp_tslexeme() owner to postgres;

create function pg_catalog.dsimple_init()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsimple_init() is '(internal)';

alter function pg_catalog.dsimple_init() owner to postgres;

create function pg_catalog.dsimple_lexize()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsimple_lexize() is '(internal)';

alter function pg_catalog.dsimple_lexize() owner to postgres;

create function pg_catalog.dsynonym_init()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsynonym_init() is '(internal)';

alter function pg_catalog.dsynonym_init() owner to postgres;

create function pg_catalog.dsynonym_lexize()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsynonym_lexize() is '(internal)';

alter function pg_catalog.dsynonym_lexize() owner to postgres;

create function pg_catalog.dispell_init()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dispell_init() is '(internal)';

alter function pg_catalog.dispell_init() owner to postgres;

create function pg_catalog.dispell_lexize()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dispell_lexize() is '(internal)';

alter function pg_catalog.dispell_lexize() owner to postgres;

create function pg_catalog.regconfigin()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigin() is 'I/O';

alter function pg_catalog.regconfigin() owner to postgres;

create function pg_catalog.regconfigout()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigout() is 'I/O';

alter function pg_catalog.regconfigout() owner to postgres;

create function pg_catalog.regconfigrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigrecv() is 'I/O';

alter function pg_catalog.regconfigrecv() owner to postgres;

create function pg_catalog.regconfigsend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigsend() is 'I/O';

alter function pg_catalog.regconfigsend() owner to postgres;

create function pg_catalog.thesaurus_init()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.thesaurus_init() is '(internal)';

alter function pg_catalog.thesaurus_init() owner to postgres;

create function pg_catalog.thesaurus_lexize()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.thesaurus_lexize() is '(internal)';

alter function pg_catalog.thesaurus_lexize() owner to postgres;

create function pg_catalog.ts_headline()
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline() is 'generate headline';

alter function pg_catalog.ts_headline() owner to postgres;

create function pg_catalog.to_tsvector()
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector() is 'transform to tsvector';

alter function pg_catalog.to_tsvector() owner to postgres;

create function pg_catalog.to_tsquery()
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsquery() is 'make tsquery';

alter function pg_catalog.to_tsquery() owner to postgres;

create function pg_catalog.plainto_tsquery()
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.plainto_tsquery() is 'transform to tsquery';

alter function pg_catalog.plainto_tsquery() owner to postgres;

create function pg_catalog.to_tsvector()
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector() is 'transform to tsvector';

alter function pg_catalog.to_tsvector() owner to postgres;

create function pg_catalog.to_tsquery()
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsquery() is 'make tsquery';

alter function pg_catalog.to_tsquery() owner to postgres;

create function pg_catalog.plainto_tsquery()
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.plainto_tsquery() is 'transform to tsquery';

alter function pg_catalog.plainto_tsquery() owner to postgres;

create function pg_catalog.tsvector_update_trigger()
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_update_trigger() is 'trigger for automatic update of tsvector column';

alter function pg_catalog.tsvector_update_trigger() owner to postgres;

create function pg_catalog.tsvector_update_trigger_column()
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_update_trigger_column() is 'trigger for automatic update of tsvector column';

alter function pg_catalog.tsvector_update_trigger_column() owner to postgres;

create function pg_catalog.ts_headline()
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline() is 'generate headline';

alter function pg_catalog.ts_headline() owner to postgres;

create function pg_catalog.pg_ts_parser_is_visible()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_parser_is_visible() is 'is text search parser visible in search path?';

alter function pg_catalog.pg_ts_parser_is_visible() owner to postgres;

create function pg_catalog.pg_ts_dict_is_visible()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_dict_is_visible() is 'is text search dictionary visible in search path?';

alter function pg_catalog.pg_ts_dict_is_visible() owner to postgres;

create function pg_catalog.pg_ts_config_is_visible()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_config_is_visible() is 'is text search configuration visible in search path?';

alter function pg_catalog.pg_ts_config_is_visible() owner to postgres;

create function pg_catalog.get_current_ts_config()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_current_ts_config() is 'get current tsearch configuration';

alter function pg_catalog.get_current_ts_config() owner to postgres;

create function pg_catalog.ts_match_tt()
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_tt() is 'implementation of @@ operator';

alter function pg_catalog.ts_match_tt() owner to postgres;

create function pg_catalog.ts_match_tq()
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_tq() is 'implementation of @@ operator';

alter function pg_catalog.ts_match_tq() owner to postgres;

create function pg_catalog.pg_ts_template_is_visible()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_template_is_visible() is 'is text search template visible in search path?';

alter function pg_catalog.pg_ts_template_is_visible() owner to postgres;

create function pg_catalog.regdictionaryin()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionaryin() is 'I/O';

alter function pg_catalog.regdictionaryin() owner to postgres;

create function pg_catalog.regdictionaryout()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionaryout() is 'I/O';

alter function pg_catalog.regdictionaryout() owner to postgres;

create function pg_catalog.regdictionaryrecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionaryrecv() is 'I/O';

alter function pg_catalog.regdictionaryrecv() owner to postgres;

create function pg_catalog.regdictionarysend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionarysend() is 'I/O';

alter function pg_catalog.regdictionarysend() owner to postgres;

create function pg_catalog.pg_stat_reset_shared()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_shared() is 'statistics: reset collected statistics shared across the cluster';

alter function pg_catalog.pg_stat_reset_shared() owner to postgres;

create function pg_catalog.pg_stat_reset_single_table_counters()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_single_table_counters() is 'statistics: reset collected statistics for a single table or index in the current database';

alter function pg_catalog.pg_stat_reset_single_table_counters() owner to postgres;

create function pg_catalog.pg_stat_reset_single_function_counters()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_single_function_counters() is 'statistics: reset collected statistics for a single function in the current database';

alter function pg_catalog.pg_stat_reset_single_function_counters() owner to postgres;

create function pg_catalog.pg_tablespace_location()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_tablespace_location() is 'tablespace location';

alter function pg_catalog.pg_tablespace_location() owner to postgres;

create function pg_catalog.pg_create_physical_replication_slot()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_create_physical_replication_slot() is 'create a physical replication slot';

alter function pg_catalog.pg_create_physical_replication_slot() owner to postgres;

create function pg_catalog.pg_drop_replication_slot()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_drop_replication_slot() is 'drop a replication slot';

alter function pg_catalog.pg_drop_replication_slot() owner to postgres;

create function pg_catalog.pg_get_replication_slots()
    stable
    parallel safe
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_replication_slots() is 'information about replication slots currently in use';

alter function pg_catalog.pg_get_replication_slots() owner to postgres;

create function pg_catalog.pg_logical_slot_get_changes()
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_slot_get_changes() is 'get changes from replication slot';

alter function pg_catalog.pg_logical_slot_get_changes() owner to postgres;

create function pg_catalog.pg_logical_slot_get_binary_changes()
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_slot_get_binary_changes() is 'get binary changes from replication slot';

alter function pg_catalog.pg_logical_slot_get_binary_changes() owner to postgres;

create function pg_catalog.pg_logical_slot_peek_changes()
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_slot_peek_changes() is 'peek at changes from replication slot';

alter function pg_catalog.pg_logical_slot_peek_changes() owner to postgres;

create function pg_catalog.pg_logical_slot_peek_binary_changes()
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_slot_peek_binary_changes() is 'peek at binary changes from replication slot';

alter function pg_catalog.pg_logical_slot_peek_binary_changes() owner to postgres;

create function pg_catalog.pg_create_logical_replication_slot()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_create_logical_replication_slot() is 'set up a logical replication slot';

alter function pg_catalog.pg_create_logical_replication_slot() owner to postgres;

create function pg_catalog.to_jsonb()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_jsonb() is 'map input to jsonb';

alter function pg_catalog.to_jsonb() owner to postgres;

create function pg_catalog.pg_stat_get_snapshot_timestamp()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_snapshot_timestamp() is 'statistics: timestamp of the current statistics snapshot';

alter function pg_catalog.pg_stat_get_snapshot_timestamp() owner to postgres;

create function pg_catalog.gin_clean_pending_list()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_clean_pending_list() is 'clean up GIN pending list';

alter function pg_catalog.gin_clean_pending_list() owner to postgres;

create function pg_catalog.gtsvector_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_consistent() is 'GiST tsvector support (obsolete)';

alter function pg_catalog.gtsvector_consistent() owner to postgres;

create function pg_catalog.gin_extract_tsquery()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsquery() is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_extract_tsquery() owner to postgres;

create function pg_catalog.gin_tsquery_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_consistent() is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_tsquery_consistent() owner to postgres;

create function pg_catalog.gtsquery_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_consistent() is 'GiST tsquery support (obsolete)';

alter function pg_catalog.gtsquery_consistent() owner to postgres;

create function pg_catalog.inet_spg_config()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_config() is 'SP-GiST support';

alter function pg_catalog.inet_spg_config() owner to postgres;

create function pg_catalog.inet_spg_choose()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_choose() is 'SP-GiST support';

alter function pg_catalog.inet_spg_choose() owner to postgres;

create function pg_catalog.inet_spg_picksplit()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_picksplit() is 'SP-GiST support';

alter function pg_catalog.inet_spg_picksplit() owner to postgres;

create function pg_catalog.inet_spg_inner_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_inner_consistent() is 'SP-GiST support';

alter function pg_catalog.inet_spg_inner_consistent() owner to postgres;

create function pg_catalog.inet_spg_leaf_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_leaf_consistent() is 'SP-GiST support';

alter function pg_catalog.inet_spg_leaf_consistent() owner to postgres;

create function pg_catalog.pg_current_logfile()
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_logfile() is 'current logging collector file location';

alter function pg_catalog.pg_current_logfile() owner to postgres;

create function pg_catalog.pg_current_logfile()
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_logfile() is 'current logging collector file location';

alter function pg_catalog.pg_current_logfile() owner to postgres;

create function pg_catalog.jsonb_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_send() is 'I/O';

alter function pg_catalog.jsonb_send() owner to postgres;

create function pg_catalog.jsonb_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_out() is 'I/O';

alter function pg_catalog.jsonb_out() owner to postgres;

create function pg_catalog.jsonb_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_recv() is 'I/O';

alter function pg_catalog.jsonb_recv() owner to postgres;

create function pg_catalog.jsonb_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_in() is 'I/O';

alter function pg_catalog.jsonb_in() owner to postgres;

create function pg_catalog.pg_get_function_arg_default()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_arg_default() is 'function argument default';

alter function pg_catalog.pg_get_function_arg_default() owner to postgres;

create function pg_catalog.pg_export_snapshot()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_export_snapshot() is 'export a snapshot';

alter function pg_catalog.pg_export_snapshot() owner to postgres;

create function pg_catalog.pg_is_in_recovery()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_in_recovery() is 'true if server is in recovery';

alter function pg_catalog.pg_is_in_recovery() owner to postgres;

create function pg_catalog.money(integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.money(integer) is 'convert int4 to money';

alter function pg_catalog.money(integer) owner to postgres;

create function pg_catalog.money(bigint)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.money(bigint) is 'convert int8 to money';

alter function pg_catalog.money(bigint) owner to postgres;

create function pg_catalog.pg_is_in_backup()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_in_backup() is 'true if server is in online backup';

alter function pg_catalog.pg_is_in_backup() owner to postgres;

create function pg_catalog.pg_backup_start_time()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_backup_start_time() is 'start time of an online backup';

alter function pg_catalog.pg_backup_start_time() owner to postgres;

create function pg_catalog.pg_collation_is_visible()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_collation_is_visible() is 'is collation visible in search path?';

alter function pg_catalog.pg_collation_is_visible() owner to postgres;

create function pg_catalog.array_typanalyze()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_typanalyze() is 'array typanalyze';

alter function pg_catalog.array_typanalyze() owner to postgres;

create function pg_catalog.arraycontsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontsel() is 'restriction selectivity for array-containment operators';

alter function pg_catalog.arraycontsel() owner to postgres;

create function pg_catalog.arraycontjoinsel()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontjoinsel() is 'join selectivity for array-containment operators';

alter function pg_catalog.arraycontjoinsel() owner to postgres;

create function pg_catalog.pg_get_multixact_members()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_multixact_members() is 'view members of a multixactid';

alter function pg_catalog.pg_get_multixact_members() owner to postgres;

create function pg_catalog.pg_last_wal_receive_lsn()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_wal_receive_lsn() is 'current wal flush location';

alter function pg_catalog.pg_last_wal_receive_lsn() owner to postgres;

create function pg_catalog.pg_last_wal_replay_lsn()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_wal_replay_lsn() is 'last wal replay location';

alter function pg_catalog.pg_last_wal_replay_lsn() owner to postgres;

create function pg_catalog.cash_div_cash()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_cash() is 'implementation of / operator';

alter function pg_catalog.cash_div_cash() owner to postgres;

create function pg_catalog.numeric(money)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(money) is 'convert money to numeric';

alter function pg_catalog.numeric(money) owner to postgres;

create function pg_catalog.money(numeric)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.money(numeric) is 'convert numeric to money';

alter function pg_catalog.money(numeric) owner to postgres;

create function pg_catalog.pg_read_file()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file() is 'read text from a file';

alter function pg_catalog.pg_read_file() owner to postgres;

create function pg_catalog.pg_read_binary_file()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_binary_file() is 'read bytea from a file';

alter function pg_catalog.pg_read_binary_file() owner to postgres;

create function pg_catalog.pg_read_binary_file()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_binary_file() is 'read bytea from a file';

alter function pg_catalog.pg_read_binary_file() owner to postgres;

create function pg_catalog.pg_opfamily_is_visible()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_opfamily_is_visible() is 'is opfamily visible in search path?';

alter function pg_catalog.pg_opfamily_is_visible() owner to postgres;

create function pg_catalog.pg_last_xact_replay_timestamp()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_xact_replay_timestamp() is 'timestamp of last replay xact';

alter function pg_catalog.pg_last_xact_replay_timestamp() owner to postgres;

create function pg_catalog.anyrange_in()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyrange_in() is 'I/O';

alter function pg_catalog.anyrange_in() owner to postgres;

create function pg_catalog.anyrange_out()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyrange_out() is 'I/O';

alter function pg_catalog.anyrange_out() owner to postgres;

create function pg_catalog.range_in()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_in() is 'I/O';

alter function pg_catalog.range_in() owner to postgres;

create function pg_catalog.range_out()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_out() is 'I/O';

alter function pg_catalog.range_out() owner to postgres;

create function pg_catalog.range_recv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_recv() is 'I/O';

alter function pg_catalog.range_recv() owner to postgres;

create function pg_catalog.range_send()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_send() is 'I/O';

alter function pg_catalog.range_send() owner to postgres;

create function pg_catalog.pg_identify_object()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_identify_object() is 'get machine-parseable identification of SQL object';

alter function pg_catalog.pg_identify_object() owner to postgres;

create function pg_catalog.int4range()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range() is 'int4range constructor';

alter function pg_catalog.int4range() owner to postgres;

create function pg_catalog.int4range()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range() is 'int4range constructor';

alter function pg_catalog.int4range() owner to postgres;

create function pg_catalog.pg_relation_is_updatable()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_is_updatable() is 'is a relation insertable/updatable/deletable';

alter function pg_catalog.pg_relation_is_updatable() owner to postgres;

create function pg_catalog.pg_column_is_updatable()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_column_is_updatable() is 'is a column updatable';

alter function pg_catalog.pg_column_is_updatable() owner to postgres;

create function pg_catalog.numrange()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numrange() is 'numrange constructor';

alter function pg_catalog.numrange() owner to postgres;

create function pg_catalog.numrange()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numrange() is 'numrange constructor';

alter function pg_catalog.numrange() owner to postgres;

create function pg_catalog.make_date()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_date() is 'construct date';

alter function pg_catalog.make_date() owner to postgres;

create function pg_catalog.make_time()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_time() is 'construct time';

alter function pg_catalog.make_time() owner to postgres;

create function pg_catalog.lower()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower() is 'lower bound of range';

alter function pg_catalog.lower() owner to postgres;

create function pg_catalog.upper()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper() is 'upper bound of range';

alter function pg_catalog.upper() owner to postgres;

create function pg_catalog.isempty()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isempty() is 'is the range empty?';

alter function pg_catalog.isempty() owner to postgres;

create function pg_catalog.lower_inc()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower_inc() is 'is the range''s lower bound inclusive?';

alter function pg_catalog.lower_inc() owner to postgres;

create function pg_catalog.upper_inc()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper_inc() is 'is the range''s upper bound inclusive?';

alter function pg_catalog.upper_inc() owner to postgres;

create function pg_catalog.lower_inf()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower_inf() is 'is the range''s lower bound infinite?';

alter function pg_catalog.lower_inf() owner to postgres;

create function pg_catalog.upper_inf()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper_inf() is 'is the range''s upper bound infinite?';

alter function pg_catalog.upper_inf() owner to postgres;

create function pg_catalog.range_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_eq() is 'implementation of = operator';

alter function pg_catalog.range_eq() owner to postgres;

create function pg_catalog.range_ne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_ne() is 'implementation of <> operator';

alter function pg_catalog.range_ne() owner to postgres;

create function pg_catalog.range_overlaps()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overlaps() is 'implementation of && operator';

alter function pg_catalog.range_overlaps() owner to postgres;

create function pg_catalog.range_contains_elem()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contains_elem() is 'implementation of @> operator';

alter function pg_catalog.range_contains_elem() owner to postgres;

create function pg_catalog.range_contains()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contains() is 'implementation of @> operator';

alter function pg_catalog.range_contains() owner to postgres;

create function pg_catalog.elem_contained_by_range()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.elem_contained_by_range() is 'implementation of <@ operator';

alter function pg_catalog.elem_contained_by_range() owner to postgres;

create function pg_catalog.range_contained_by()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contained_by() is 'implementation of <@ operator';

alter function pg_catalog.range_contained_by() owner to postgres;

create function pg_catalog.range_adjacent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_adjacent() is 'implementation of -|- operator';

alter function pg_catalog.range_adjacent() owner to postgres;

create function pg_catalog.range_before()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_before() is 'implementation of << operator';

alter function pg_catalog.range_before() owner to postgres;

create function pg_catalog.range_after()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_after() is 'implementation of >> operator';

alter function pg_catalog.range_after() owner to postgres;

create function pg_catalog.range_overleft()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overleft() is 'implementation of &< operator';

alter function pg_catalog.range_overleft() owner to postgres;

create function pg_catalog.range_overright()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overright() is 'implementation of &> operator';

alter function pg_catalog.range_overright() owner to postgres;

create function pg_catalog.range_union()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_union() is 'implementation of + operator';

alter function pg_catalog.range_union() owner to postgres;

create function pg_catalog.range_intersect()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_intersect() is 'implementation of * operator';

alter function pg_catalog.range_intersect() owner to postgres;

create function pg_catalog.range_minus()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_minus() is 'implementation of - operator';

alter function pg_catalog.range_minus() owner to postgres;

create function pg_catalog.range_cmp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_cmp() is 'less-equal-greater';

alter function pg_catalog.range_cmp() owner to postgres;

create function pg_catalog.range_lt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_lt() is 'implementation of < operator';

alter function pg_catalog.range_lt() owner to postgres;

create function pg_catalog.range_le()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_le() is 'implementation of <= operator';

alter function pg_catalog.range_le() owner to postgres;

create function pg_catalog.range_ge()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_ge() is 'implementation of >= operator';

alter function pg_catalog.range_ge() owner to postgres;

create function pg_catalog.range_gt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gt() is 'implementation of > operator';

alter function pg_catalog.range_gt() owner to postgres;

create function pg_catalog.range_gist_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_consistent() is 'GiST support';

alter function pg_catalog.range_gist_consistent() owner to postgres;

create function pg_catalog.range_gist_union()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_union() is 'GiST support';

alter function pg_catalog.range_gist_union() owner to postgres;

create function pg_catalog.pg_replication_slot_advance()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_slot_advance() is 'advance logical replication slot';

alter function pg_catalog.pg_replication_slot_advance() owner to postgres;

create function pg_catalog.range_gist_penalty()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_penalty() is 'GiST support';

alter function pg_catalog.range_gist_penalty() owner to postgres;

create function pg_catalog.range_gist_picksplit()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_picksplit() is 'GiST support';

alter function pg_catalog.range_gist_picksplit() owner to postgres;

create function pg_catalog.range_gist_same()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_same() is 'GiST support';

alter function pg_catalog.range_gist_same() owner to postgres;

create function pg_catalog.hash_range()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_range() is 'hash a range';

alter function pg_catalog.hash_range() owner to postgres;

create function pg_catalog.int4range_canonical()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range_canonical() is 'convert an int4 range to canonical form';

alter function pg_catalog.int4range_canonical() owner to postgres;

create function pg_catalog.daterange_canonical()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange_canonical() is 'convert a date range to canonical form';

alter function pg_catalog.daterange_canonical() owner to postgres;

create function pg_catalog.range_typanalyze()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_typanalyze() is 'range typanalyze';

alter function pg_catalog.range_typanalyze() owner to postgres;

create function pg_catalog.timestamp_support()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_support() is 'planner support for timestamp length coercion';

alter function pg_catalog.timestamp_support() owner to postgres;

create function pg_catalog.interval_support()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_support() is 'planner support for interval length coercion';

alter function pg_catalog.interval_support() owner to postgres;

create function pg_catalog.ginarraytriconsistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarraytriconsistent() is 'GIN array support';

alter function pg_catalog.ginarraytriconsistent() owner to postgres;

create function pg_catalog.gin_tsquery_triconsistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_triconsistent() is 'GIN tsvector support';

alter function pg_catalog.gin_tsquery_triconsistent() owner to postgres;

create function pg_catalog.int4range_subdiff()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range_subdiff() is 'float8 difference of two int4 values';

alter function pg_catalog.int4range_subdiff() owner to postgres;

create function pg_catalog.int8range_subdiff()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range_subdiff() is 'float8 difference of two int8 values';

alter function pg_catalog.int8range_subdiff() owner to postgres;

create function pg_catalog.numrange_subdiff()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numrange_subdiff() is 'float8 difference of two numeric values';

alter function pg_catalog.numrange_subdiff() owner to postgres;

create function pg_catalog.daterange_subdiff()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange_subdiff() is 'float8 difference of two date values';

alter function pg_catalog.daterange_subdiff() owner to postgres;

create function pg_catalog.int8range_canonical()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range_canonical() is 'convert an int8 range to canonical form';

alter function pg_catalog.int8range_canonical() owner to postgres;

create function pg_catalog.tsrange_subdiff()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsrange_subdiff() is 'float8 difference of two timestamp values';

alter function pg_catalog.tsrange_subdiff() owner to postgres;

create function pg_catalog.tstzrange_subdiff()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzrange_subdiff() is 'float8 difference of two timestamp with time zone values';

alter function pg_catalog.tstzrange_subdiff() owner to postgres;

create function pg_catalog.jsonb_object_keys()
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_keys() is 'get jsonb object keys';

alter function pg_catalog.jsonb_object_keys() owner to postgres;

create function pg_catalog.jsonb_each_text()
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_each_text() is 'key value pairs of a jsonb object';

alter function pg_catalog.jsonb_each_text() owner to postgres;

create function pg_catalog.tsrange()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsrange() is 'tsrange constructor';

alter function pg_catalog.tsrange() owner to postgres;

create function pg_catalog.tsrange()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsrange() is 'tsrange constructor';

alter function pg_catalog.tsrange() owner to postgres;

create function pg_catalog.pg_sleep_for(interval) returns void
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sleep_for() is 'sleep for the specified interval';

alter function pg_catalog.pg_sleep_for() owner to postgres;

create function pg_catalog.pg_sleep_until(timestamp with time zone) returns void
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sleep_until() is 'sleep until the specified time';

alter function pg_catalog.pg_sleep_until() owner to postgres;

create function pg_catalog.tstzrange()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzrange() is 'tstzrange constructor';

alter function pg_catalog.tstzrange() owner to postgres;

create function pg_catalog.tstzrange()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzrange() is 'tstzrange constructor';

alter function pg_catalog.tstzrange() owner to postgres;

create function pg_catalog.mxid_age()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mxid_age() is 'age of a multi-transaction ID, in multi-transactions before current multi-transaction';

alter function pg_catalog.mxid_age() owner to postgres;

create function pg_catalog.jsonb_extract_path_text()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_extract_path_text() is 'get value from jsonb as text with path elements';

alter function pg_catalog.jsonb_extract_path_text() owner to postgres;

create function pg_catalog.daterange()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange() is 'daterange constructor';

alter function pg_catalog.daterange() owner to postgres;

create function pg_catalog.daterange()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange() is 'daterange constructor';

alter function pg_catalog.daterange() owner to postgres;

create function pg_catalog.acldefault()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acldefault() is 'show hardwired default privileges, primarily for use by the information schema';

alter function pg_catalog.acldefault() owner to postgres;

create function pg_catalog.time_support()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_support() is 'planner support for time length coercion';

alter function pg_catalog.time_support() owner to postgres;

create function pg_catalog.int8range()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range() is 'int8range constructor';

alter function pg_catalog.int8range() owner to postgres;

create function pg_catalog.int8range()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range() is 'int8range constructor';

alter function pg_catalog.int8range() owner to postgres;

create function pg_catalog.json_object_field()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_field() is 'implementation of -> operator';

alter function pg_catalog.json_object_field() owner to postgres;

create function pg_catalog.json_object_field_text()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_field_text() is 'implementation of ->> operator';

alter function pg_catalog.json_object_field_text() owner to postgres;

create function pg_catalog.json_array_element()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_element() is 'implementation of -> operator';

alter function pg_catalog.json_array_element() owner to postgres;

create function pg_catalog.json_array_element_text()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_element_text() is 'implementation of ->> operator';

alter function pg_catalog.json_array_element_text() owner to postgres;

create function pg_catalog.json_extract_path()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_extract_path() is 'get value from json with path elements';

alter function pg_catalog.json_extract_path() owner to postgres;

create function pg_catalog.brin_summarize_new_values()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_summarize_new_values() is 'brin: standalone scan new table pages';

alter function pg_catalog.brin_summarize_new_values() owner to postgres;

create function pg_catalog.json_extract_path_text()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_extract_path_text() is 'get value from json as text with path elements';

alter function pg_catalog.json_extract_path_text() owner to postgres;

create function pg_catalog.pg_get_object_address()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_object_address() is 'get OID-based object address from name/args arrays';

alter function pg_catalog.pg_get_object_address() owner to postgres;

create function pg_catalog.json_array_elements()
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_elements() is 'key value pairs of a json object';

alter function pg_catalog.json_array_elements() owner to postgres;

create function pg_catalog.json_array_length()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_length() is 'length of json array';

alter function pg_catalog.json_array_length() owner to postgres;

create function pg_catalog.json_object_keys()
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_keys() is 'get json object keys';

alter function pg_catalog.json_object_keys() owner to postgres;

create function pg_catalog.json_each()
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_each() is 'key value pairs of a json object';

alter function pg_catalog.json_each() owner to postgres;

create function pg_catalog.json_each_text()
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_each_text() is 'key value pairs of a json object';

alter function pg_catalog.json_each_text() owner to postgres;

create function pg_catalog.json_populate_record()
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_populate_record() is 'get record fields from a json object';

alter function pg_catalog.json_populate_record() owner to postgres;

create function pg_catalog.json_populate_recordset()
    stable
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_populate_recordset() is 'get set of records with fields from a json array of objects';

alter function pg_catalog.json_populate_recordset() owner to postgres;

create function pg_catalog.json_typeof()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_typeof() is 'get the type of a json value';

alter function pg_catalog.json_typeof() owner to postgres;

create function pg_catalog.json_array_elements_text()
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_elements_text() is 'elements of json array';

alter function pg_catalog.json_array_elements_text() owner to postgres;

create function pg_catalog.ordered_set_transition()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ordered_set_transition() is 'aggregate transition function';

alter function pg_catalog.ordered_set_transition() owner to postgres;

create function pg_catalog.ordered_set_transition_multi()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ordered_set_transition_multi() is 'aggregate transition function';

alter function pg_catalog.ordered_set_transition_multi() owner to postgres;

create function pg_catalog.percentile_disc_final()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_disc_final() is 'aggregate final function';

alter function pg_catalog.percentile_disc_final() owner to postgres;

create function pg_catalog.percentile_cont_float8_final()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_float8_final() is 'aggregate final function';

alter function pg_catalog.percentile_cont_float8_final() owner to postgres;

create function pg_catalog.percentile_cont_interval_final()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_interval_final() is 'aggregate final function';

alter function pg_catalog.percentile_cont_interval_final() owner to postgres;

create function pg_catalog.percentile_disc_multi_final()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_disc_multi_final() is 'aggregate final function';

alter function pg_catalog.percentile_disc_multi_final() owner to postgres;

create function pg_catalog.percentile_cont_float8_multi_final()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_float8_multi_final() is 'aggregate final function';

alter function pg_catalog.percentile_cont_float8_multi_final() owner to postgres;

create function pg_catalog.percentile_cont_interval_multi_final()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_interval_multi_final() is 'aggregate final function';

alter function pg_catalog.percentile_cont_interval_multi_final() owner to postgres;

create function pg_catalog.mode_final()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mode_final() is 'aggregate final function';

alter function pg_catalog.mode_final() owner to postgres;

create function pg_catalog.rank_final()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rank_final() is 'aggregate final function';

alter function pg_catalog.rank_final() owner to postgres;

create function pg_catalog.percent_rank_final()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percent_rank_final() is 'aggregate final function';

alter function pg_catalog.percent_rank_final() owner to postgres;

create function pg_catalog.cume_dist_final()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cume_dist_final() is 'aggregate final function';

alter function pg_catalog.cume_dist_final() owner to postgres;

create function pg_catalog.dense_rank_final()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dense_rank_final() is 'aggregate final function';

alter function pg_catalog.dense_rank_final() owner to postgres;

create function pg_catalog.generate_series_int4_support()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series_int4_support() is 'planner support for generate_series';

alter function pg_catalog.generate_series_int4_support() owner to postgres;

create function pg_catalog.generate_series_int8_support()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series_int8_support() is 'planner support for generate_series';

alter function pg_catalog.generate_series_int8_support() owner to postgres;

create function pg_catalog.array_unnest_support()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_unnest_support() is 'planner support for array_unnest';

alter function pg_catalog.array_unnest_support() owner to postgres;

create function pg_catalog.brin_summarize_range()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_summarize_range() is 'brin: standalone scan new table pages';

alter function pg_catalog.brin_summarize_range() owner to postgres;

create function pg_catalog.jsonpath_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_in() is 'I/O';

alter function pg_catalog.jsonpath_in() owner to postgres;

create function pg_catalog.jsonpath_recv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_recv() is 'I/O';

alter function pg_catalog.jsonpath_recv() owner to postgres;

create function pg_catalog.jsonpath_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_out() is 'I/O';

alter function pg_catalog.jsonpath_out() owner to postgres;

create function pg_catalog.jsonpath_send()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_send() is 'I/O';

alter function pg_catalog.jsonpath_send() owner to postgres;

create function pg_catalog.jsonb_path_exists()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_exists() is 'jsonpath exists test';

alter function pg_catalog.jsonb_path_exists() owner to postgres;

create function pg_catalog.jsonb_path_query()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query() is 'jsonpath query';

alter function pg_catalog.jsonb_path_query() owner to postgres;

create function pg_catalog.jsonb_path_query_array()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_array() is 'jsonpath query wrapped into array';

alter function pg_catalog.jsonb_path_query_array() owner to postgres;

create function pg_catalog.jsonb_path_query_first()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_first() is 'jsonpath query first item';

alter function pg_catalog.jsonb_path_query_first() owner to postgres;

create function pg_catalog.jsonb_path_match()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_match() is 'jsonpath match';

alter function pg_catalog.jsonb_path_match() owner to postgres;

create function pg_catalog.jsonb_path_exists_opr()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_exists_opr() is 'implementation of @? operator';

alter function pg_catalog.jsonb_path_exists_opr() owner to postgres;

create function pg_catalog.jsonb_path_match_opr()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_match_opr() is 'implementation of @@ operator';

alter function pg_catalog.jsonb_path_match_opr() owner to postgres;

create function pg_catalog.brin_desummarize_range()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_desummarize_range() is 'brin: desummarize page range';

alter function pg_catalog.brin_desummarize_range() owner to postgres;

create function pg_catalog.spg_quad_config()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_config() is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_config() owner to postgres;

create function pg_catalog.spg_quad_choose()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_choose() is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_choose() owner to postgres;

create function pg_catalog.spg_quad_picksplit()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_picksplit() is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_picksplit() owner to postgres;

create function pg_catalog.spg_quad_inner_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_inner_consistent() is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_inner_consistent() owner to postgres;

create function pg_catalog.spg_quad_leaf_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_leaf_consistent() is 'SP-GiST support for quad tree and k-d tree over point';

alter function pg_catalog.spg_quad_leaf_consistent() owner to postgres;

create function pg_catalog.spg_kd_config()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_config() is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_config() owner to postgres;

create function pg_catalog.spg_kd_choose()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_choose() is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_choose() owner to postgres;

create function pg_catalog.spg_kd_picksplit()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_picksplit() is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_picksplit() owner to postgres;

create function pg_catalog.spg_kd_inner_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_inner_consistent() is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_inner_consistent() owner to postgres;

create function pg_catalog.spg_text_config()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_config() is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_config() owner to postgres;

create function pg_catalog.spg_text_choose()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_choose() is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_choose() owner to postgres;

create function pg_catalog.spg_text_picksplit()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_picksplit() is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_picksplit() owner to postgres;

create function pg_catalog.spg_text_inner_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_inner_consistent() is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_inner_consistent() owner to postgres;

create function pg_catalog.spg_text_leaf_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_leaf_consistent() is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_leaf_consistent() owner to postgres;

create function pg_catalog.pg_sequence_last_value()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sequence_last_value() is 'sequence last value';

alter function pg_catalog.pg_sequence_last_value() owner to postgres;

create function pg_catalog.jsonb_ne()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_ne() is 'implementation of <> operator';

alter function pg_catalog.jsonb_ne() owner to postgres;

create function pg_catalog.jsonb_lt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_lt() is 'implementation of < operator';

alter function pg_catalog.jsonb_lt() owner to postgres;

create function pg_catalog.jsonb_gt()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_gt() is 'implementation of > operator';

alter function pg_catalog.jsonb_gt() owner to postgres;

create function pg_catalog.jsonb_le()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_le() is 'implementation of <= operator';

alter function pg_catalog.jsonb_le() owner to postgres;

create function pg_catalog.jsonb_ge()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_ge() is 'implementation of >= operator';

alter function pg_catalog.jsonb_ge() owner to postgres;

create function pg_catalog.jsonb_eq()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_eq() is 'implementation of = operator';

alter function pg_catalog.jsonb_eq() owner to postgres;

create function pg_catalog.jsonb_cmp()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_cmp() is 'less-equal-greater';

alter function pg_catalog.jsonb_cmp() owner to postgres;

create function pg_catalog.jsonb_hash()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_hash() is 'hash';

alter function pg_catalog.jsonb_hash() owner to postgres;

create function pg_catalog.jsonb_contains()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_contains() is 'implementation of @> operator';

alter function pg_catalog.jsonb_contains() owner to postgres;

create function pg_catalog.jsonb_exists()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_exists() is 'implementation of ? operator';

alter function pg_catalog.jsonb_exists() owner to postgres;

create function pg_catalog.jsonb_exists_any()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_exists_any() is 'implementation of ?| operator';

alter function pg_catalog.jsonb_exists_any() owner to postgres;

create function pg_catalog.jsonb_exists_all()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_exists_all() is 'implementation of ?& operator';

alter function pg_catalog.jsonb_exists_all() owner to postgres;

create function pg_catalog.jsonb_contained()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_contained() is 'implementation of <@ operator';

alter function pg_catalog.jsonb_contained() owner to postgres;

create function pg_catalog.array_agg_array_transfn()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_array_transfn() is 'aggregate transition function';

alter function pg_catalog.array_agg_array_transfn() owner to postgres;

create function pg_catalog.array_agg_array_finalfn()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_array_finalfn() is 'aggregate final function';

alter function pg_catalog.array_agg_array_finalfn() owner to postgres;

create function pg_catalog.range_merge()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_merge() is 'the smallest range which includes both of the given ranges';

alter function pg_catalog.range_merge() owner to postgres;

create function pg_catalog.inet_merge()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_merge() is 'the smallest network which includes both of the given networks';

alter function pg_catalog.inet_merge() owner to postgres;

create function pg_catalog.bound_box()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bound_box() is 'bounding box of two boxes';

alter function pg_catalog.bound_box() owner to postgres;

create function pg_catalog.inet_same_family()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_same_family() is 'are the addresses from the same family?';

alter function pg_catalog.inet_same_family() owner to postgres;

create function pg_catalog.binary_upgrade_set_record_init_privs()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_record_init_privs() is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_record_init_privs() owner to postgres;

create function pg_catalog.regnamespacein()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespacein() is 'I/O';

alter function pg_catalog.regnamespacein() owner to postgres;

create function pg_catalog.regnamespaceout()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespaceout() is 'I/O';

alter function pg_catalog.regnamespaceout() owner to postgres;

create function pg_catalog.to_regnamespace()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regnamespace() is 'convert namespace name to regnamespace';

alter function pg_catalog.to_regnamespace() owner to postgres;

create function pg_catalog.regnamespacerecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespacerecv() is 'I/O';

alter function pg_catalog.regnamespacerecv() owner to postgres;

create function pg_catalog.regnamespacesend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespacesend() is 'I/O';

alter function pg_catalog.regnamespacesend() owner to postgres;

create function pg_catalog.box(point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(point) is 'convert point to empty box';

alter function pg_catalog.box(point) owner to postgres;

create function pg_catalog.regroleout()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regroleout() is 'I/O';

alter function pg_catalog.regroleout() owner to postgres;

create function pg_catalog.to_regrole()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regrole() is 'convert role name to regrole';

alter function pg_catalog.to_regrole() owner to postgres;

create function pg_catalog.regrolerecv()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regrolerecv() is 'I/O';

alter function pg_catalog.regrolerecv() owner to postgres;

create function pg_catalog.regrolesend()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regrolesend() is 'I/O';

alter function pg_catalog.regrolesend() owner to postgres;

create function pg_catalog.regrolein()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regrolein() is 'I/O';

alter function pg_catalog.regrolein() owner to postgres;

create function pg_catalog.pg_rotate_logfile_old()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_rotate_logfile_old() is 'rotate log file - old version for adminpack 1.0';

alter function pg_catalog.pg_rotate_logfile_old() owner to postgres;

create function pg_catalog.pg_read_file_old()
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file_old() is 'read text from a file - old version for adminpack 1.0';

alter function pg_catalog.pg_read_file_old() owner to postgres;

create function pg_catalog.binary_upgrade_set_missing_value()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_missing_value() is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_missing_value() owner to postgres;

create function pg_catalog.brin_inclusion_opcinfo()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_opcinfo() is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_opcinfo() owner to postgres;

create function pg_catalog.brin_inclusion_add_value()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_add_value() is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_add_value() owner to postgres;

create function pg_catalog.brin_inclusion_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_consistent() is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_consistent() owner to postgres;

create function pg_catalog.brin_inclusion_union()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_union() is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_union() owner to postgres;

create function pg_catalog.macaddr8_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_in() is 'I/O';

alter function pg_catalog.macaddr8_in() owner to postgres;

create function pg_catalog.macaddr8_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_out() is 'I/O';

alter function pg_catalog.macaddr8_out() owner to postgres;

create function pg_catalog.trunc(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(macaddr8) is 'MACADDR8 manufacturer fields';

alter function pg_catalog.trunc(macaddr8) owner to postgres;

create function pg_catalog.macaddr8_eq()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_eq() is 'implementation of = operator';

alter function pg_catalog.macaddr8_eq() owner to postgres;

create function pg_catalog.macaddr8_lt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_lt() is 'implementation of < operator';

alter function pg_catalog.macaddr8_lt() owner to postgres;

create function pg_catalog.macaddr8_le()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_le() is 'implementation of <= operator';

alter function pg_catalog.macaddr8_le() owner to postgres;

create function pg_catalog.macaddr8_gt()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_gt() is 'implementation of > operator';

alter function pg_catalog.macaddr8_gt() owner to postgres;

create function pg_catalog.macaddr8_ge()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_ge() is 'implementation of >= operator';

alter function pg_catalog.macaddr8_ge() owner to postgres;

create function pg_catalog.macaddr8_ne()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_ne() is 'implementation of <> operator';

alter function pg_catalog.macaddr8_ne() owner to postgres;

create function pg_catalog.macaddr8_cmp()
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_cmp() is 'less-equal-greater';

alter function pg_catalog.macaddr8_cmp() owner to postgres;

create function pg_catalog.macaddr8_not()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_not() is 'implementation of ~ operator';

alter function pg_catalog.macaddr8_not() owner to postgres;

create function pg_catalog.macaddr8_and()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_and() is 'implementation of & operator';

alter function pg_catalog.macaddr8_and() owner to postgres;

create function pg_catalog.macaddr8_or()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_or() is 'implementation of | operator';

alter function pg_catalog.macaddr8_or() owner to postgres;

create function pg_catalog.macaddr8()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8() is 'convert macaddr to macaddr8';

alter function pg_catalog.macaddr8() owner to postgres;

create function pg_catalog.macaddr()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr() is 'convert macaddr8 to macaddr';

alter function pg_catalog.macaddr() owner to postgres;

create function pg_catalog.macaddr8_set7bit()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_set7bit() is 'set 7th bit in macaddr8';

alter function pg_catalog.macaddr8_set7bit() owner to postgres;

create function pg_catalog.in_range()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range() is 'window RANGE support';

alter function pg_catalog.in_range() owner to postgres;

create function pg_catalog.in_range(integer, integer, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(integer, integer, bigint) is 'window RANGE support';

alter function pg_catalog.in_range(integer, integer, bigint) owner to postgres;

create function pg_catalog.in_range(integer, integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(integer, integer, integer) is 'window RANGE support';

alter function pg_catalog.in_range(integer, integer, integer) owner to postgres;

create function pg_catalog.in_range(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(smallint) is 'window RANGE support';

alter function pg_catalog.in_range(smallint) owner to postgres;

create function pg_catalog.in_range(smallint, smallint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(smallint, smallint, bigint) is 'window RANGE support';

alter function pg_catalog.in_range(smallint, smallint, bigint) owner to postgres;

create function pg_catalog.in_range(smallint, smallint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(smallint, smallint, integer) is 'window RANGE support';

alter function pg_catalog.in_range(smallint, smallint, integer) owner to postgres;

create function pg_catalog.in_range(smallint, smallint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(smallint, smallint, smallint) is 'window RANGE support';

alter function pg_catalog.in_range(smallint, smallint, smallint) owner to postgres;

create function pg_catalog.in_range(date, date, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(date, date, interval) is 'window RANGE support';

alter function pg_catalog.in_range(date, date, interval) owner to postgres;

create function pg_catalog.in_range(timestamp, timestamp, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(timestamp, timestamp, interval) is 'window RANGE support';

alter function pg_catalog.in_range(timestamp, timestamp, interval) owner to postgres;

create function pg_catalog.in_range(timestamp with time zone, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(timestamp with time zone, timestamp with time zone) is 'window RANGE support';

alter function pg_catalog.in_range(timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog.in_range(interval, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(interval, interval) is 'window RANGE support';

alter function pg_catalog.in_range(interval, interval) owner to postgres;

create function pg_catalog.in_range(time, time)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(time, time) is 'window RANGE support';

alter function pg_catalog.in_range(time, time) owner to postgres;

create function pg_catalog.in_range(time with time zone, time with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(time with time zone, time with time zone) is 'window RANGE support';

alter function pg_catalog.in_range(time with time zone, time with time zone) owner to postgres;

create function pg_catalog.in_range(double precision, double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(double precision, double precision, double precision) is 'window RANGE support';

alter function pg_catalog.in_range(double precision, double precision, double precision) owner to postgres;

create function pg_catalog.in_range()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range() is 'window RANGE support';

alter function pg_catalog.in_range() owner to postgres;

create function pg_catalog.in_range(numeric, numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(numeric, numeric, numeric) is 'window RANGE support';

alter function pg_catalog.in_range(numeric, numeric, numeric) owner to postgres;

create function pg_catalog.to_tsvector(jsonb)
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(jsonb) is 'transform string values from jsonb to tsvector';

alter function pg_catalog.to_tsvector(jsonb) owner to postgres;

create function pg_catalog.to_tsvector()
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector() is 'transform string values from json to tsvector';

alter function pg_catalog.to_tsvector() owner to postgres;

create function pg_catalog.to_tsvector()
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector() is 'transform string values from jsonb to tsvector';

alter function pg_catalog.to_tsvector() owner to postgres;

create function pg_catalog.to_tsvector(regconfig, json)
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(regconfig, json) is 'transform string values from json to tsvector';

alter function pg_catalog.to_tsvector(regconfig, json) owner to postgres;

create function pg_catalog.jsonb_to_tsvector(jsonb)
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_to_tsvector(jsonb) is 'transform specified values from jsonb to tsvector';

alter function pg_catalog.jsonb_to_tsvector(jsonb) owner to postgres;

create function pg_catalog.jsonb_to_tsvector(regconfig, jsonb)
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_to_tsvector(regconfig, jsonb) is 'transform specified values from jsonb to tsvector';

alter function pg_catalog.jsonb_to_tsvector(regconfig, jsonb) owner to postgres;

create function pg_catalog.json_to_tsvector(json, jsonb)
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_to_tsvector(json, jsonb) is 'transform specified values from json to tsvector';

alter function pg_catalog.json_to_tsvector(json, jsonb) owner to postgres;

create function pg_catalog.json_to_tsvector(regconfig, json, jsonb)
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_to_tsvector(regconfig, json, jsonb) is 'transform specified values from json to tsvector';

alter function pg_catalog.json_to_tsvector(regconfig, json, jsonb) owner to postgres;

create function pg_catalog.pg_copy_physical_replication_slot(temporary boolean, out slot_name name, out lsn pg_lsn)
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_physical_replication_slot(boolean, out name, out pg_lsn) is 'copy a physical replication slot, changing temporality';

alter function pg_catalog.pg_copy_physical_replication_slot(boolean, out name, out pg_lsn) owner to postgres;

create function pg_catalog.pg_copy_physical_replication_slot(out slot_name name, out lsn pg_lsn)
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_physical_replication_slot(out name, out pg_lsn) is 'copy a physical replication slot';

alter function pg_catalog.pg_copy_physical_replication_slot(out name, out pg_lsn) owner to postgres;

create function pg_catalog.pg_copy_logical_replication_slot(temporary boolean, plugin name, out slot_name name, out lsn pg_lsn)
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_logical_replication_slot(boolean, name, out name, out pg_lsn) is 'copy a logical replication slot, changing temporality and plugin';

alter function pg_catalog.pg_copy_logical_replication_slot(boolean, name, out name, out pg_lsn) owner to postgres;

create function pg_catalog.pg_copy_logical_replication_slot()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_logical_replication_slot() is 'copy a logical replication slot, changing temporality';

alter function pg_catalog.pg_copy_logical_replication_slot() owner to postgres;

create function pg_catalog.pg_copy_logical_replication_slot(out slot_name name, out lsn pg_lsn)
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_logical_replication_slot(out name, out pg_lsn) is 'copy a logical replication slot';

alter function pg_catalog.pg_copy_logical_replication_slot(out name, out pg_lsn) owner to postgres;

create function pg_catalog.ascii_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ascii_to_mic() is 'internal conversion function for SQL_ASCII to MULE_INTERNAL';

alter function pg_catalog.ascii_to_mic() owner to postgres;

create function pg_catalog.mic_to_ascii()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_ascii() is 'internal conversion function for MULE_INTERNAL to SQL_ASCII';

alter function pg_catalog.mic_to_ascii() owner to postgres;

create function pg_catalog.koi8r_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_mic() is 'internal conversion function for KOI8R to MULE_INTERNAL';

alter function pg_catalog.koi8r_to_mic() owner to postgres;

create function pg_catalog.mic_to_koi8r()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_koi8r() is 'internal conversion function for MULE_INTERNAL to KOI8R';

alter function pg_catalog.mic_to_koi8r() owner to postgres;

create function pg_catalog.iso_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_mic() is 'internal conversion function for ISO-8859-5 to MULE_INTERNAL';

alter function pg_catalog.iso_to_mic() owner to postgres;

create function pg_catalog.mic_to_iso()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_iso() is 'internal conversion function for MULE_INTERNAL to ISO-8859-5';

alter function pg_catalog.mic_to_iso() owner to postgres;

create function pg_catalog.win1251_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_mic() is 'internal conversion function for WIN1251 to MULE_INTERNAL';

alter function pg_catalog.win1251_to_mic() owner to postgres;

create function pg_catalog.mic_to_win1251()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_win1251() is 'internal conversion function for MULE_INTERNAL to WIN1251';

alter function pg_catalog.mic_to_win1251() owner to postgres;

create function pg_catalog.win866_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_mic() is 'internal conversion function for WIN866 to MULE_INTERNAL';

alter function pg_catalog.win866_to_mic() owner to postgres;

create function pg_catalog.mic_to_win866()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_win866() is 'internal conversion function for MULE_INTERNAL to WIN866';

alter function pg_catalog.mic_to_win866() owner to postgres;

create function pg_catalog.koi8r_to_win1251()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_win1251() is 'internal conversion function for KOI8R to WIN1251';

alter function pg_catalog.koi8r_to_win1251() owner to postgres;

create function pg_catalog.win1251_to_koi8r()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_koi8r() is 'internal conversion function for WIN1251 to KOI8R';

alter function pg_catalog.win1251_to_koi8r() owner to postgres;

create function pg_catalog.koi8r_to_win866()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_win866() is 'internal conversion function for KOI8R to WIN866';

alter function pg_catalog.koi8r_to_win866() owner to postgres;

create function pg_catalog.win866_to_koi8r()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_koi8r() is 'internal conversion function for WIN866 to KOI8R';

alter function pg_catalog.win866_to_koi8r() owner to postgres;

create function pg_catalog.win866_to_win1251()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_win1251() is 'internal conversion function for WIN866 to WIN1251';

alter function pg_catalog.win866_to_win1251() owner to postgres;

create function pg_catalog.win1251_to_win866()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_win866() is 'internal conversion function for WIN1251 to WIN866';

alter function pg_catalog.win1251_to_win866() owner to postgres;

create function pg_catalog.iso_to_koi8r()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_koi8r() is 'internal conversion function for ISO-8859-5 to KOI8R';

alter function pg_catalog.iso_to_koi8r() owner to postgres;

create function pg_catalog.koi8r_to_iso()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_iso() is 'internal conversion function for KOI8R to ISO-8859-5';

alter function pg_catalog.koi8r_to_iso() owner to postgres;

create function pg_catalog.iso_to_win1251()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_win1251() is 'internal conversion function for ISO-8859-5 to WIN1251';

alter function pg_catalog.iso_to_win1251() owner to postgres;

create function pg_catalog.win1251_to_iso()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_iso() is 'internal conversion function for WIN1251 to ISO-8859-5';

alter function pg_catalog.win1251_to_iso() owner to postgres;

create function pg_catalog.iso_to_win866()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_win866() is 'internal conversion function for ISO-8859-5 to WIN866';

alter function pg_catalog.iso_to_win866() owner to postgres;

create function pg_catalog.win866_to_iso()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_iso() is 'internal conversion function for WIN866 to ISO-8859-5';

alter function pg_catalog.win866_to_iso() owner to postgres;

create function pg_catalog.euc_cn_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_cn_to_mic() is 'internal conversion function for EUC_CN to MULE_INTERNAL';

alter function pg_catalog.euc_cn_to_mic() owner to postgres;

create function pg_catalog.mic_to_euc_cn()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_cn() is 'internal conversion function for MULE_INTERNAL to EUC_CN';

alter function pg_catalog.mic_to_euc_cn() owner to postgres;

create function pg_catalog.euc_jp_to_sjis()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jp_to_sjis() is 'internal conversion function for EUC_JP to SJIS';

alter function pg_catalog.euc_jp_to_sjis() owner to postgres;

create function pg_catalog.sjis_to_euc_jp()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sjis_to_euc_jp() is 'internal conversion function for SJIS to EUC_JP';

alter function pg_catalog.sjis_to_euc_jp() owner to postgres;

create function pg_catalog.euc_jp_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jp_to_mic() is 'internal conversion function for EUC_JP to MULE_INTERNAL';

alter function pg_catalog.euc_jp_to_mic() owner to postgres;

create function pg_catalog.sjis_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sjis_to_mic() is 'internal conversion function for SJIS to MULE_INTERNAL';

alter function pg_catalog.sjis_to_mic() owner to postgres;

create function pg_catalog.mic_to_euc_jp()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_jp() is 'internal conversion function for MULE_INTERNAL to EUC_JP';

alter function pg_catalog.mic_to_euc_jp() owner to postgres;

create function pg_catalog.mic_to_sjis()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_sjis() is 'internal conversion function for MULE_INTERNAL to SJIS';

alter function pg_catalog.mic_to_sjis() owner to postgres;

create function pg_catalog.euc_kr_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_kr_to_mic() is 'internal conversion function for EUC_KR to MULE_INTERNAL';

alter function pg_catalog.euc_kr_to_mic() owner to postgres;

create function pg_catalog.mic_to_euc_kr()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_kr() is 'internal conversion function for MULE_INTERNAL to EUC_KR';

alter function pg_catalog.mic_to_euc_kr() owner to postgres;

create function pg_catalog.euc_tw_to_big5()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_tw_to_big5() is 'internal conversion function for EUC_TW to BIG5';

alter function pg_catalog.euc_tw_to_big5() owner to postgres;

create function pg_catalog.big5_to_euc_tw()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.big5_to_euc_tw() is 'internal conversion function for BIG5 to EUC_TW';

alter function pg_catalog.big5_to_euc_tw() owner to postgres;

create function pg_catalog.euc_tw_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_tw_to_mic() is 'internal conversion function for EUC_TW to MULE_INTERNAL';

alter function pg_catalog.euc_tw_to_mic() owner to postgres;

create function pg_catalog.big5_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.big5_to_mic() is 'internal conversion function for BIG5 to MULE_INTERNAL';

alter function pg_catalog.big5_to_mic() owner to postgres;

create function pg_catalog.mic_to_euc_tw()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_tw() is 'internal conversion function for MULE_INTERNAL to EUC_TW';

alter function pg_catalog.mic_to_euc_tw() owner to postgres;

create function pg_catalog.mic_to_big5()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_big5() is 'internal conversion function for MULE_INTERNAL to BIG5';

alter function pg_catalog.mic_to_big5() owner to postgres;

create function pg_catalog.latin2_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin2_to_mic() is 'internal conversion function for LATIN2 to MULE_INTERNAL';

alter function pg_catalog.latin2_to_mic() owner to postgres;

create function pg_catalog.mic_to_latin2()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin2() is 'internal conversion function for MULE_INTERNAL to LATIN2';

alter function pg_catalog.mic_to_latin2() owner to postgres;

create function pg_catalog.win1250_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1250_to_mic() is 'internal conversion function for WIN1250 to MULE_INTERNAL';

alter function pg_catalog.win1250_to_mic() owner to postgres;

create function pg_catalog.mic_to_win1250()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_win1250() is 'internal conversion function for MULE_INTERNAL to WIN1250';

alter function pg_catalog.mic_to_win1250() owner to postgres;

create function pg_catalog.latin2_to_win1250()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin2_to_win1250() is 'internal conversion function for LATIN2 to WIN1250';

alter function pg_catalog.latin2_to_win1250() owner to postgres;

create function pg_catalog.win1250_to_latin2()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1250_to_latin2() is 'internal conversion function for WIN1250 to LATIN2';

alter function pg_catalog.win1250_to_latin2() owner to postgres;

create function pg_catalog.latin1_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin1_to_mic() is 'internal conversion function for LATIN1 to MULE_INTERNAL';

alter function pg_catalog.latin1_to_mic() owner to postgres;

create function pg_catalog.mic_to_latin1()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin1() is 'internal conversion function for MULE_INTERNAL to LATIN1';

alter function pg_catalog.mic_to_latin1() owner to postgres;

create function pg_catalog.latin3_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin3_to_mic() is 'internal conversion function for LATIN3 to MULE_INTERNAL';

alter function pg_catalog.latin3_to_mic() owner to postgres;

create function pg_catalog.mic_to_latin3()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin3() is 'internal conversion function for MULE_INTERNAL to LATIN3';

alter function pg_catalog.mic_to_latin3() owner to postgres;

create function pg_catalog.latin4_to_mic()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin4_to_mic() is 'internal conversion function for LATIN4 to MULE_INTERNAL';

alter function pg_catalog.latin4_to_mic() owner to postgres;

create function pg_catalog.mic_to_latin4()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin4() is 'internal conversion function for MULE_INTERNAL to LATIN4';

alter function pg_catalog.mic_to_latin4() owner to postgres;

create function pg_catalog.ascii_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ascii_to_utf8() is 'internal conversion function for SQL_ASCII to UTF8';

alter function pg_catalog.ascii_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_ascii()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_ascii() is 'internal conversion function for UTF8 to SQL_ASCII';

alter function pg_catalog.utf8_to_ascii() owner to postgres;

create function pg_catalog.big5_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.big5_to_utf8() is 'internal conversion function for BIG5 to UTF8';

alter function pg_catalog.big5_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_big5()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_big5() is 'internal conversion function for UTF8 to BIG5';

alter function pg_catalog.utf8_to_big5() owner to postgres;

create function pg_catalog.utf8_to_koi8r()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_koi8r() is 'internal conversion function for UTF8 to KOI8R';

alter function pg_catalog.utf8_to_koi8r() owner to postgres;

create function pg_catalog.koi8r_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_utf8() is 'internal conversion function for KOI8R to UTF8';

alter function pg_catalog.koi8r_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_koi8u()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_koi8u() is 'internal conversion function for UTF8 to KOI8U';

alter function pg_catalog.utf8_to_koi8u() owner to postgres;

create function pg_catalog.koi8u_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8u_to_utf8() is 'internal conversion function for KOI8U to UTF8';

alter function pg_catalog.koi8u_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_win()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_win() is 'internal conversion function for UTF8 to WIN';

alter function pg_catalog.utf8_to_win() owner to postgres;

create function pg_catalog.win_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win_to_utf8() is 'internal conversion function for WIN to UTF8';

alter function pg_catalog.win_to_utf8() owner to postgres;

create function pg_catalog.euc_cn_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_cn_to_utf8() is 'internal conversion function for EUC_CN to UTF8';

alter function pg_catalog.euc_cn_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_euc_cn()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_cn() is 'internal conversion function for UTF8 to EUC_CN';

alter function pg_catalog.utf8_to_euc_cn() owner to postgres;

create function pg_catalog.euc_jp_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jp_to_utf8() is 'internal conversion function for EUC_JP to UTF8';

alter function pg_catalog.euc_jp_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_euc_jp()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_jp() is 'internal conversion function for UTF8 to EUC_JP';

alter function pg_catalog.utf8_to_euc_jp() owner to postgres;

create function pg_catalog.euc_kr_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_kr_to_utf8() is 'internal conversion function for EUC_KR to UTF8';

alter function pg_catalog.euc_kr_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_euc_kr()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_kr() is 'internal conversion function for UTF8 to EUC_KR';

alter function pg_catalog.utf8_to_euc_kr() owner to postgres;

create function pg_catalog.euc_tw_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_tw_to_utf8() is 'internal conversion function for EUC_TW to UTF8';

alter function pg_catalog.euc_tw_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_euc_tw()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_tw() is 'internal conversion function for UTF8 to EUC_TW';

alter function pg_catalog.utf8_to_euc_tw() owner to postgres;

create function pg_catalog.gb18030_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gb18030_to_utf8() is 'internal conversion function for GB18030 to UTF8';

alter function pg_catalog.gb18030_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_gb18030()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_gb18030() is 'internal conversion function for UTF8 to GB18030';

alter function pg_catalog.utf8_to_gb18030() owner to postgres;

create function pg_catalog.gbk_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gbk_to_utf8() is 'internal conversion function for GBK to UTF8';

alter function pg_catalog.gbk_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_gbk()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_gbk() is 'internal conversion function for UTF8 to GBK';

alter function pg_catalog.utf8_to_gbk() owner to postgres;

create function pg_catalog.utf8_to_iso8859()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_iso8859() is 'internal conversion function for UTF8 to ISO-8859 2-16';

alter function pg_catalog.utf8_to_iso8859() owner to postgres;

create function pg_catalog.iso8859_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso8859_to_utf8() is 'internal conversion function for ISO-8859 2-16 to UTF8';

alter function pg_catalog.iso8859_to_utf8() owner to postgres;

create function pg_catalog.iso8859_1_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso8859_1_to_utf8() is 'internal conversion function for LATIN1 to UTF8';

alter function pg_catalog.iso8859_1_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_iso8859_1()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_iso8859_1() is 'internal conversion function for UTF8 to LATIN1';

alter function pg_catalog.utf8_to_iso8859_1() owner to postgres;

create function pg_catalog.johab_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.johab_to_utf8() is 'internal conversion function for JOHAB to UTF8';

alter function pg_catalog.johab_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_johab()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_johab() is 'internal conversion function for UTF8 to JOHAB';

alter function pg_catalog.utf8_to_johab() owner to postgres;

create function pg_catalog.sjis_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sjis_to_utf8() is 'internal conversion function for SJIS to UTF8';

alter function pg_catalog.sjis_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_sjis()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_sjis() is 'internal conversion function for UTF8 to SJIS';

alter function pg_catalog.utf8_to_sjis() owner to postgres;

create function pg_catalog.uhc_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uhc_to_utf8() is 'internal conversion function for UHC to UTF8';

alter function pg_catalog.uhc_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_uhc()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_uhc() is 'internal conversion function for UTF8 to UHC';

alter function pg_catalog.utf8_to_uhc() owner to postgres;

create function pg_catalog.euc_jis_2004_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jis_2004_to_utf8() is 'internal conversion function for EUC_JIS_2004 to UTF8';

alter function pg_catalog.euc_jis_2004_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_euc_jis_2004()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_jis_2004() is 'internal conversion function for UTF8 to EUC_JIS_2004';

alter function pg_catalog.utf8_to_euc_jis_2004() owner to postgres;

create function pg_catalog.shift_jis_2004_to_utf8()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shift_jis_2004_to_utf8() is 'internal conversion function for SHIFT_JIS_2004 to UTF8';

alter function pg_catalog.shift_jis_2004_to_utf8() owner to postgres;

create function pg_catalog.utf8_to_shift_jis_2004()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_shift_jis_2004() is 'internal conversion function for UTF8 to SHIFT_JIS_2004';

alter function pg_catalog.utf8_to_shift_jis_2004() owner to postgres;

create function pg_catalog.euc_jis_2004_to_shift_jis_2004()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jis_2004_to_shift_jis_2004() is 'internal conversion function for EUC_JIS_2004 to SHIFT_JIS_2004';

alter function pg_catalog.euc_jis_2004_to_shift_jis_2004() owner to postgres;

create function pg_catalog.shift_jis_2004_to_euc_jis_2004()
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shift_jis_2004_to_euc_jis_2004() is 'internal conversion function for SHIFT_JIS_2004 to EUC_JIS_2004';

alter function pg_catalog.shift_jis_2004_to_euc_jis_2004() owner to postgres;

create function pg_catalog.pg_event_trigger_table_rewrite_oid()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_event_trigger_table_rewrite_oid() is 'return Oid of the table getting rewritten';

alter function pg_catalog.pg_event_trigger_table_rewrite_oid() owner to postgres;

create function pg_catalog.pg_event_trigger_table_rewrite_reason()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_event_trigger_table_rewrite_reason() is 'return reason code for table getting rewritten';

alter function pg_catalog.pg_event_trigger_table_rewrite_reason() owner to postgres;

create function pg_catalog.pg_event_trigger_ddl_commands()
    stable
    strict
    parallel restricted
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_event_trigger_ddl_commands() is 'list DDL actions being executed by the current command';

alter function pg_catalog.pg_event_trigger_ddl_commands() owner to postgres;

create function pg_catalog.phraseto_tsquery()
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.phraseto_tsquery() is 'transform to tsquery';

alter function pg_catalog.phraseto_tsquery() owner to postgres;

create function pg_catalog.tsquery_phrase()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_phrase() is 'implementation of <-> operator';

alter function pg_catalog.tsquery_phrase() owner to postgres;

create function pg_catalog.tsquery_phrase()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_phrase() is 'phrase-concatenate with distance';

alter function pg_catalog.tsquery_phrase() owner to postgres;

create function pg_catalog.phraseto_tsquery()
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.phraseto_tsquery() is 'transform to tsquery';

alter function pg_catalog.phraseto_tsquery() owner to postgres;

create function pg_catalog.websearch_to_tsquery()
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.websearch_to_tsquery() is 'transform to tsquery';

alter function pg_catalog.websearch_to_tsquery() owner to postgres;

create function pg_catalog.websearch_to_tsquery()
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.websearch_to_tsquery() is 'transform to tsquery';

alter function pg_catalog.websearch_to_tsquery() owner to postgres;

create function pg_catalog.spg_bbox_quad_config()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_bbox_quad_config() is 'SP-GiST support for quad tree over 2-D types represented by their bounding boxes';

alter function pg_catalog.spg_bbox_quad_config() owner to postgres;

create function pg_catalog.spg_poly_quad_compress()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_poly_quad_compress() is 'SP-GiST support for quad tree over polygons';

alter function pg_catalog.spg_poly_quad_compress() owner to postgres;

create function pg_catalog.spg_box_quad_config()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_config() is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_config() owner to postgres;

create function pg_catalog.spg_box_quad_choose()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_choose() is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_choose() owner to postgres;

create function pg_catalog.spg_box_quad_picksplit()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_picksplit() is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_picksplit() owner to postgres;

create function pg_catalog.spg_box_quad_inner_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_inner_consistent() is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_inner_consistent() owner to postgres;

create function pg_catalog.spg_box_quad_leaf_consistent()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_leaf_consistent() is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_leaf_consistent() owner to postgres;

create function pg_catalog.pg_mcv_list_in()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_in() is 'I/O';

alter function pg_catalog.pg_mcv_list_in() owner to postgres;

create function pg_catalog.pg_mcv_list_out()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_out() is 'I/O';

alter function pg_catalog.pg_mcv_list_out() owner to postgres;

create function pg_catalog.pg_mcv_list_recv()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_recv() is 'I/O';

alter function pg_catalog.pg_mcv_list_recv() owner to postgres;

create function pg_catalog.pg_mcv_list_send()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_send() is 'I/O';

alter function pg_catalog.pg_mcv_list_send() owner to postgres;

create function pg_catalog.satisfies_hash_partition()
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.satisfies_hash_partition() is 'hash partition CHECK constraint';

alter function pg_catalog.satisfies_hash_partition() owner to postgres;

create function pg_catalog.pg_ls_tmpdir()
    strict
    parallel safe
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ls_tmpdir() is 'list files in the pgsql_tmp directory';

alter function pg_catalog.pg_ls_tmpdir() owner to postgres;

create function pg_catalog.pg_ls_tmpdir()
    strict
    parallel safe
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ls_tmpdir() is 'list files in the pgsql_tmp directory';

alter function pg_catalog.pg_ls_tmpdir() owner to postgres;

grant execute on function pg_catalog.pg_ls_tmpdir() to pg_monitor;

grant execute on function pg_catalog.pg_ls_tmpdir() to pg_monitor;

create function pg_catalog.pg_ls_archive_statusdir()
    strict
    parallel safe
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ls_archive_statusdir() is 'list of files in the archive_status directory';

alter function pg_catalog.pg_ls_archive_statusdir() owner to postgres;

grant execute on function pg_catalog.pg_ls_archive_statusdir() to pg_monitor;

create function pg_catalog.pg_replication_origin_create()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_create() is 'create a replication origin';

alter function pg_catalog.pg_replication_origin_create() owner to postgres;

create function pg_catalog.pg_replication_origin_drop()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_drop() is 'drop replication origin identified by its name';

alter function pg_catalog.pg_replication_origin_drop() owner to postgres;

create function pg_catalog.pg_replication_origin_oid()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_oid() is 'translate the replication origin''s name to its id';

alter function pg_catalog.pg_replication_origin_oid() owner to postgres;

create function pg_catalog.pg_replication_origin_session_setup()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_setup() is 'configure session to maintain replication progress tracking for the passed in origin';

alter function pg_catalog.pg_replication_origin_session_setup() owner to postgres;

create function pg_catalog.pg_replication_origin_session_reset()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_reset() is 'teardown configured replication progress tracking';

alter function pg_catalog.pg_replication_origin_session_reset() owner to postgres;

create function pg_catalog.pg_replication_origin_session_is_setup()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_is_setup() is 'is a replication origin configured in this session';

alter function pg_catalog.pg_replication_origin_session_is_setup() owner to postgres;

create function pg_catalog.pg_replication_origin_session_progress()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_progress() is 'get the replication progress of the current session';

alter function pg_catalog.pg_replication_origin_session_progress() owner to postgres;

create function pg_catalog.pg_replication_origin_xact_setup()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_xact_setup() is 'setup the transaction''s origin lsn and timestamp';

alter function pg_catalog.pg_replication_origin_xact_setup() owner to postgres;

create function pg_catalog.pg_replication_origin_xact_reset()
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_xact_reset() is 'reset the transaction''s origin lsn and timestamp';

alter function pg_catalog.pg_replication_origin_xact_reset() owner to postgres;

create function pg_catalog.pg_replication_origin_advance()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_advance() is 'advance replication origin to specific location';

alter function pg_catalog.pg_replication_origin_advance() owner to postgres;

create function pg_catalog.pg_replication_origin_progress()
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_progress() is 'get an individual replication origin''s replication progress';

alter function pg_catalog.pg_replication_origin_progress() owner to postgres;

create function pg_catalog.pg_show_replication_origin_status()
    parallel restricted
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_show_replication_origin_status() is 'get progress for all replication origins';

alter function pg_catalog.pg_show_replication_origin_status() owner to postgres;

create function pg_catalog.pg_stat_get_subscription()
    stable
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_subscription() is 'statistics: information about subscription';

alter function pg_catalog.pg_stat_get_subscription() owner to postgres;

create function pg_catalog.pg_get_publication_tables()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_publication_tables() is 'get OIDs of tables in a publication';

alter function pg_catalog.pg_get_publication_tables() owner to postgres;

create function pg_catalog.pg_get_replica_identity_index()
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_replica_identity_index() is 'oid of replica identity index if any';

alter function pg_catalog.pg_get_replica_identity_index() owner to postgres;

create function pg_catalog.pg_relation_is_publishable()
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_is_publishable() is 'returns whether a relation can be part of a publication';

alter function pg_catalog.pg_relation_is_publishable() owner to postgres;

create function pg_catalog.ts_debug(config regconfig, document text, OUT alias text, OUT description text, OUT token text, OUT dictionaries regdictionary[], OUT dictionary regdictionary, OUT lexemes text[]) returns SETOF record
    stable
    strict
    parallel safe
    language sql
as
$$
SELECT
    tt.alias AS alias,
    tt.description AS description,
    parse.token AS token,
    ARRAY ( SELECT m.mapdict::pg_catalog.regdictionary
            FROM pg_catalog.pg_ts_config_map AS m
            WHERE m.mapcfg = $1 AND m.maptokentype = parse.tokid
            ORDER BY m.mapseqno )
    AS dictionaries,
    ( SELECT mapdict::pg_catalog.regdictionary
      FROM pg_catalog.pg_ts_config_map AS m
      WHERE m.mapcfg = $1 AND m.maptokentype = parse.tokid
      ORDER BY pg_catalog.ts_lexize(mapdict, parse.token) IS NULL, m.mapseqno
      LIMIT 1
    ) AS dictionary,
    ( SELECT pg_catalog.ts_lexize(mapdict, parse.token)
      FROM pg_catalog.pg_ts_config_map AS m
      WHERE m.mapcfg = $1 AND m.maptokentype = parse.tokid
      ORDER BY pg_catalog.ts_lexize(mapdict, parse.token) IS NULL, m.mapseqno
      LIMIT 1
    ) AS lexemes
FROM pg_catalog.ts_parse(
        (SELECT cfgparser FROM pg_catalog.pg_ts_config WHERE oid = $1 ), $2
    ) AS parse,
     pg_catalog.ts_token_type(
        (SELECT cfgparser FROM pg_catalog.pg_ts_config WHERE oid = $1 )
    ) AS tt
WHERE tt.tokid = parse.tokid
$$;

comment on function pg_catalog.ts_debug(regconfig, text, out text, out text, out text, out regdictionary[], out regdictionary, out text[]) is 'debug function for text search configuration';

alter function pg_catalog.ts_debug(regconfig, text, out text, out text, out text, out regdictionary[], out regdictionary, out text[]) owner to postgres;

create function pg_catalog.ts_debug(document text, OUT alias text, OUT description text, OUT token text, OUT dictionaries regdictionary[], OUT dictionary regdictionary, OUT lexemes text[]) returns SETOF record
    stable
    strict
    parallel safe
    language sql
as
$$
    SELECT * FROM pg_catalog.ts_debug( pg_catalog.get_current_ts_config(), $1);
$$;

comment on function pg_catalog.ts_debug(text, out text, out text, out text, out regdictionary[], out regdictionary, out text[]) is 'debug function for current text search configuration';

alter function pg_catalog.ts_debug(text, out text, out text, out text, out regdictionary[], out regdictionary, out text[]) owner to postgres;

create function pg_catalog.dsnowball_init()
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pg_catalog.dsnowball_init() owner to postgres;

create function pg_catalog.dsnowball_lexize()
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pg_catalog.dsnowball_lexize() owner to postgres;

create function information_schema._pg_expandarray(anyarray, OUT x anyelement, OUT n integer) returns SETOF record
    immutable
    strict
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

alter function information_schema._pg_expandarray() owner to postgres;

create function information_schema._pg_keysequal(smallint[], smallint[]) returns boolean
    immutable
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

alter function information_schema._pg_keysequal() owner to postgres;

create function information_schema._pg_index_position(oid, smallint) returns integer
    stable
    strict
    language sql
as
$$
    begin
-- missing source code
end;
$$;

alter function information_schema._pg_index_position() owner to postgres;

create function information_schema._pg_truetypid(pg_attribute, pg_type) returns oid
    immutable
    strict
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

alter function information_schema._pg_truetypid() owner to postgres;

create function information_schema._pg_truetypmod(pg_attribute, pg_type) returns integer
    immutable
    strict
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

alter function information_schema._pg_truetypmod() owner to postgres;

create function information_schema._pg_char_max_length(typid oid, typmod integer) returns integer
    immutable
    strict
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

alter function information_schema._pg_char_max_length() owner to postgres;

create function information_schema._pg_char_octet_length(typid oid, typmod integer) returns integer
    immutable
    strict
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

alter function information_schema._pg_char_octet_length() owner to postgres;

create function information_schema._pg_numeric_precision(typid oid, typmod integer) returns integer
    immutable
    strict
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

alter function information_schema._pg_numeric_precision() owner to postgres;

create function information_schema._pg_numeric_precision_radix(typid oid, typmod integer) returns integer
    immutable
    strict
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

alter function information_schema._pg_numeric_precision_radix() owner to postgres;

create function information_schema._pg_numeric_scale(typid oid, typmod integer) returns integer
    immutable
    strict
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

alter function information_schema._pg_numeric_scale() owner to postgres;

create function information_schema._pg_datetime_precision(typid oid, typmod integer) returns integer
    immutable
    strict
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

alter function information_schema._pg_datetime_precision() owner to postgres;

create function information_schema._pg_interval_type(typid oid, mod integer) returns text
    immutable
    strict
    parallel safe
    language sql
as
$$
    begin
-- missing source code
end;
$$;

alter function information_schema._pg_interval_type() owner to postgres;

create function pg_catalog.plpgsql_call_handler()
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pg_catalog.plpgsql_call_handler() owner to postgres;

create function pg_catalog.plpgsql_inline_handler()
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pg_catalog.plpgsql_inline_handler() owner to postgres;

create function pg_catalog.plpgsql_validator()
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pg_catalog.plpgsql_validator() owner to postgres;

create operator pg_catalog.|| (procedure = pg_catalog.array_append, leftarg = anyarray, rightarg = anyelement);

comment on operator pg_catalog.||(anyarray, anyelement) is 'append element onto end of array';

alter operator pg_catalog.||(anyarray, anyelement) owner to postgres;

create operator pg_catalog.|| (procedure = pg_catalog.array_prepend, leftarg = anyelement, rightarg = anyarray);

comment on operator pg_catalog.||(anyelement, anyarray) is 'prepend element onto front of array';

alter operator pg_catalog.||(anyelement, anyarray) owner to postgres;

create operator pg_catalog.|| (procedure = pg_catalog.array_cat, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.||(anyarray, anyarray) is 'concatenate';

alter operator pg_catalog.||(anyarray, anyarray) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.cideq, leftarg = cid, rightarg = cid, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes);

comment on operator pg_catalog.=(cid, cid) is 'equal';

alter operator pg_catalog.=(cid, cid) owner to postgres;

create operator pg_catalog.! (procedure = pg_catalog.numeric_fac, leftarg = bigint);

comment on operator pg_catalog.!(bigint, none) is 'factorial';

alter operator pg_catalog.!(bigint, none) owner to postgres;

create operator pg_catalog.!! (procedure = pg_catalog.numeric_fac, rightarg = bigint);

comment on operator pg_catalog.!!(none, bigint) is 'deprecated, use ! instead';

alter operator pg_catalog.!!(none, bigint) owner to postgres;

create operator pg_catalog.% (procedure = pg_catalog.int8mod, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.%(bigint, bigint) is 'modulus';

alter operator pg_catalog.%(bigint, bigint) owner to postgres;

create operator pg_catalog.@ (procedure = pg_catalog.int8abs, rightarg = bigint);

comment on operator pg_catalog.@(none, bigint) is 'absolute value';

alter operator pg_catalog.@(none, bigint) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.int8um, rightarg = bigint);

comment on operator pg_catalog.-(none, bigint) is 'negate';

alter operator pg_catalog.-(none, bigint) owner to postgres;

create operator pg_catalog.<< (procedure = pg_catalog.poly_left, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<(polygon, polygon) is 'is left of';

alter operator pg_catalog.<<(polygon, polygon) owner to postgres;

create operator pg_catalog.&< (procedure = pg_catalog.poly_overleft, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<(polygon, polygon) is 'overlaps or is left of';

alter operator pg_catalog.&<(polygon, polygon) owner to postgres;

create operator pg_catalog.&> (procedure = pg_catalog.poly_overright, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&>(polygon, polygon) is 'overlaps or is right of';

alter operator pg_catalog.&>(polygon, polygon) owner to postgres;

create operator pg_catalog.>> (procedure = pg_catalog.poly_right, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>>(polygon, polygon) is 'is right of';

alter operator pg_catalog.>>(polygon, polygon) owner to postgres;

create operator pg_catalog.~= (procedure = pg_catalog.poly_same, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.~=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.~=(polygon, polygon) is 'same as';

alter operator pg_catalog.~=(polygon, polygon) owner to postgres;

create operator pg_catalog.&& (procedure = pg_catalog.poly_overlap, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.&&(polygon, polygon) is 'overlaps';

alter operator pg_catalog.&&(polygon, polygon) owner to postgres;

create operator pg_catalog.<< (procedure = pg_catalog.box_left, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<(box, box) is 'is left of';

alter operator pg_catalog.<<(box, box) owner to postgres;

create operator pg_catalog.&< (procedure = pg_catalog.box_overleft, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<(box, box) is 'overlaps or is left of';

alter operator pg_catalog.&<(box, box) owner to postgres;

create operator pg_catalog.&> (procedure = pg_catalog.box_overright, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&>(box, box) is 'overlaps or is right of';

alter operator pg_catalog.&>(box, box) owner to postgres;

create operator pg_catalog.>> (procedure = pg_catalog.box_right, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>>(box, box) is 'is right of';

alter operator pg_catalog.>>(box, box) owner to postgres;

create operator pg_catalog.~= (procedure = pg_catalog.box_same, leftarg = box, rightarg = box, commutator = pg_catalog.~=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.~=(box, box) is 'same as';

alter operator pg_catalog.~=(box, box) owner to postgres;

create operator pg_catalog.&& (procedure = pg_catalog.box_overlap, leftarg = box, rightarg = box, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.&&(box, box) is 'overlaps';

alter operator pg_catalog.&&(box, box) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.box_eq, leftarg = box, rightarg = box, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(box, box) is 'equal by area';

alter operator pg_catalog.=(box, box) owner to postgres;

create operator pg_catalog.>^ (procedure = pg_catalog.point_above, leftarg = point, rightarg = point, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>^(point, point) is 'is above';

alter operator pg_catalog.>^(point, point) owner to postgres;

create operator pg_catalog.<< (procedure = pg_catalog.point_left, leftarg = point, rightarg = point, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<(point, point) is 'is left of';

alter operator pg_catalog.<<(point, point) owner to postgres;

create operator pg_catalog.>> (procedure = pg_catalog.point_right, leftarg = point, rightarg = point, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>>(point, point) is 'is right of';

alter operator pg_catalog.>>(point, point) owner to postgres;

create operator pg_catalog.<^ (procedure = pg_catalog.point_below, leftarg = point, rightarg = point, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<^(point, point) is 'is below';

alter operator pg_catalog.<^(point, point) owner to postgres;

create operator pg_catalog.@@ (procedure = pg_catalog.box_center, rightarg = box);

comment on operator pg_catalog.@@(none, box) is 'center of';

alter operator pg_catalog.@@(none, box) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.int4mul, leftarg = integer, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, integer) is 'multiply';

alter operator pg_catalog.*(integer, integer) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.point_distance, leftarg = point, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, point) is 'distance between';

alter operator pg_catalog.<->(point, point) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.int2mul, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, smallint) is 'multiply';

alter operator pg_catalog.*(smallint, smallint) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.int2div, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog./(smallint, smallint) is 'divide';

alter operator pg_catalog./(smallint, smallint) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.int4div, leftarg = integer, rightarg = integer);

comment on operator pg_catalog./(integer, integer) is 'divide';

alter operator pg_catalog./(integer, integer) owner to postgres;

create operator pg_catalog.% (procedure = pg_catalog.int2mod, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.%(smallint, smallint) is 'modulus';

alter operator pg_catalog.%(smallint, smallint) owner to postgres;

create operator pg_catalog.% (procedure = pg_catalog.int4mod, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.%(integer, integer) is 'modulus';

alter operator pg_catalog.%(integer, integer) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.int24div, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog./(smallint, integer) is 'divide';

alter operator pg_catalog./(smallint, integer) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.int42div, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog./(integer, smallint) is 'divide';

alter operator pg_catalog./(integer, smallint) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.int2pl, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(smallint, smallint) is 'add';

alter operator pg_catalog.+(smallint, smallint) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.int4pl, leftarg = integer, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, integer) is 'add';

alter operator pg_catalog.+(integer, integer) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.int2mi, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.-(smallint, smallint) is 'subtract';

alter operator pg_catalog.-(smallint, smallint) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.int4mi, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.-(integer, integer) is 'subtract';

alter operator pg_catalog.-(integer, integer) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.int24mi, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.-(smallint, integer) is 'subtract';

alter operator pg_catalog.-(smallint, integer) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.int42mi, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.-(integer, smallint) is 'subtract';

alter operator pg_catalog.-(integer, smallint) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.int4um, rightarg = integer);

comment on operator pg_catalog.-(none, integer) is 'negate';

alter operator pg_catalog.-(none, integer) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.int2um, rightarg = smallint);

comment on operator pg_catalog.-(none, smallint) is 'negate';

alter operator pg_catalog.-(none, smallint) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.float4um, rightarg = real);

comment on operator pg_catalog.-(none, real) is 'negate';

alter operator pg_catalog.-(none, real) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.float8um, rightarg = double precision);

comment on operator pg_catalog.-(none, double precision) is 'negate';

alter operator pg_catalog.-(none, double precision) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.float4pl, leftarg = real, rightarg = real, commutator = pg_catalog.+);

comment on operator pg_catalog.+(real, real) is 'add';

alter operator pg_catalog.+(real, real) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.float4mi, leftarg = real, rightarg = real);

comment on operator pg_catalog.-(real, real) is 'subtract';

alter operator pg_catalog.-(real, real) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.float4div, leftarg = real, rightarg = real);

comment on operator pg_catalog./(real, real) is 'divide';

alter operator pg_catalog./(real, real) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.float4mul, leftarg = real, rightarg = real, commutator = pg_catalog.*);

comment on operator pg_catalog.*(real, real) is 'multiply';

alter operator pg_catalog.*(real, real) owner to postgres;

create operator pg_catalog.@ (procedure = pg_catalog.float4abs, rightarg = real);

comment on operator pg_catalog.@(none, real) is 'absolute value';

alter operator pg_catalog.@(none, real) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.float8pl, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.+);

comment on operator pg_catalog.+(double precision, double precision) is 'add';

alter operator pg_catalog.+(double precision, double precision) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.float8mi, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.-(double precision, double precision) is 'subtract';

alter operator pg_catalog.-(double precision, double precision) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.float8div, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog./(double precision, double precision) is 'divide';

alter operator pg_catalog./(double precision, double precision) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.float8mul, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, double precision) is 'multiply';

alter operator pg_catalog.*(double precision, double precision) owner to postgres;

create operator pg_catalog.@ (procedure = pg_catalog.float8abs, rightarg = double precision);

comment on operator pg_catalog.@(none, double precision) is 'absolute value';

alter operator pg_catalog.@(none, double precision) owner to postgres;

create operator pg_catalog.|/ (procedure = pg_catalog.dsqrt, rightarg = double precision);

comment on operator pg_catalog.|/(none, double precision) is 'square root';

alter operator pg_catalog.|/(none, double precision) owner to postgres;

create operator pg_catalog.||/ (procedure = pg_catalog.dcbrt, rightarg = double precision);

comment on operator pg_catalog.||/(none, double precision) is 'cube root';

alter operator pg_catalog.||/(none, double precision) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.dist_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.<->(point, line) is 'distance between';

alter operator pg_catalog.<->(point, line) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.dist_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.<->(point, lseg) is 'distance between';

alter operator pg_catalog.<->(point, lseg) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.dist_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.<->(point, box) is 'distance between';

alter operator pg_catalog.<->(point, box) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.dist_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.<->(lseg, line) is 'distance between';

alter operator pg_catalog.<->(lseg, line) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.dist_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.<->(lseg, box) is 'distance between';

alter operator pg_catalog.<->(lseg, box) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.dist_ppath, leftarg = point, rightarg = path);

comment on operator pg_catalog.<->(point, path) is 'distance between';

alter operator pg_catalog.<->(point, path) owner to postgres;

create operator pg_catalog.|| (procedure = pg_catalog.textcat, leftarg = text, rightarg = text);

comment on operator pg_catalog.||(text, text) is 'concatenate';

alter operator pg_catalog.||(text, text) owner to postgres;

create operator pg_catalog.@ (procedure = pg_catalog.int2abs, rightarg = smallint);

comment on operator pg_catalog.@(none, smallint) is 'absolute value';

alter operator pg_catalog.@(none, smallint) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.int8pl, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, bigint) is 'add';

alter operator pg_catalog.+(bigint, bigint) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.int8mi, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.-(bigint, bigint) is 'subtract';

alter operator pg_catalog.-(bigint, bigint) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.int8mul, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, bigint) is 'multiply';

alter operator pg_catalog.*(bigint, bigint) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.int8div, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog./(bigint, bigint) is 'divide';

alter operator pg_catalog./(bigint, bigint) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.int84mi, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.-(bigint, integer) is 'subtract';

alter operator pg_catalog.-(bigint, integer) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.int84div, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog./(bigint, integer) is 'divide';

alter operator pg_catalog./(bigint, integer) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.int48mi, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.-(integer, bigint) is 'subtract';

alter operator pg_catalog.-(integer, bigint) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.int48div, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog./(integer, bigint) is 'divide';

alter operator pg_catalog./(integer, bigint) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.box_distance, leftarg = box, rightarg = box, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(box, box) is 'distance between';

alter operator pg_catalog.<->(box, box) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.path_distance, leftarg = path, rightarg = path, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(path, path) is 'distance between';

alter operator pg_catalog.<->(path, path) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.line_distance, leftarg = line, rightarg = line, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(line, line) is 'distance between';

alter operator pg_catalog.<->(line, line) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.lseg_distance, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(lseg, lseg) is 'distance between';

alter operator pg_catalog.<->(lseg, lseg) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.poly_distance, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(polygon, polygon) is 'distance between';

alter operator pg_catalog.<->(polygon, polygon) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.point_add, leftarg = point, rightarg = point, commutator = pg_catalog.+);

comment on operator pg_catalog.+(point, point) is 'add points (translate)';

alter operator pg_catalog.+(point, point) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.point_sub, leftarg = point, rightarg = point);

comment on operator pg_catalog.-(point, point) is 'subtract points (translate)';

alter operator pg_catalog.-(point, point) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.point_mul, leftarg = point, rightarg = point, commutator = pg_catalog.*);

comment on operator pg_catalog.*(point, point) is 'multiply points (scale/rotate)';

alter operator pg_catalog.*(point, point) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.point_div, leftarg = point, rightarg = point);

comment on operator pg_catalog./(point, point) is 'divide points (scale/rotate)';

alter operator pg_catalog./(point, point) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.path_add, leftarg = path, rightarg = path, commutator = pg_catalog.+);

comment on operator pg_catalog.+(path, path) is 'concatenate';

alter operator pg_catalog.+(path, path) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.path_add_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.+(path, point) is 'add (translate path)';

alter operator pg_catalog.+(path, point) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.path_sub_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.-(path, point) is 'subtract (translate path)';

alter operator pg_catalog.-(path, point) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.path_mul_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.*(path, point) is 'multiply (rotate/scale path)';

alter operator pg_catalog.*(path, point) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.path_div_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog./(path, point) is 'divide (rotate/scale path)';

alter operator pg_catalog./(path, point) owner to postgres;

create operator pg_catalog.@ (procedure = pg_catalog.int4abs, rightarg = integer);

comment on operator pg_catalog.@(none, integer) is 'absolute value';

alter operator pg_catalog.@(none, integer) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.path_n_eq, leftarg = path, rightarg = path, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(path, path) is 'equal';

alter operator pg_catalog.=(path, path) owner to postgres;

create operator pg_catalog.# (procedure = pg_catalog.path_npoints, rightarg = path);

comment on operator pg_catalog.#(none, path) is 'number of points';

alter operator pg_catalog.#(none, path) owner to postgres;

create operator pg_catalog.?# (procedure = pg_catalog.path_inter, leftarg = path, rightarg = path);

comment on operator pg_catalog.?#(path, path) is 'intersect';

alter operator pg_catalog.?#(path, path) owner to postgres;

create operator pg_catalog.@-@ (procedure = pg_catalog.path_length, rightarg = path);

comment on operator pg_catalog.@-@(none, path) is 'sum of path segment lengths';

alter operator pg_catalog.@-@(none, path) owner to postgres;

create operator pg_catalog.>^ (procedure = pg_catalog.box_above_eq, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>^(box, box) is 'is above (allows touching)';

alter operator pg_catalog.>^(box, box) owner to postgres;

create operator pg_catalog.<^ (procedure = pg_catalog.box_below_eq, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<^(box, box) is 'is below (allows touching)';

alter operator pg_catalog.<^(box, box) owner to postgres;

create operator pg_catalog.?# (procedure = pg_catalog.box_overlap, leftarg = box, rightarg = box, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.?#(box, box) is 'deprecated, use && instead';

alter operator pg_catalog.?#(box, box) owner to postgres;

create operator pg_catalog.# (procedure = pg_catalog.box_intersect, leftarg = box, rightarg = box);

comment on operator pg_catalog.#(box, box) is 'box intersection';

alter operator pg_catalog.#(box, box) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.box_add, leftarg = box, rightarg = point);

comment on operator pg_catalog.+(box, point) is 'add point to box (translate)';

alter operator pg_catalog.+(box, point) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.box_sub, leftarg = box, rightarg = point);

comment on operator pg_catalog.-(box, point) is 'subtract point from box (translate)';

alter operator pg_catalog.-(box, point) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.box_mul, leftarg = box, rightarg = point);

comment on operator pg_catalog.*(box, point) is 'multiply box by point (scale)';

alter operator pg_catalog.*(box, point) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.box_div, leftarg = box, rightarg = point);

comment on operator pg_catalog./(box, point) is 'divide box by point (scale)';

alter operator pg_catalog./(box, point) owner to postgres;

create operator pg_catalog.?- (procedure = pg_catalog.point_horiz, leftarg = point, rightarg = point, commutator = pg_catalog.?-);

comment on operator pg_catalog.?-(point, point) is 'horizontally aligned';

alter operator pg_catalog.?-(point, point) owner to postgres;

create operator pg_catalog.?| (procedure = pg_catalog.point_vert, leftarg = point, rightarg = point, commutator = pg_catalog.?|);

comment on operator pg_catalog.?|(point, point) is 'vertically aligned';

alter operator pg_catalog.?|(point, point) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.int82mi, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.-(bigint, smallint) is 'subtract';

alter operator pg_catalog.-(bigint, smallint) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.int82div, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog./(bigint, smallint) is 'divide';

alter operator pg_catalog./(bigint, smallint) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.int28mi, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.-(smallint, bigint) is 'subtract';

alter operator pg_catalog.-(smallint, bigint) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.int28div, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog./(smallint, bigint) is 'divide';

alter operator pg_catalog./(smallint, bigint) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.cash_div_flt4, leftarg = money, rightarg = real);

comment on operator pg_catalog./(money, real) is 'divide';

alter operator pg_catalog./(money, real) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.cash_pl, leftarg = money, rightarg = money, commutator = pg_catalog.+);

comment on operator pg_catalog.+(money, money) is 'add';

alter operator pg_catalog.+(money, money) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.cash_mi, leftarg = money, rightarg = money);

comment on operator pg_catalog.-(money, money) is 'subtract';

alter operator pg_catalog.-(money, money) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.cash_div_flt8, leftarg = money, rightarg = double precision);

comment on operator pg_catalog./(money, double precision) is 'divide';

alter operator pg_catalog./(money, double precision) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.cash_div_int4, leftarg = money, rightarg = integer);

comment on operator pg_catalog./(money, integer) is 'divide';

alter operator pg_catalog./(money, integer) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.cash_div_int2, leftarg = money, rightarg = smallint);

comment on operator pg_catalog./(money, smallint) is 'divide';

alter operator pg_catalog./(money, smallint) owner to postgres;

create operator pg_catalog.^ (procedure = pg_catalog.dpow, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.^(double precision, double precision) is 'exponentiation';

alter operator pg_catalog.^(double precision, double precision) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.aclinsert, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.+(aclitem[], aclitem) is 'add/update ACL item';

alter operator pg_catalog.+(aclitem[], aclitem) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.aclremove, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.-(aclitem[], aclitem) is 'remove ACL item';

alter operator pg_catalog.-(aclitem[], aclitem) owner to postgres;

create operator pg_catalog.@> (procedure = pg_catalog.aclcontains, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.@>(aclitem[], aclitem) is 'contains';

alter operator pg_catalog.@>(aclitem[], aclitem) owner to postgres;

create operator pg_catalog.@@ (procedure = pg_catalog.lseg_center, rightarg = lseg);

comment on operator pg_catalog.@@(none, lseg) is 'center of';

alter operator pg_catalog.@@(none, lseg) owner to postgres;

create operator pg_catalog.@@ (procedure = pg_catalog.path_center, rightarg = path);

comment on operator pg_catalog.@@(none, path) is 'center of';

alter operator pg_catalog.@@(none, path) owner to postgres;

create operator pg_catalog.@@ (procedure = pg_catalog.poly_center, rightarg = polygon);

comment on operator pg_catalog.@@(none, polygon) is 'center of';

alter operator pg_catalog.@@(none, polygon) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.aclitemeq, leftarg = aclitem, rightarg = aclitem, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes);

comment on operator pg_catalog.=(aclitem, aclitem) is 'equal';

alter operator pg_catalog.=(aclitem, aclitem) owner to postgres;

create operator pg_catalog.^ (procedure = pg_catalog.numeric_power, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.^(numeric, numeric) is 'exponentiation';

alter operator pg_catalog.^(numeric, numeric) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.date_mi_interval, leftarg = date, rightarg = interval);

comment on operator pg_catalog.-(date, interval) is 'subtract';

alter operator pg_catalog.-(date, interval) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.date_mi, leftarg = date, rightarg = date);

comment on operator pg_catalog.-(date, date) is 'subtract';

alter operator pg_catalog.-(date, date) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.date_mii, leftarg = date, rightarg = integer);

comment on operator pg_catalog.-(date, integer) is 'subtract';

alter operator pg_catalog.-(date, integer) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.float48mi, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.-(real, double precision) is 'subtract';

alter operator pg_catalog.-(real, double precision) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.float48div, leftarg = real, rightarg = double precision);

comment on operator pg_catalog./(real, double precision) is 'divide';

alter operator pg_catalog./(real, double precision) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.float84mi, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.-(double precision, real) is 'subtract';

alter operator pg_catalog.-(double precision, real) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.float84div, leftarg = double precision, rightarg = real);

comment on operator pg_catalog./(double precision, real) is 'divide';

alter operator pg_catalog./(double precision, real) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.timestamptz_mi, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.-(timestamp with time zone, timestamp with time zone) is 'subtract';

alter operator pg_catalog.-(timestamp with time zone, timestamp with time zone) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.timestamptz_mi_interval, leftarg = timestamp with time zone, rightarg = interval);

comment on operator pg_catalog.-(timestamp with time zone, interval) is 'subtract';

alter operator pg_catalog.-(timestamp with time zone, interval) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.interval_um, rightarg = interval);

comment on operator pg_catalog.-(none, interval) is 'negate';

alter operator pg_catalog.-(none, interval) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl, leftarg = interval, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, interval) is 'add';

alter operator pg_catalog.+(interval, interval) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.interval_mi, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.-(interval, interval) is 'subtract';

alter operator pg_catalog.-(interval, interval) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.time_mi_time, leftarg = time, rightarg = time);

comment on operator pg_catalog.-(time, time) is 'subtract';

alter operator pg_catalog.-(time, time) owner to postgres;

create operator pg_catalog.@@ (procedure = pg_catalog.circle_center, rightarg = circle);

comment on operator pg_catalog.@@(none, circle) is 'center of';

alter operator pg_catalog.@@(none, circle) owner to postgres;

create operator pg_catalog.<< (procedure = pg_catalog.circle_left, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<(circle, circle) is 'is left of';

alter operator pg_catalog.<<(circle, circle) owner to postgres;

create operator pg_catalog.&< (procedure = pg_catalog.circle_overleft, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<(circle, circle) is 'overlaps or is left of';

alter operator pg_catalog.&<(circle, circle) owner to postgres;

create operator pg_catalog.&> (procedure = pg_catalog.circle_overright, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&>(circle, circle) is 'overlaps or is right of';

alter operator pg_catalog.&>(circle, circle) owner to postgres;

create operator pg_catalog.>> (procedure = pg_catalog.circle_right, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>>(circle, circle) is 'is right of';

alter operator pg_catalog.>>(circle, circle) owner to postgres;

create operator pg_catalog.~= (procedure = pg_catalog.circle_same, leftarg = circle, rightarg = circle, commutator = pg_catalog.~=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.~=(circle, circle) is 'same as';

alter operator pg_catalog.~=(circle, circle) owner to postgres;

create operator pg_catalog.&& (procedure = pg_catalog.circle_overlap, leftarg = circle, rightarg = circle, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.&&(circle, circle) is 'overlaps';

alter operator pg_catalog.&&(circle, circle) owner to postgres;

create operator pg_catalog.|>> (procedure = pg_catalog.circle_above, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|>>(circle, circle) is 'is above';

alter operator pg_catalog.|>>(circle, circle) owner to postgres;

create operator pg_catalog.<<| (procedure = pg_catalog.circle_below, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<|(circle, circle) is 'is below';

alter operator pg_catalog.<<|(circle, circle) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.circle_add_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.+(circle, point) is 'add';

alter operator pg_catalog.+(circle, point) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.circle_sub_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.-(circle, point) is 'subtract';

alter operator pg_catalog.-(circle, point) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.circle_mul_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.*(circle, point) is 'multiply';

alter operator pg_catalog.*(circle, point) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.circle_div_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog./(circle, point) is 'divide';

alter operator pg_catalog./(circle, point) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.circle_distance, leftarg = circle, rightarg = circle, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(circle, circle) is 'distance between';

alter operator pg_catalog.<->(circle, circle) owner to postgres;

create operator pg_catalog.# (procedure = pg_catalog.poly_npoints, rightarg = polygon);

comment on operator pg_catalog.#(none, polygon) is 'number of points';

alter operator pg_catalog.#(none, polygon) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.dist_cpoly, leftarg = circle, rightarg = polygon);

comment on operator pg_catalog.<->(circle, polygon) is 'distance between';

alter operator pg_catalog.<->(circle, polygon) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.dist_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.<->(line, box) is 'distance between';

alter operator pg_catalog.<->(line, box) owner to postgres;

create operator pg_catalog.?# (procedure = pg_catalog.lseg_intersect, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.?#);

comment on operator pg_catalog.?#(lseg, lseg) is 'intersect';

alter operator pg_catalog.?#(lseg, lseg) owner to postgres;

create operator pg_catalog.?|| (procedure = pg_catalog.lseg_parallel, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.?||);

comment on operator pg_catalog.?||(lseg, lseg) is 'parallel';

alter operator pg_catalog.?||(lseg, lseg) owner to postgres;

create operator pg_catalog.?-| (procedure = pg_catalog.lseg_perp, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.?-|);

comment on operator pg_catalog.?-|(lseg, lseg) is 'perpendicular';

alter operator pg_catalog.?-|(lseg, lseg) owner to postgres;

create operator pg_catalog.?- (procedure = pg_catalog.lseg_horizontal, rightarg = lseg);

comment on operator pg_catalog.?-(none, lseg) is 'horizontal';

alter operator pg_catalog.?-(none, lseg) owner to postgres;

create operator pg_catalog.?| (procedure = pg_catalog.lseg_vertical, rightarg = lseg);

comment on operator pg_catalog.?|(none, lseg) is 'vertical';

alter operator pg_catalog.?|(none, lseg) owner to postgres;

create operator pg_catalog.# (procedure = pg_catalog.lseg_interpt, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.#);

comment on operator pg_catalog.#(lseg, lseg) is 'intersection point';

alter operator pg_catalog.#(lseg, lseg) owner to postgres;

create operator pg_catalog.?# (procedure = pg_catalog.inter_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.?#(lseg, line) is 'intersect';

alter operator pg_catalog.?#(lseg, line) owner to postgres;

create operator pg_catalog.?# (procedure = pg_catalog.inter_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.?#(lseg, box) is 'intersect';

alter operator pg_catalog.?#(lseg, box) owner to postgres;

create operator pg_catalog.?# (procedure = pg_catalog.inter_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.?#(line, box) is 'intersect';

alter operator pg_catalog.?#(line, box) owner to postgres;

create operator pg_catalog.<@ (procedure = pg_catalog.on_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.<@(point, line) is 'point on line';

alter operator pg_catalog.<@(point, line) owner to postgres;

create operator pg_catalog.<@ (procedure = pg_catalog.on_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.<@(point, lseg) is 'is contained by';

alter operator pg_catalog.<@(point, lseg) owner to postgres;

create operator pg_catalog.<@ (procedure = pg_catalog.on_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.<@(lseg, line) is 'lseg on line';

alter operator pg_catalog.<@(lseg, line) owner to postgres;

create operator pg_catalog.<@ (procedure = pg_catalog.on_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.<@(lseg, box) is 'is contained by';

alter operator pg_catalog.<@(lseg, box) owner to postgres;

create operator pg_catalog.## (procedure = pg_catalog.close_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.##(point, line) is 'closest point to A on B';

alter operator pg_catalog.##(point, line) owner to postgres;

create operator pg_catalog.## (procedure = pg_catalog.close_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.##(point, lseg) is 'closest point to A on B';

alter operator pg_catalog.##(point, lseg) owner to postgres;

create operator pg_catalog.## (procedure = pg_catalog.close_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.##(point, box) is 'closest point to A on B';

alter operator pg_catalog.##(point, box) owner to postgres;

create operator pg_catalog.## (procedure = pg_catalog.close_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.##(lseg, line) is 'closest point to A on B';

alter operator pg_catalog.##(lseg, line) owner to postgres;

create operator pg_catalog.## (procedure = pg_catalog.close_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.##(lseg, box) is 'closest point to A on B';

alter operator pg_catalog.##(lseg, box) owner to postgres;

create operator pg_catalog.## (procedure = pg_catalog.close_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.##(line, box) is 'closest point to A on B';

alter operator pg_catalog.##(line, box) owner to postgres;

create operator pg_catalog.## (procedure = pg_catalog.close_ls, leftarg = line, rightarg = lseg);

comment on operator pg_catalog.##(line, lseg) is 'closest point to A on B';

alter operator pg_catalog.##(line, lseg) owner to postgres;

create operator pg_catalog.## (procedure = pg_catalog.close_lseg, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.##(lseg, lseg) is 'closest point to A on B';

alter operator pg_catalog.##(lseg, lseg) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.interval_div, leftarg = interval, rightarg = double precision);

comment on operator pg_catalog./(interval, double precision) is 'divide';

alter operator pg_catalog./(interval, double precision) owner to postgres;

create operator pg_catalog.@-@ (procedure = pg_catalog.lseg_length, rightarg = lseg);

comment on operator pg_catalog.@-@(none, lseg) is 'distance between endpoints';

alter operator pg_catalog.@-@(none, lseg) owner to postgres;

create operator pg_catalog.?# (procedure = pg_catalog.line_intersect, leftarg = line, rightarg = line, commutator = pg_catalog.?#);

comment on operator pg_catalog.?#(line, line) is 'intersect';

alter operator pg_catalog.?#(line, line) owner to postgres;

create operator pg_catalog.?|| (procedure = pg_catalog.line_parallel, leftarg = line, rightarg = line, commutator = pg_catalog.?||);

comment on operator pg_catalog.?||(line, line) is 'parallel';

alter operator pg_catalog.?||(line, line) owner to postgres;

create operator pg_catalog.?-| (procedure = pg_catalog.line_perp, leftarg = line, rightarg = line, commutator = pg_catalog.?-|);

comment on operator pg_catalog.?-|(line, line) is 'perpendicular';

alter operator pg_catalog.?-|(line, line) owner to postgres;

create operator pg_catalog.?- (procedure = pg_catalog.line_horizontal, rightarg = line);

comment on operator pg_catalog.?-(none, line) is 'horizontal';

alter operator pg_catalog.?-(none, line) owner to postgres;

create operator pg_catalog.?| (procedure = pg_catalog.line_vertical, rightarg = line);

comment on operator pg_catalog.?|(none, line) is 'vertical';

alter operator pg_catalog.?|(none, line) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.line_eq, leftarg = line, rightarg = line, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(line, line) is 'equal';

alter operator pg_catalog.=(line, line) owner to postgres;

create operator pg_catalog.# (procedure = pg_catalog.line_interpt, leftarg = line, rightarg = line, commutator = pg_catalog.#);

comment on operator pg_catalog.#(line, line) is 'intersection point';

alter operator pg_catalog.#(line, line) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.numeric_uminus, rightarg = numeric);

comment on operator pg_catalog.-(none, numeric) is 'negate';

alter operator pg_catalog.-(none, numeric) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.numeric_add, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.+);

comment on operator pg_catalog.+(numeric, numeric) is 'add';

alter operator pg_catalog.+(numeric, numeric) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.numeric_sub, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.-(numeric, numeric) is 'subtract';

alter operator pg_catalog.-(numeric, numeric) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.numeric_mul, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.*);

comment on operator pg_catalog.*(numeric, numeric) is 'multiply';

alter operator pg_catalog.*(numeric, numeric) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.numeric_div, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog./(numeric, numeric) is 'divide';

alter operator pg_catalog./(numeric, numeric) owner to postgres;

create operator pg_catalog.% (procedure = pg_catalog.numeric_mod, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.%(numeric, numeric) is 'modulus';

alter operator pg_catalog.%(numeric, numeric) owner to postgres;

create operator pg_catalog.@ (procedure = pg_catalog.numeric_abs, rightarg = numeric);

comment on operator pg_catalog.@(none, numeric) is 'absolute value';

alter operator pg_catalog.@(none, numeric) owner to postgres;

create operator pg_catalog.& (procedure = pg_catalog.bitand, leftarg = bit, rightarg = bit, commutator = pg_catalog.&);

comment on operator pg_catalog.&(bit, bit) is 'bitwise and';

alter operator pg_catalog.&(bit, bit) owner to postgres;

create operator pg_catalog.| (procedure = pg_catalog.bitor, leftarg = bit, rightarg = bit, commutator = pg_catalog.|);

comment on operator pg_catalog.|(bit, bit) is 'bitwise or';

alter operator pg_catalog.|(bit, bit) owner to postgres;

create operator pg_catalog.# (procedure = pg_catalog.bitxor, leftarg = bit, rightarg = bit, commutator = pg_catalog.#);

comment on operator pg_catalog.#(bit, bit) is 'bitwise exclusive or';

alter operator pg_catalog.#(bit, bit) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.bitnot, rightarg = bit);

comment on operator pg_catalog.~(none, bit) is 'bitwise not';

alter operator pg_catalog.~(none, bit) owner to postgres;

create operator pg_catalog.<< (procedure = pg_catalog.bitshiftleft, leftarg = bit, rightarg = integer);

comment on operator pg_catalog.<<(bit, integer) is 'bitwise shift left';

alter operator pg_catalog.<<(bit, integer) owner to postgres;

create operator pg_catalog.>> (procedure = pg_catalog.bitshiftright, leftarg = bit, rightarg = integer);

comment on operator pg_catalog.>>(bit, integer) is 'bitwise shift right';

alter operator pg_catalog.>>(bit, integer) owner to postgres;

create operator pg_catalog.|| (procedure = pg_catalog.bitcat, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.||(bit varying, bit varying) is 'concatenate';

alter operator pg_catalog.||(bit varying, bit varying) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.time_mi_interval, leftarg = time, rightarg = interval);

comment on operator pg_catalog.-(time, interval) is 'subtract';

alter operator pg_catalog.-(time, interval) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.timetz_mi_interval, leftarg = time with time zone, rightarg = interval);

comment on operator pg_catalog.-(time with time zone, interval) is 'subtract';

alter operator pg_catalog.-(time with time zone, interval) owner to postgres;

create operator pg_catalog.& (procedure = pg_catalog.int2and, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.&);

comment on operator pg_catalog.&(smallint, smallint) is 'bitwise and';

alter operator pg_catalog.&(smallint, smallint) owner to postgres;

create operator pg_catalog.| (procedure = pg_catalog.int2or, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.|);

comment on operator pg_catalog.|(smallint, smallint) is 'bitwise or';

alter operator pg_catalog.|(smallint, smallint) owner to postgres;

create operator pg_catalog.# (procedure = pg_catalog.int2xor, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.#);

comment on operator pg_catalog.#(smallint, smallint) is 'bitwise exclusive or';

alter operator pg_catalog.#(smallint, smallint) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.int2not, rightarg = smallint);

comment on operator pg_catalog.~(none, smallint) is 'bitwise not';

alter operator pg_catalog.~(none, smallint) owner to postgres;

create operator pg_catalog.<< (procedure = pg_catalog.int2shl, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<<(smallint, integer) is 'bitwise shift left';

alter operator pg_catalog.<<(smallint, integer) owner to postgres;

create operator pg_catalog.>> (procedure = pg_catalog.int2shr, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.>>(smallint, integer) is 'bitwise shift right';

alter operator pg_catalog.>>(smallint, integer) owner to postgres;

create operator pg_catalog.& (procedure = pg_catalog.int4and, leftarg = integer, rightarg = integer, commutator = pg_catalog.&);

comment on operator pg_catalog.&(integer, integer) is 'bitwise and';

alter operator pg_catalog.&(integer, integer) owner to postgres;

create operator pg_catalog.| (procedure = pg_catalog.int4or, leftarg = integer, rightarg = integer, commutator = pg_catalog.|);

comment on operator pg_catalog.|(integer, integer) is 'bitwise or';

alter operator pg_catalog.|(integer, integer) owner to postgres;

create operator pg_catalog.# (procedure = pg_catalog.int4xor, leftarg = integer, rightarg = integer, commutator = pg_catalog.#);

comment on operator pg_catalog.#(integer, integer) is 'bitwise exclusive or';

alter operator pg_catalog.#(integer, integer) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.int4not, rightarg = integer);

comment on operator pg_catalog.~(none, integer) is 'bitwise not';

alter operator pg_catalog.~(none, integer) owner to postgres;

create operator pg_catalog.<< (procedure = pg_catalog.int4shl, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<<(integer, integer) is 'bitwise shift left';

alter operator pg_catalog.<<(integer, integer) owner to postgres;

create operator pg_catalog.>> (procedure = pg_catalog.int4shr, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.>>(integer, integer) is 'bitwise shift right';

alter operator pg_catalog.>>(integer, integer) owner to postgres;

create operator pg_catalog.& (procedure = pg_catalog.int8and, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.&);

comment on operator pg_catalog.&(bigint, bigint) is 'bitwise and';

alter operator pg_catalog.&(bigint, bigint) owner to postgres;

create operator pg_catalog.| (procedure = pg_catalog.int8or, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.|);

comment on operator pg_catalog.|(bigint, bigint) is 'bitwise or';

alter operator pg_catalog.|(bigint, bigint) owner to postgres;

create operator pg_catalog.# (procedure = pg_catalog.int8xor, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.#);

comment on operator pg_catalog.#(bigint, bigint) is 'bitwise exclusive or';

alter operator pg_catalog.#(bigint, bigint) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.int8not, rightarg = bigint);

comment on operator pg_catalog.~(none, bigint) is 'bitwise not';

alter operator pg_catalog.~(none, bigint) owner to postgres;

create operator pg_catalog.<< (procedure = pg_catalog.int8shl, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<<(bigint, integer) is 'bitwise shift left';

alter operator pg_catalog.<<(bigint, integer) owner to postgres;

create operator pg_catalog.>> (procedure = pg_catalog.int8shr, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.>>(bigint, integer) is 'bitwise shift right';

alter operator pg_catalog.>>(bigint, integer) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.int8up, rightarg = bigint);

comment on operator pg_catalog.+(none, bigint) is 'unary plus';

alter operator pg_catalog.+(none, bigint) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.int2up, rightarg = smallint);

comment on operator pg_catalog.+(none, smallint) is 'unary plus';

alter operator pg_catalog.+(none, smallint) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.int4up, rightarg = integer);

comment on operator pg_catalog.+(none, integer) is 'unary plus';

alter operator pg_catalog.+(none, integer) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.float4up, rightarg = real);

comment on operator pg_catalog.+(none, real) is 'unary plus';

alter operator pg_catalog.+(none, real) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.float8up, rightarg = double precision);

comment on operator pg_catalog.+(none, double precision) is 'unary plus';

alter operator pg_catalog.+(none, double precision) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.numeric_uplus, rightarg = numeric);

comment on operator pg_catalog.+(none, numeric) is 'unary plus';

alter operator pg_catalog.+(none, numeric) owner to postgres;

create operator pg_catalog.|| (procedure = pg_catalog.byteacat, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.||(bytea, bytea) is 'concatenate';

alter operator pg_catalog.||(bytea, bytea) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.timestamp_mi, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.-(timestamp, timestamp) is 'subtract';

alter operator pg_catalog.-(timestamp, timestamp) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.timestamp_mi_interval, leftarg = timestamp, rightarg = interval);

comment on operator pg_catalog.-(timestamp, interval) is 'subtract';

alter operator pg_catalog.-(timestamp, interval) owner to postgres;

create operator pg_catalog.<<| (procedure = pg_catalog.box_below, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<|(box, box) is 'is below';

alter operator pg_catalog.<<|(box, box) owner to postgres;

create operator pg_catalog.&<| (procedure = pg_catalog.box_overbelow, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<|(box, box) is 'overlaps or is below';

alter operator pg_catalog.&<|(box, box) owner to postgres;

create operator pg_catalog.|&> (procedure = pg_catalog.box_overabove, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|&>(box, box) is 'overlaps or is above';

alter operator pg_catalog.|&>(box, box) owner to postgres;

create operator pg_catalog.|>> (procedure = pg_catalog.box_above, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|>>(box, box) is 'is above';

alter operator pg_catalog.|>>(box, box) owner to postgres;

create operator pg_catalog.<<| (procedure = pg_catalog.poly_below, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<|(polygon, polygon) is 'is below';

alter operator pg_catalog.<<|(polygon, polygon) owner to postgres;

create operator pg_catalog.&<| (procedure = pg_catalog.poly_overbelow, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<|(polygon, polygon) is 'overlaps or is below';

alter operator pg_catalog.&<|(polygon, polygon) owner to postgres;

create operator pg_catalog.|&> (procedure = pg_catalog.poly_overabove, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|&>(polygon, polygon) is 'overlaps or is above';

alter operator pg_catalog.|&>(polygon, polygon) owner to postgres;

create operator pg_catalog.|>> (procedure = pg_catalog.poly_above, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|>>(polygon, polygon) is 'is above';

alter operator pg_catalog.|>>(polygon, polygon) owner to postgres;

create operator pg_catalog.&<| (procedure = pg_catalog.circle_overbelow, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<|(circle, circle) is 'overlaps or is below';

alter operator pg_catalog.&<|(circle, circle) owner to postgres;

create operator pg_catalog.|&> (procedure = pg_catalog.circle_overabove, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|&>(circle, circle) is 'overlaps or is above';

alter operator pg_catalog.|&>(circle, circle) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.inetnot, rightarg = inet);

comment on operator pg_catalog.~(none, inet) is 'bitwise not';

alter operator pg_catalog.~(none, inet) owner to postgres;

create operator pg_catalog.& (procedure = pg_catalog.inetand, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.&(inet, inet) is 'bitwise and';

alter operator pg_catalog.&(inet, inet) owner to postgres;

create operator pg_catalog.| (procedure = pg_catalog.inetor, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.|(inet, inet) is 'bitwise or';

alter operator pg_catalog.|(inet, inet) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.inetmi_int8, leftarg = inet, rightarg = bigint);

comment on operator pg_catalog.-(inet, bigint) is 'subtract';

alter operator pg_catalog.-(inet, bigint) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.inetmi, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.-(inet, inet) is 'subtract';

alter operator pg_catalog.-(inet, inet) owner to postgres;

create operator pg_catalog.&& (procedure = pg_catalog.arrayoverlap, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.&&, join = pg_catalog.arraycontjoinsel, restrict = pg_catalog.arraycontsel);

comment on operator pg_catalog.&&(anyarray, anyarray) is 'overlaps';

alter operator pg_catalog.&&(anyarray, anyarray) owner to postgres;

create operator pg_catalog.|| (procedure = pg_catalog.textanycat, leftarg = text, rightarg = anynonarray);

comment on operator pg_catalog.||(text, anynonarray) is 'concatenate';

alter operator pg_catalog.||(text, anynonarray) owner to postgres;

create operator pg_catalog.|| (procedure = pg_catalog.anytextcat, leftarg = anynonarray, rightarg = text);

comment on operator pg_catalog.||(anynonarray, text) is 'concatenate';

alter operator pg_catalog.||(anynonarray, text) owner to postgres;

create operator pg_catalog.@ (procedure = pg_catalog.on_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.@(point, box) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, box) owner to postgres;

create operator pg_catalog.@ (procedure = pg_catalog.on_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.@(point, line) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, line) owner to postgres;

create operator pg_catalog.@ (procedure = pg_catalog.on_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.@(point, lseg) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, lseg) owner to postgres;

create operator pg_catalog.@ (procedure = pg_catalog.on_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.@(lseg, line) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(lseg, line) owner to postgres;

create operator pg_catalog.@ (procedure = pg_catalog.on_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.@(lseg, box) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(lseg, box) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.aclcontains, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.~(aclitem[], aclitem) is 'deprecated, use @> instead';

alter operator pg_catalog.~(aclitem[], aclitem) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.macaddr_not, rightarg = macaddr);

comment on operator pg_catalog.~(none, macaddr) is 'bitwise not';

alter operator pg_catalog.~(none, macaddr) owner to postgres;

create operator pg_catalog.& (procedure = pg_catalog.macaddr_and, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.&(macaddr, macaddr) is 'bitwise and';

alter operator pg_catalog.&(macaddr, macaddr) owner to postgres;

create operator pg_catalog.| (procedure = pg_catalog.macaddr_or, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.|(macaddr, macaddr) is 'bitwise or';

alter operator pg_catalog.|(macaddr, macaddr) owner to postgres;

create operator pg_catalog.#>> (procedure = pg_catalog.jsonb_extract_path_text, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#>>(jsonb, text[]) is 'get value from jsonb as text with path elements';

alter operator pg_catalog.#>>(jsonb, text[]) owner to postgres;

create operator pg_catalog.-> (procedure = pg_catalog.jsonb_object_field, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.->(jsonb, text) is 'get jsonb object field';

alter operator pg_catalog.->(jsonb, text) owner to postgres;

create operator pg_catalog.-> (procedure = pg_catalog.jsonb_array_element, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.->(jsonb, integer) is 'get jsonb array element';

alter operator pg_catalog.->(jsonb, integer) owner to postgres;

create operator pg_catalog.#> (procedure = pg_catalog.jsonb_extract_path, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#>(jsonb, text[]) is 'get value from jsonb with path elements';

alter operator pg_catalog.#>(jsonb, text[]) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.pg_lsn_mi, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.-(pg_lsn, pg_lsn) is 'minus';

alter operator pg_catalog.-(pg_lsn, pg_lsn) owner to postgres;

create operator pg_catalog.? (procedure = pg_catalog.jsonb_exists, leftarg = jsonb, rightarg = text, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.?(jsonb, text) is 'key exists';

alter operator pg_catalog.?(jsonb, text) owner to postgres;

create operator pg_catalog.?| (procedure = pg_catalog.jsonb_exists_any, leftarg = jsonb, rightarg = text[], join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.?|(jsonb, text[]) is 'any key exists';

alter operator pg_catalog.?|(jsonb, text[]) owner to postgres;

create operator pg_catalog.?& (procedure = pg_catalog.jsonb_exists_all, leftarg = jsonb, rightarg = text[], join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.?&(jsonb, text[]) is 'all keys exist';

alter operator pg_catalog.?&(jsonb, text[]) owner to postgres;

create operator pg_catalog.|| (procedure = pg_catalog.jsonb_concat, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.||(jsonb, jsonb) is 'concatenate';

alter operator pg_catalog.||(jsonb, jsonb) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.jsonb_delete, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.-(jsonb, text) is 'delete object field';

alter operator pg_catalog.-(jsonb, text) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.jsonb_delete, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.-(jsonb, integer) is 'delete array element';

alter operator pg_catalog.-(jsonb, integer) owner to postgres;

create operator pg_catalog.#- (procedure = pg_catalog.jsonb_delete_path, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#-(jsonb, text[]) is 'delete path';

alter operator pg_catalog.#-(jsonb, text[]) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.cash_div_int8, leftarg = money, rightarg = bigint);

comment on operator pg_catalog./(money, bigint) is 'divide';

alter operator pg_catalog./(money, bigint) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.macaddr8_not, rightarg = macaddr8);

comment on operator pg_catalog.~(none, macaddr8) is 'bitwise not';

alter operator pg_catalog.~(none, macaddr8) owner to postgres;

create operator pg_catalog.& (procedure = pg_catalog.macaddr8_and, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.&(macaddr8, macaddr8) is 'bitwise and';

alter operator pg_catalog.&(macaddr8, macaddr8) owner to postgres;

create operator pg_catalog.| (procedure = pg_catalog.macaddr8_or, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.|(macaddr8, macaddr8) is 'bitwise or';

alter operator pg_catalog.|(macaddr8, macaddr8) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.jsonb_delete, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.-(jsonb, text[]) is 'delete object fields';

alter operator pg_catalog.-(jsonb, text[]) owner to postgres;

create operator pg_catalog.->> (procedure = pg_catalog.jsonb_object_field_text, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.->>(jsonb, text) is 'get jsonb object field as text';

alter operator pg_catalog.->>(jsonb, text) owner to postgres;

create operator pg_catalog.->> (procedure = pg_catalog.jsonb_array_element_text, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.->>(jsonb, integer) is 'get jsonb array element as text';

alter operator pg_catalog.->>(jsonb, integer) owner to postgres;

create operator pg_catalog.&& (procedure = pg_catalog.network_overlap, leftarg = inet, rightarg = inet, commutator = pg_catalog.&&, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.&&(inet, inet) is 'overlaps (is subnet or supernet)';

alter operator pg_catalog.&&(inet, inet) owner to postgres;

create operator pg_catalog.|| (procedure = pg_catalog.tsvector_concat, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.||(tsvector, tsvector) is 'concatenate';

alter operator pg_catalog.||(tsvector, tsvector) owner to postgres;

create operator pg_catalog.&& (procedure = pg_catalog.tsquery_and, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.&&(tsquery, tsquery) is 'AND-concatenate';

alter operator pg_catalog.&&(tsquery, tsquery) owner to postgres;

create operator pg_catalog.|| (procedure = pg_catalog.tsquery_or, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.||(tsquery, tsquery) is 'OR-concatenate';

alter operator pg_catalog.||(tsquery, tsquery) owner to postgres;

create operator pg_catalog.!! (procedure = pg_catalog.tsquery_not, rightarg = tsquery);

comment on operator pg_catalog.!!(none, tsquery) is 'NOT tsquery';

alter operator pg_catalog.!!(none, tsquery) owner to postgres;

create operator pg_catalog.@@ (procedure = pg_catalog.ts_match_tt, leftarg = text, rightarg = text, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@@(text, text) is 'text search match';

alter operator pg_catalog.@@(text, text) owner to postgres;

create operator pg_catalog.@@ (procedure = pg_catalog.ts_match_tq, leftarg = text, rightarg = tsquery, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@@(text, tsquery) is 'text search match';

alter operator pg_catalog.@@(text, tsquery) owner to postgres;

create operator pg_catalog./ (procedure = pg_catalog.cash_div_cash, leftarg = money, rightarg = money);

comment on operator pg_catalog./(money, money) is 'divide';

alter operator pg_catalog./(money, money) owner to postgres;

create operator pg_catalog.^@ (procedure = pg_catalog.starts_with, leftarg = text, rightarg = text, join = pg_catalog.prefixjoinsel, restrict = pg_catalog.prefixsel);

comment on operator pg_catalog.^@(text, text) is 'starts with';

alter operator pg_catalog.^@(text, text) owner to postgres;

create operator pg_catalog.&& (procedure = pg_catalog.range_overlaps, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.&&(anyrange, anyrange) is 'overlaps';

alter operator pg_catalog.&&(anyrange, anyrange) owner to postgres;

create operator pg_catalog.&< (procedure = pg_catalog.range_overleft, leftarg = anyrange, rightarg = anyrange, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.&<(anyrange, anyrange) is 'overlaps or is left of';

alter operator pg_catalog.&<(anyrange, anyrange) owner to postgres;

create operator pg_catalog.&> (procedure = pg_catalog.range_overright, leftarg = anyrange, rightarg = anyrange, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.&>(anyrange, anyrange) is 'overlaps or is right of';

alter operator pg_catalog.&>(anyrange, anyrange) owner to postgres;

create operator pg_catalog.-|- (procedure = pg_catalog.range_adjacent, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.-|-, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.-|-(anyrange, anyrange) is 'is adjacent to';

alter operator pg_catalog.-|-(anyrange, anyrange) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.range_union, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.+);

comment on operator pg_catalog.+(anyrange, anyrange) is 'range union';

alter operator pg_catalog.+(anyrange, anyrange) owner to postgres;

create operator pg_catalog.- (procedure = pg_catalog.range_minus, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.-(anyrange, anyrange) is 'range difference';

alter operator pg_catalog.-(anyrange, anyrange) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.range_intersect, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.*);

comment on operator pg_catalog.*(anyrange, anyrange) is 'range intersection';

alter operator pg_catalog.*(anyrange, anyrange) owner to postgres;

create operator pg_catalog.-> (procedure = pg_catalog.json_object_field, leftarg = json, rightarg = text);

comment on operator pg_catalog.->(json, text) is 'get json object field';

alter operator pg_catalog.->(json, text) owner to postgres;

create operator pg_catalog.->> (procedure = pg_catalog.json_object_field_text, leftarg = json, rightarg = text);

comment on operator pg_catalog.->>(json, text) is 'get json object field as text';

alter operator pg_catalog.->>(json, text) owner to postgres;

create operator pg_catalog.-> (procedure = pg_catalog.json_array_element, leftarg = json, rightarg = integer);

comment on operator pg_catalog.->(json, integer) is 'get json array element';

alter operator pg_catalog.->(json, integer) owner to postgres;

create operator pg_catalog.->> (procedure = pg_catalog.json_array_element_text, leftarg = json, rightarg = integer);

comment on operator pg_catalog.->>(json, integer) is 'get json array element as text';

alter operator pg_catalog.->>(json, integer) owner to postgres;

create operator pg_catalog.#> (procedure = pg_catalog.json_extract_path, leftarg = json, rightarg = text[]);

comment on operator pg_catalog.#>(json, text[]) is 'get value from json with path elements';

alter operator pg_catalog.#>(json, text[]) owner to postgres;

create operator pg_catalog.#>> (procedure = pg_catalog.json_extract_path_text, leftarg = json, rightarg = text[]);

comment on operator pg_catalog.#>>(json, text[]) is 'get value from json as text with path elements';

alter operator pg_catalog.#>>(json, text[]) owner to postgres;

create operator pg_catalog.@? (procedure = pg_catalog.jsonb_path_exists_opr, leftarg = jsonb, rightarg = jsonpath, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@?(jsonb, jsonpath) is 'jsonpath exists';

alter operator pg_catalog.@?(jsonb, jsonpath) owner to postgres;

create operator pg_catalog.@@ (procedure = pg_catalog.jsonb_path_match_opr, leftarg = jsonb, rightarg = jsonpath, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@@(jsonb, jsonpath) is 'jsonpath match';

alter operator pg_catalog.@@(jsonb, jsonpath) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.tsquery_phrase, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<->(tsquery, tsquery) is 'phrase-concatenate';

alter operator pg_catalog.<->(tsquery, tsquery) owner to postgres;

create collation pg_catalog."default" (
    locale = ???
    );

comment on collation pg_catalog."default" is 'database''s default collation';

alter collation pg_catalog."default" owner to postgres;

create collation pg_catalog."C" (
    locale = 'C'
    );

comment on collation pg_catalog."C" is 'standard C collation';

alter collation pg_catalog."C" owner to postgres;

create collation pg_catalog."POSIX" (
    locale = 'POSIX'
    );

comment on collation pg_catalog."POSIX" is 'standard POSIX collation';

alter collation pg_catalog."POSIX" owner to postgres;

create collation pg_catalog.ucs_basic (
    locale = 'C'
    );

alter collation pg_catalog.ucs_basic owner to postgres;

create collation pg_catalog."C.UTF-8" (
    locale = 'C.UTF-8'
    );

alter collation pg_catalog."C.UTF-8" owner to postgres;

create collation pg_catalog."en_US.utf8" (
    locale = 'en_US.utf8'
    );

alter collation pg_catalog."en_US.utf8" owner to postgres;

create collation pg_catalog."en_US" (
    locale = 'en_US.utf8'
    );

alter collation pg_catalog."en_US" owner to postgres;

create collation pg_catalog."und-x-icu" (
    locale = 'und'
    );

comment on collation pg_catalog."und-x-icu" is 'Unknown language';

alter collation pg_catalog."und-x-icu" owner to postgres;

create collation pg_catalog."af-x-icu" (
    locale = 'af'
    );

comment on collation pg_catalog."af-x-icu" is 'Afrikaans';

alter collation pg_catalog."af-x-icu" owner to postgres;

create collation pg_catalog."af-NA-x-icu" (
    locale = 'af-NA'
    );

comment on collation pg_catalog."af-NA-x-icu" is 'Afrikaans (Namibia)';

alter collation pg_catalog."af-NA-x-icu" owner to postgres;

create collation pg_catalog."af-ZA-x-icu" (
    locale = 'af-ZA'
    );

comment on collation pg_catalog."af-ZA-x-icu" is 'Afrikaans (South Africa)';

alter collation pg_catalog."af-ZA-x-icu" owner to postgres;

create collation pg_catalog."agq-x-icu" (
    locale = 'agq'
    );

comment on collation pg_catalog."agq-x-icu" is 'Aghem';

alter collation pg_catalog."agq-x-icu" owner to postgres;

create collation pg_catalog."agq-CM-x-icu" (
    locale = 'agq-CM'
    );

comment on collation pg_catalog."agq-CM-x-icu" is 'Aghem (Cameroon)';

alter collation pg_catalog."agq-CM-x-icu" owner to postgres;

create collation pg_catalog."ak-x-icu" (
    locale = 'ak'
    );

comment on collation pg_catalog."ak-x-icu" is 'Akan';

alter collation pg_catalog."ak-x-icu" owner to postgres;

create collation pg_catalog."ak-GH-x-icu" (
    locale = 'ak-GH'
    );

comment on collation pg_catalog."ak-GH-x-icu" is 'Akan (Ghana)';

alter collation pg_catalog."ak-GH-x-icu" owner to postgres;

create collation pg_catalog."am-x-icu" (
    locale = 'am'
    );

comment on collation pg_catalog."am-x-icu" is 'Amharic';

alter collation pg_catalog."am-x-icu" owner to postgres;

create collation pg_catalog."am-ET-x-icu" (
    locale = 'am-ET'
    );

comment on collation pg_catalog."am-ET-x-icu" is 'Amharic (Ethiopia)';

alter collation pg_catalog."am-ET-x-icu" owner to postgres;

create collation pg_catalog."ar-x-icu" (
    locale = 'ar'
    );

comment on collation pg_catalog."ar-x-icu" is 'Arabic';

alter collation pg_catalog."ar-x-icu" owner to postgres;

create collation pg_catalog."ar-001-x-icu" (
    locale = 'ar-001'
    );

comment on collation pg_catalog."ar-001-x-icu" is 'Arabic (World)';

alter collation pg_catalog."ar-001-x-icu" owner to postgres;

create collation pg_catalog."ar-AE-x-icu" (
    locale = 'ar-AE'
    );

comment on collation pg_catalog."ar-AE-x-icu" is 'Arabic (United Arab Emirates)';

alter collation pg_catalog."ar-AE-x-icu" owner to postgres;

create collation pg_catalog."ar-BH-x-icu" (
    locale = 'ar-BH'
    );

comment on collation pg_catalog."ar-BH-x-icu" is 'Arabic (Bahrain)';

alter collation pg_catalog."ar-BH-x-icu" owner to postgres;

create collation pg_catalog."ar-DJ-x-icu" (
    locale = 'ar-DJ'
    );

comment on collation pg_catalog."ar-DJ-x-icu" is 'Arabic (Djibouti)';

alter collation pg_catalog."ar-DJ-x-icu" owner to postgres;

create collation pg_catalog."ar-DZ-x-icu" (
    locale = 'ar-DZ'
    );

comment on collation pg_catalog."ar-DZ-x-icu" is 'Arabic (Algeria)';

alter collation pg_catalog."ar-DZ-x-icu" owner to postgres;

create collation pg_catalog."ar-EG-x-icu" (
    locale = 'ar-EG'
    );

comment on collation pg_catalog."ar-EG-x-icu" is 'Arabic (Egypt)';

alter collation pg_catalog."ar-EG-x-icu" owner to postgres;

create collation pg_catalog."ar-EH-x-icu" (
    locale = 'ar-EH'
    );

comment on collation pg_catalog."ar-EH-x-icu" is 'Arabic (Western Sahara)';

alter collation pg_catalog."ar-EH-x-icu" owner to postgres;

create collation pg_catalog."ar-ER-x-icu" (
    locale = 'ar-ER'
    );

comment on collation pg_catalog."ar-ER-x-icu" is 'Arabic (Eritrea)';

alter collation pg_catalog."ar-ER-x-icu" owner to postgres;

create collation pg_catalog."ar-IL-x-icu" (
    locale = 'ar-IL'
    );

comment on collation pg_catalog."ar-IL-x-icu" is 'Arabic (Israel)';

alter collation pg_catalog."ar-IL-x-icu" owner to postgres;

create collation pg_catalog."ar-IQ-x-icu" (
    locale = 'ar-IQ'
    );

comment on collation pg_catalog."ar-IQ-x-icu" is 'Arabic (Iraq)';

alter collation pg_catalog."ar-IQ-x-icu" owner to postgres;

create collation pg_catalog."ar-JO-x-icu" (
    locale = 'ar-JO'
    );

comment on collation pg_catalog."ar-JO-x-icu" is 'Arabic (Jordan)';

alter collation pg_catalog."ar-JO-x-icu" owner to postgres;

create collation pg_catalog."ar-KM-x-icu" (
    locale = 'ar-KM'
    );

comment on collation pg_catalog."ar-KM-x-icu" is 'Arabic (Comoros)';

alter collation pg_catalog."ar-KM-x-icu" owner to postgres;

create collation pg_catalog."ar-KW-x-icu" (
    locale = 'ar-KW'
    );

comment on collation pg_catalog."ar-KW-x-icu" is 'Arabic (Kuwait)';

alter collation pg_catalog."ar-KW-x-icu" owner to postgres;

create collation pg_catalog."ar-LB-x-icu" (
    locale = 'ar-LB'
    );

comment on collation pg_catalog."ar-LB-x-icu" is 'Arabic (Lebanon)';

alter collation pg_catalog."ar-LB-x-icu" owner to postgres;

create collation pg_catalog."ar-LY-x-icu" (
    locale = 'ar-LY'
    );

comment on collation pg_catalog."ar-LY-x-icu" is 'Arabic (Libya)';

alter collation pg_catalog."ar-LY-x-icu" owner to postgres;

create collation pg_catalog."ar-MA-x-icu" (
    locale = 'ar-MA'
    );

comment on collation pg_catalog."ar-MA-x-icu" is 'Arabic (Morocco)';

alter collation pg_catalog."ar-MA-x-icu" owner to postgres;

create collation pg_catalog."ar-MR-x-icu" (
    locale = 'ar-MR'
    );

comment on collation pg_catalog."ar-MR-x-icu" is 'Arabic (Mauritania)';

alter collation pg_catalog."ar-MR-x-icu" owner to postgres;

create collation pg_catalog."ar-OM-x-icu" (
    locale = 'ar-OM'
    );

comment on collation pg_catalog."ar-OM-x-icu" is 'Arabic (Oman)';

alter collation pg_catalog."ar-OM-x-icu" owner to postgres;

create collation pg_catalog."ar-PS-x-icu" (
    locale = 'ar-PS'
    );

comment on collation pg_catalog."ar-PS-x-icu" is 'Arabic (Palestinian Territories)';

alter collation pg_catalog."ar-PS-x-icu" owner to postgres;

create collation pg_catalog."ar-QA-x-icu" (
    locale = 'ar-QA'
    );

comment on collation pg_catalog."ar-QA-x-icu" is 'Arabic (Qatar)';

alter collation pg_catalog."ar-QA-x-icu" owner to postgres;

create collation pg_catalog."ar-SA-x-icu" (
    locale = 'ar-SA'
    );

comment on collation pg_catalog."ar-SA-x-icu" is 'Arabic (Saudi Arabia)';

alter collation pg_catalog."ar-SA-x-icu" owner to postgres;

create collation pg_catalog."ar-SD-x-icu" (
    locale = 'ar-SD'
    );

comment on collation pg_catalog."ar-SD-x-icu" is 'Arabic (Sudan)';

alter collation pg_catalog."ar-SD-x-icu" owner to postgres;

create collation pg_catalog."ar-SO-x-icu" (
    locale = 'ar-SO'
    );

comment on collation pg_catalog."ar-SO-x-icu" is 'Arabic (Somalia)';

alter collation pg_catalog."ar-SO-x-icu" owner to postgres;

create collation pg_catalog."ar-SS-x-icu" (
    locale = 'ar-SS'
    );

comment on collation pg_catalog."ar-SS-x-icu" is 'Arabic (South Sudan)';

alter collation pg_catalog."ar-SS-x-icu" owner to postgres;

create collation pg_catalog."ar-SY-x-icu" (
    locale = 'ar-SY'
    );

comment on collation pg_catalog."ar-SY-x-icu" is 'Arabic (Syria)';

alter collation pg_catalog."ar-SY-x-icu" owner to postgres;

create collation pg_catalog."ar-TD-x-icu" (
    locale = 'ar-TD'
    );

comment on collation pg_catalog."ar-TD-x-icu" is 'Arabic (Chad)';

alter collation pg_catalog."ar-TD-x-icu" owner to postgres;

create collation pg_catalog."ar-TN-x-icu" (
    locale = 'ar-TN'
    );

comment on collation pg_catalog."ar-TN-x-icu" is 'Arabic (Tunisia)';

alter collation pg_catalog."ar-TN-x-icu" owner to postgres;

create collation pg_catalog."ar-YE-x-icu" (
    locale = 'ar-YE'
    );

comment on collation pg_catalog."ar-YE-x-icu" is 'Arabic (Yemen)';

alter collation pg_catalog."ar-YE-x-icu" owner to postgres;

create collation pg_catalog."as-x-icu" (
    locale = 'as'
    );

comment on collation pg_catalog."as-x-icu" is 'Assamese';

alter collation pg_catalog."as-x-icu" owner to postgres;

create collation pg_catalog."as-IN-x-icu" (
    locale = 'as-IN'
    );

comment on collation pg_catalog."as-IN-x-icu" is 'Assamese (India)';

alter collation pg_catalog."as-IN-x-icu" owner to postgres;

create collation pg_catalog."asa-x-icu" (
    locale = 'asa'
    );

comment on collation pg_catalog."asa-x-icu" is 'Asu';

alter collation pg_catalog."asa-x-icu" owner to postgres;

create collation pg_catalog."asa-TZ-x-icu" (
    locale = 'asa-TZ'
    );

comment on collation pg_catalog."asa-TZ-x-icu" is 'Asu (Tanzania)';

alter collation pg_catalog."asa-TZ-x-icu" owner to postgres;

create collation pg_catalog."ast-x-icu" (
    locale = 'ast'
    );

comment on collation pg_catalog."ast-x-icu" is 'Asturian';

alter collation pg_catalog."ast-x-icu" owner to postgres;

create collation pg_catalog."ast-ES-x-icu" (
    locale = 'ast-ES'
    );

comment on collation pg_catalog."ast-ES-x-icu" is 'Asturian (Spain)';

alter collation pg_catalog."ast-ES-x-icu" owner to postgres;

create collation pg_catalog."az-x-icu" (
    locale = 'az'
    );

comment on collation pg_catalog."az-x-icu" is 'Azerbaijani';

alter collation pg_catalog."az-x-icu" owner to postgres;

create collation pg_catalog."az-Cyrl-x-icu" (
    locale = 'az-Cyrl'
    );

comment on collation pg_catalog."az-Cyrl-x-icu" is 'Azerbaijani (Cyrillic)';

alter collation pg_catalog."az-Cyrl-x-icu" owner to postgres;

create collation pg_catalog."az-Cyrl-AZ-x-icu" (
    locale = 'az-Cyrl-AZ'
    );

comment on collation pg_catalog."az-Cyrl-AZ-x-icu" is 'Azerbaijani (Cyrillic, Azerbaijan)';

alter collation pg_catalog."az-Cyrl-AZ-x-icu" owner to postgres;

create collation pg_catalog."az-Latn-x-icu" (
    locale = 'az-Latn'
    );

comment on collation pg_catalog."az-Latn-x-icu" is 'Azerbaijani (Latin)';

alter collation pg_catalog."az-Latn-x-icu" owner to postgres;

create collation pg_catalog."az-Latn-AZ-x-icu" (
    locale = 'az-Latn-AZ'
    );

comment on collation pg_catalog."az-Latn-AZ-x-icu" is 'Azerbaijani (Latin, Azerbaijan)';

alter collation pg_catalog."az-Latn-AZ-x-icu" owner to postgres;

create collation pg_catalog."bas-x-icu" (
    locale = 'bas'
    );

comment on collation pg_catalog."bas-x-icu" is 'Basaa';

alter collation pg_catalog."bas-x-icu" owner to postgres;

create collation pg_catalog."bas-CM-x-icu" (
    locale = 'bas-CM'
    );

comment on collation pg_catalog."bas-CM-x-icu" is 'Basaa (Cameroon)';

alter collation pg_catalog."bas-CM-x-icu" owner to postgres;

create collation pg_catalog."be-x-icu" (
    locale = 'be'
    );

comment on collation pg_catalog."be-x-icu" is 'Belarusian';

alter collation pg_catalog."be-x-icu" owner to postgres;

create collation pg_catalog."be-BY-x-icu" (
    locale = 'be-BY'
    );

comment on collation pg_catalog."be-BY-x-icu" is 'Belarusian (Belarus)';

alter collation pg_catalog."be-BY-x-icu" owner to postgres;

create collation pg_catalog."bem-x-icu" (
    locale = 'bem'
    );

comment on collation pg_catalog."bem-x-icu" is 'Bemba';

alter collation pg_catalog."bem-x-icu" owner to postgres;

create collation pg_catalog."bem-ZM-x-icu" (
    locale = 'bem-ZM'
    );

comment on collation pg_catalog."bem-ZM-x-icu" is 'Bemba (Zambia)';

alter collation pg_catalog."bem-ZM-x-icu" owner to postgres;

create collation pg_catalog."bez-x-icu" (
    locale = 'bez'
    );

comment on collation pg_catalog."bez-x-icu" is 'Bena';

alter collation pg_catalog."bez-x-icu" owner to postgres;

create collation pg_catalog."bez-TZ-x-icu" (
    locale = 'bez-TZ'
    );

comment on collation pg_catalog."bez-TZ-x-icu" is 'Bena (Tanzania)';

alter collation pg_catalog."bez-TZ-x-icu" owner to postgres;

create collation pg_catalog."bg-x-icu" (
    locale = 'bg'
    );

comment on collation pg_catalog."bg-x-icu" is 'Bulgarian';

alter collation pg_catalog."bg-x-icu" owner to postgres;

create collation pg_catalog."bg-BG-x-icu" (
    locale = 'bg-BG'
    );

comment on collation pg_catalog."bg-BG-x-icu" is 'Bulgarian (Bulgaria)';

alter collation pg_catalog."bg-BG-x-icu" owner to postgres;

create collation pg_catalog."bm-x-icu" (
    locale = 'bm'
    );

comment on collation pg_catalog."bm-x-icu" is 'Bambara';

alter collation pg_catalog."bm-x-icu" owner to postgres;

create collation pg_catalog."bm-ML-x-icu" (
    locale = 'bm-ML'
    );

comment on collation pg_catalog."bm-ML-x-icu" is 'Bambara (Mali)';

alter collation pg_catalog."bm-ML-x-icu" owner to postgres;

create collation pg_catalog."bn-x-icu" (
    locale = 'bn'
    );

comment on collation pg_catalog."bn-x-icu" is 'Bangla';

alter collation pg_catalog."bn-x-icu" owner to postgres;

create collation pg_catalog."bn-BD-x-icu" (
    locale = 'bn-BD'
    );

comment on collation pg_catalog."bn-BD-x-icu" is 'Bangla (Bangladesh)';

alter collation pg_catalog."bn-BD-x-icu" owner to postgres;

create collation pg_catalog."bn-IN-x-icu" (
    locale = 'bn-IN'
    );

comment on collation pg_catalog."bn-IN-x-icu" is 'Bangla (India)';

alter collation pg_catalog."bn-IN-x-icu" owner to postgres;

create collation pg_catalog."bo-x-icu" (
    locale = 'bo'
    );

comment on collation pg_catalog."bo-x-icu" is 'Tibetan';

alter collation pg_catalog."bo-x-icu" owner to postgres;

create collation pg_catalog."bo-CN-x-icu" (
    locale = 'bo-CN'
    );

comment on collation pg_catalog."bo-CN-x-icu" is 'Tibetan (China)';

alter collation pg_catalog."bo-CN-x-icu" owner to postgres;

create collation pg_catalog."bo-IN-x-icu" (
    locale = 'bo-IN'
    );

comment on collation pg_catalog."bo-IN-x-icu" is 'Tibetan (India)';

alter collation pg_catalog."bo-IN-x-icu" owner to postgres;

create collation pg_catalog."br-x-icu" (
    locale = 'br'
    );

comment on collation pg_catalog."br-x-icu" is 'Breton';

alter collation pg_catalog."br-x-icu" owner to postgres;

create collation pg_catalog."br-FR-x-icu" (
    locale = 'br-FR'
    );

comment on collation pg_catalog."br-FR-x-icu" is 'Breton (France)';

alter collation pg_catalog."br-FR-x-icu" owner to postgres;

create collation pg_catalog."brx-x-icu" (
    locale = 'brx'
    );

comment on collation pg_catalog."brx-x-icu" is 'Bodo';

alter collation pg_catalog."brx-x-icu" owner to postgres;

create collation pg_catalog."brx-IN-x-icu" (
    locale = 'brx-IN'
    );

comment on collation pg_catalog."brx-IN-x-icu" is 'Bodo (India)';

alter collation pg_catalog."brx-IN-x-icu" owner to postgres;

create collation pg_catalog."bs-x-icu" (
    locale = 'bs'
    );

comment on collation pg_catalog."bs-x-icu" is 'Bosnian';

alter collation pg_catalog."bs-x-icu" owner to postgres;

create collation pg_catalog."bs-Cyrl-x-icu" (
    locale = 'bs-Cyrl'
    );

comment on collation pg_catalog."bs-Cyrl-x-icu" is 'Bosnian (Cyrillic)';

alter collation pg_catalog."bs-Cyrl-x-icu" owner to postgres;

create collation pg_catalog."bs-Cyrl-BA-x-icu" (
    locale = 'bs-Cyrl-BA'
    );

comment on collation pg_catalog."bs-Cyrl-BA-x-icu" is 'Bosnian (Cyrillic, Bosnia & Herzegovina)';

alter collation pg_catalog."bs-Cyrl-BA-x-icu" owner to postgres;

create collation pg_catalog."bs-Latn-x-icu" (
    locale = 'bs-Latn'
    );

comment on collation pg_catalog."bs-Latn-x-icu" is 'Bosnian (Latin)';

alter collation pg_catalog."bs-Latn-x-icu" owner to postgres;

create collation pg_catalog."bs-Latn-BA-x-icu" (
    locale = 'bs-Latn-BA'
    );

comment on collation pg_catalog."bs-Latn-BA-x-icu" is 'Bosnian (Latin, Bosnia & Herzegovina)';

alter collation pg_catalog."bs-Latn-BA-x-icu" owner to postgres;

create collation pg_catalog."ca-x-icu" (
    locale = 'ca'
    );

comment on collation pg_catalog."ca-x-icu" is 'Catalan';

alter collation pg_catalog."ca-x-icu" owner to postgres;

create collation pg_catalog."ca-AD-x-icu" (
    locale = 'ca-AD'
    );

comment on collation pg_catalog."ca-AD-x-icu" is 'Catalan (Andorra)';

alter collation pg_catalog."ca-AD-x-icu" owner to postgres;

create collation pg_catalog."ca-ES-x-icu" (
    locale = 'ca-ES'
    );

comment on collation pg_catalog."ca-ES-x-icu" is 'Catalan (Spain)';

alter collation pg_catalog."ca-ES-x-icu" owner to postgres;

create collation pg_catalog."ca-FR-x-icu" (
    locale = 'ca-FR'
    );

comment on collation pg_catalog."ca-FR-x-icu" is 'Catalan (France)';

alter collation pg_catalog."ca-FR-x-icu" owner to postgres;

create collation pg_catalog."ca-IT-x-icu" (
    locale = 'ca-IT'
    );

comment on collation pg_catalog."ca-IT-x-icu" is 'Catalan (Italy)';

alter collation pg_catalog."ca-IT-x-icu" owner to postgres;

create collation pg_catalog."ccp-x-icu" (
    locale = 'ccp'
    );

comment on collation pg_catalog."ccp-x-icu" is 'Chakma';

alter collation pg_catalog."ccp-x-icu" owner to postgres;

create collation pg_catalog."ccp-BD-x-icu" (
    locale = 'ccp-BD'
    );

comment on collation pg_catalog."ccp-BD-x-icu" is 'Chakma (Bangladesh)';

alter collation pg_catalog."ccp-BD-x-icu" owner to postgres;

create collation pg_catalog."ccp-IN-x-icu" (
    locale = 'ccp-IN'
    );

comment on collation pg_catalog."ccp-IN-x-icu" is 'Chakma (India)';

alter collation pg_catalog."ccp-IN-x-icu" owner to postgres;

create collation pg_catalog."ce-x-icu" (
    locale = 'ce'
    );

comment on collation pg_catalog."ce-x-icu" is 'Chechen';

alter collation pg_catalog."ce-x-icu" owner to postgres;

create collation pg_catalog."ce-RU-x-icu" (
    locale = 'ce-RU'
    );

comment on collation pg_catalog."ce-RU-x-icu" is 'Chechen (Russia)';

alter collation pg_catalog."ce-RU-x-icu" owner to postgres;

create collation pg_catalog."ceb-x-icu" (
    locale = 'ceb'
    );

comment on collation pg_catalog."ceb-x-icu" is 'Cebuano';

alter collation pg_catalog."ceb-x-icu" owner to postgres;

create collation pg_catalog."ceb-PH-x-icu" (
    locale = 'ceb-PH'
    );

comment on collation pg_catalog."ceb-PH-x-icu" is 'Cebuano (Philippines)';

alter collation pg_catalog."ceb-PH-x-icu" owner to postgres;

create collation pg_catalog."cgg-x-icu" (
    locale = 'cgg'
    );

comment on collation pg_catalog."cgg-x-icu" is 'Chiga';

alter collation pg_catalog."cgg-x-icu" owner to postgres;

create collation pg_catalog."cgg-UG-x-icu" (
    locale = 'cgg-UG'
    );

comment on collation pg_catalog."cgg-UG-x-icu" is 'Chiga (Uganda)';

alter collation pg_catalog."cgg-UG-x-icu" owner to postgres;

create collation pg_catalog."chr-x-icu" (
    locale = 'chr'
    );

comment on collation pg_catalog."chr-x-icu" is 'Cherokee';

alter collation pg_catalog."chr-x-icu" owner to postgres;

create collation pg_catalog."chr-US-x-icu" (
    locale = 'chr-US'
    );

comment on collation pg_catalog."chr-US-x-icu" is 'Cherokee (United States)';

alter collation pg_catalog."chr-US-x-icu" owner to postgres;

create collation pg_catalog."ckb-x-icu" (
    locale = 'ckb'
    );

comment on collation pg_catalog."ckb-x-icu" is 'Central Kurdish';

alter collation pg_catalog."ckb-x-icu" owner to postgres;

create collation pg_catalog."ckb-IQ-x-icu" (
    locale = 'ckb-IQ'
    );

comment on collation pg_catalog."ckb-IQ-x-icu" is 'Central Kurdish (Iraq)';

alter collation pg_catalog."ckb-IQ-x-icu" owner to postgres;

create collation pg_catalog."ckb-IR-x-icu" (
    locale = 'ckb-IR'
    );

comment on collation pg_catalog."ckb-IR-x-icu" is 'Central Kurdish (Iran)';

alter collation pg_catalog."ckb-IR-x-icu" owner to postgres;

create collation pg_catalog."cs-x-icu" (
    locale = 'cs'
    );

comment on collation pg_catalog."cs-x-icu" is 'Czech';

alter collation pg_catalog."cs-x-icu" owner to postgres;

create collation pg_catalog."cs-CZ-x-icu" (
    locale = 'cs-CZ'
    );

comment on collation pg_catalog."cs-CZ-x-icu" is 'Czech (Czechia)';

alter collation pg_catalog."cs-CZ-x-icu" owner to postgres;

create collation pg_catalog."cy-x-icu" (
    locale = 'cy'
    );

comment on collation pg_catalog."cy-x-icu" is 'Welsh';

alter collation pg_catalog."cy-x-icu" owner to postgres;

create collation pg_catalog."cy-GB-x-icu" (
    locale = 'cy-GB'
    );

comment on collation pg_catalog."cy-GB-x-icu" is 'Welsh (United Kingdom)';

alter collation pg_catalog."cy-GB-x-icu" owner to postgres;

create collation pg_catalog."da-x-icu" (
    locale = 'da'
    );

comment on collation pg_catalog."da-x-icu" is 'Danish';

alter collation pg_catalog."da-x-icu" owner to postgres;

create collation pg_catalog."da-DK-x-icu" (
    locale = 'da-DK'
    );

comment on collation pg_catalog."da-DK-x-icu" is 'Danish (Denmark)';

alter collation pg_catalog."da-DK-x-icu" owner to postgres;

create collation pg_catalog."da-GL-x-icu" (
    locale = 'da-GL'
    );

comment on collation pg_catalog."da-GL-x-icu" is 'Danish (Greenland)';

alter collation pg_catalog."da-GL-x-icu" owner to postgres;

create collation pg_catalog."dav-x-icu" (
    locale = 'dav'
    );

comment on collation pg_catalog."dav-x-icu" is 'Taita';

alter collation pg_catalog."dav-x-icu" owner to postgres;

create collation pg_catalog."dav-KE-x-icu" (
    locale = 'dav-KE'
    );

comment on collation pg_catalog."dav-KE-x-icu" is 'Taita (Kenya)';

alter collation pg_catalog."dav-KE-x-icu" owner to postgres;

create collation pg_catalog."de-x-icu" (
    locale = 'de'
    );

comment on collation pg_catalog."de-x-icu" is 'German';

alter collation pg_catalog."de-x-icu" owner to postgres;

create collation pg_catalog."de-AT-x-icu" (
    locale = 'de-AT'
    );

comment on collation pg_catalog."de-AT-x-icu" is 'German (Austria)';

alter collation pg_catalog."de-AT-x-icu" owner to postgres;

create collation pg_catalog."de-BE-x-icu" (
    locale = 'de-BE'
    );

comment on collation pg_catalog."de-BE-x-icu" is 'German (Belgium)';

alter collation pg_catalog."de-BE-x-icu" owner to postgres;

create collation pg_catalog."de-CH-x-icu" (
    locale = 'de-CH'
    );

comment on collation pg_catalog."de-CH-x-icu" is 'German (Switzerland)';

alter collation pg_catalog."de-CH-x-icu" owner to postgres;

create collation pg_catalog."de-DE-x-icu" (
    locale = 'de-DE'
    );

comment on collation pg_catalog."de-DE-x-icu" is 'German (Germany)';

alter collation pg_catalog."de-DE-x-icu" owner to postgres;

create collation pg_catalog."de-IT-x-icu" (
    locale = 'de-IT'
    );

comment on collation pg_catalog."de-IT-x-icu" is 'German (Italy)';

alter collation pg_catalog."de-IT-x-icu" owner to postgres;

create collation pg_catalog."de-LI-x-icu" (
    locale = 'de-LI'
    );

comment on collation pg_catalog."de-LI-x-icu" is 'German (Liechtenstein)';

alter collation pg_catalog."de-LI-x-icu" owner to postgres;

create collation pg_catalog."de-LU-x-icu" (
    locale = 'de-LU'
    );

comment on collation pg_catalog."de-LU-x-icu" is 'German (Luxembourg)';

alter collation pg_catalog."de-LU-x-icu" owner to postgres;

create collation pg_catalog."dje-x-icu" (
    locale = 'dje'
    );

comment on collation pg_catalog."dje-x-icu" is 'Zarma';

alter collation pg_catalog."dje-x-icu" owner to postgres;

create collation pg_catalog."dje-NE-x-icu" (
    locale = 'dje-NE'
    );

comment on collation pg_catalog."dje-NE-x-icu" is 'Zarma (Niger)';

alter collation pg_catalog."dje-NE-x-icu" owner to postgres;

create collation pg_catalog."dsb-x-icu" (
    locale = 'dsb'
    );

comment on collation pg_catalog."dsb-x-icu" is 'Lower Sorbian';

alter collation pg_catalog."dsb-x-icu" owner to postgres;

create collation pg_catalog."dsb-DE-x-icu" (
    locale = 'dsb-DE'
    );

comment on collation pg_catalog."dsb-DE-x-icu" is 'Lower Sorbian (Germany)';

alter collation pg_catalog."dsb-DE-x-icu" owner to postgres;

create collation pg_catalog."dua-x-icu" (
    locale = 'dua'
    );

comment on collation pg_catalog."dua-x-icu" is 'Duala';

alter collation pg_catalog."dua-x-icu" owner to postgres;

create collation pg_catalog."dua-CM-x-icu" (
    locale = 'dua-CM'
    );

comment on collation pg_catalog."dua-CM-x-icu" is 'Duala (Cameroon)';

alter collation pg_catalog."dua-CM-x-icu" owner to postgres;

create collation pg_catalog."dyo-x-icu" (
    locale = 'dyo'
    );

comment on collation pg_catalog."dyo-x-icu" is 'Jola-Fonyi';

alter collation pg_catalog."dyo-x-icu" owner to postgres;

create collation pg_catalog."dyo-SN-x-icu" (
    locale = 'dyo-SN'
    );

comment on collation pg_catalog."dyo-SN-x-icu" is 'Jola-Fonyi (Senegal)';

alter collation pg_catalog."dyo-SN-x-icu" owner to postgres;

create collation pg_catalog."dz-x-icu" (
    locale = 'dz'
    );

comment on collation pg_catalog."dz-x-icu" is 'Dzongkha';

alter collation pg_catalog."dz-x-icu" owner to postgres;

create collation pg_catalog."dz-BT-x-icu" (
    locale = 'dz-BT'
    );

comment on collation pg_catalog."dz-BT-x-icu" is 'Dzongkha (Bhutan)';

alter collation pg_catalog."dz-BT-x-icu" owner to postgres;

create collation pg_catalog."ebu-x-icu" (
    locale = 'ebu'
    );

comment on collation pg_catalog."ebu-x-icu" is 'Embu';

alter collation pg_catalog."ebu-x-icu" owner to postgres;

create collation pg_catalog."ebu-KE-x-icu" (
    locale = 'ebu-KE'
    );

comment on collation pg_catalog."ebu-KE-x-icu" is 'Embu (Kenya)';

alter collation pg_catalog."ebu-KE-x-icu" owner to postgres;

create collation pg_catalog."ee-x-icu" (
    locale = 'ee'
    );

comment on collation pg_catalog."ee-x-icu" is 'Ewe';

alter collation pg_catalog."ee-x-icu" owner to postgres;

create collation pg_catalog."ee-GH-x-icu" (
    locale = 'ee-GH'
    );

comment on collation pg_catalog."ee-GH-x-icu" is 'Ewe (Ghana)';

alter collation pg_catalog."ee-GH-x-icu" owner to postgres;

create collation pg_catalog."ee-TG-x-icu" (
    locale = 'ee-TG'
    );

comment on collation pg_catalog."ee-TG-x-icu" is 'Ewe (Togo)';

alter collation pg_catalog."ee-TG-x-icu" owner to postgres;

create collation pg_catalog."el-x-icu" (
    locale = 'el'
    );

comment on collation pg_catalog."el-x-icu" is 'Greek';

alter collation pg_catalog."el-x-icu" owner to postgres;

create collation pg_catalog."el-CY-x-icu" (
    locale = 'el-CY'
    );

comment on collation pg_catalog."el-CY-x-icu" is 'Greek (Cyprus)';

alter collation pg_catalog."el-CY-x-icu" owner to postgres;

create collation pg_catalog."el-GR-x-icu" (
    locale = 'el-GR'
    );

comment on collation pg_catalog."el-GR-x-icu" is 'Greek (Greece)';

alter collation pg_catalog."el-GR-x-icu" owner to postgres;

create collation pg_catalog."en-x-icu" (
    locale = 'en'
    );

comment on collation pg_catalog."en-x-icu" is 'English';

alter collation pg_catalog."en-x-icu" owner to postgres;

create collation pg_catalog."en-001-x-icu" (
    locale = 'en-001'
    );

comment on collation pg_catalog."en-001-x-icu" is 'English (World)';

alter collation pg_catalog."en-001-x-icu" owner to postgres;

create collation pg_catalog."en-150-x-icu" (
    locale = 'en-150'
    );

comment on collation pg_catalog."en-150-x-icu" is 'English (Europe)';

alter collation pg_catalog."en-150-x-icu" owner to postgres;

create collation pg_catalog."en-AE-x-icu" (
    locale = 'en-AE'
    );

comment on collation pg_catalog."en-AE-x-icu" is 'English (United Arab Emirates)';

alter collation pg_catalog."en-AE-x-icu" owner to postgres;

create collation pg_catalog."en-AG-x-icu" (
    locale = 'en-AG'
    );

comment on collation pg_catalog."en-AG-x-icu" is 'English (Antigua & Barbuda)';

alter collation pg_catalog."en-AG-x-icu" owner to postgres;

create collation pg_catalog."en-AI-x-icu" (
    locale = 'en-AI'
    );

comment on collation pg_catalog."en-AI-x-icu" is 'English (Anguilla)';

alter collation pg_catalog."en-AI-x-icu" owner to postgres;

create collation pg_catalog."en-AS-x-icu" (
    locale = 'en-AS'
    );

comment on collation pg_catalog."en-AS-x-icu" is 'English (American Samoa)';

alter collation pg_catalog."en-AS-x-icu" owner to postgres;

create collation pg_catalog."en-AT-x-icu" (
    locale = 'en-AT'
    );

comment on collation pg_catalog."en-AT-x-icu" is 'English (Austria)';

alter collation pg_catalog."en-AT-x-icu" owner to postgres;

create collation pg_catalog."en-AU-x-icu" (
    locale = 'en-AU'
    );

comment on collation pg_catalog."en-AU-x-icu" is 'English (Australia)';

alter collation pg_catalog."en-AU-x-icu" owner to postgres;

create collation pg_catalog."en-BB-x-icu" (
    locale = 'en-BB'
    );

comment on collation pg_catalog."en-BB-x-icu" is 'English (Barbados)';

alter collation pg_catalog."en-BB-x-icu" owner to postgres;

create collation pg_catalog."en-BE-x-icu" (
    locale = 'en-BE'
    );

comment on collation pg_catalog."en-BE-x-icu" is 'English (Belgium)';

alter collation pg_catalog."en-BE-x-icu" owner to postgres;

create collation pg_catalog."en-BI-x-icu" (
    locale = 'en-BI'
    );

comment on collation pg_catalog."en-BI-x-icu" is 'English (Burundi)';

alter collation pg_catalog."en-BI-x-icu" owner to postgres;

create collation pg_catalog."en-BM-x-icu" (
    locale = 'en-BM'
    );

comment on collation pg_catalog."en-BM-x-icu" is 'English (Bermuda)';

alter collation pg_catalog."en-BM-x-icu" owner to postgres;

create collation pg_catalog."en-BS-x-icu" (
    locale = 'en-BS'
    );

comment on collation pg_catalog."en-BS-x-icu" is 'English (Bahamas)';

alter collation pg_catalog."en-BS-x-icu" owner to postgres;

create collation pg_catalog."en-BW-x-icu" (
    locale = 'en-BW'
    );

comment on collation pg_catalog."en-BW-x-icu" is 'English (Botswana)';

alter collation pg_catalog."en-BW-x-icu" owner to postgres;

create collation pg_catalog."en-BZ-x-icu" (
    locale = 'en-BZ'
    );

comment on collation pg_catalog."en-BZ-x-icu" is 'English (Belize)';

alter collation pg_catalog."en-BZ-x-icu" owner to postgres;

create collation pg_catalog."en-CA-x-icu" (
    locale = 'en-CA'
    );

comment on collation pg_catalog."en-CA-x-icu" is 'English (Canada)';

alter collation pg_catalog."en-CA-x-icu" owner to postgres;

create collation pg_catalog."en-CC-x-icu" (
    locale = 'en-CC'
    );

comment on collation pg_catalog."en-CC-x-icu" is 'English (Cocos [Keeling] Islands)';

alter collation pg_catalog."en-CC-x-icu" owner to postgres;

create collation pg_catalog."en-CH-x-icu" (
    locale = 'en-CH'
    );

comment on collation pg_catalog."en-CH-x-icu" is 'English (Switzerland)';

alter collation pg_catalog."en-CH-x-icu" owner to postgres;

create collation pg_catalog."en-CK-x-icu" (
    locale = 'en-CK'
    );

comment on collation pg_catalog."en-CK-x-icu" is 'English (Cook Islands)';

alter collation pg_catalog."en-CK-x-icu" owner to postgres;

create collation pg_catalog."en-CM-x-icu" (
    locale = 'en-CM'
    );

comment on collation pg_catalog."en-CM-x-icu" is 'English (Cameroon)';

alter collation pg_catalog."en-CM-x-icu" owner to postgres;

create collation pg_catalog."en-CX-x-icu" (
    locale = 'en-CX'
    );

comment on collation pg_catalog."en-CX-x-icu" is 'English (Christmas Island)';

alter collation pg_catalog."en-CX-x-icu" owner to postgres;

create collation pg_catalog."en-CY-x-icu" (
    locale = 'en-CY'
    );

comment on collation pg_catalog."en-CY-x-icu" is 'English (Cyprus)';

alter collation pg_catalog."en-CY-x-icu" owner to postgres;

create collation pg_catalog."en-DE-x-icu" (
    locale = 'en-DE'
    );

comment on collation pg_catalog."en-DE-x-icu" is 'English (Germany)';

alter collation pg_catalog."en-DE-x-icu" owner to postgres;

create collation pg_catalog."en-DG-x-icu" (
    locale = 'en-DG'
    );

comment on collation pg_catalog."en-DG-x-icu" is 'English (Diego Garcia)';

alter collation pg_catalog."en-DG-x-icu" owner to postgres;

create collation pg_catalog."en-DK-x-icu" (
    locale = 'en-DK'
    );

comment on collation pg_catalog."en-DK-x-icu" is 'English (Denmark)';

alter collation pg_catalog."en-DK-x-icu" owner to postgres;

create collation pg_catalog."en-DM-x-icu" (
    locale = 'en-DM'
    );

comment on collation pg_catalog."en-DM-x-icu" is 'English (Dominica)';

alter collation pg_catalog."en-DM-x-icu" owner to postgres;

create collation pg_catalog."en-ER-x-icu" (
    locale = 'en-ER'
    );

comment on collation pg_catalog."en-ER-x-icu" is 'English (Eritrea)';

alter collation pg_catalog."en-ER-x-icu" owner to postgres;

create collation pg_catalog."en-FI-x-icu" (
    locale = 'en-FI'
    );

comment on collation pg_catalog."en-FI-x-icu" is 'English (Finland)';

alter collation pg_catalog."en-FI-x-icu" owner to postgres;

create collation pg_catalog."en-FJ-x-icu" (
    locale = 'en-FJ'
    );

comment on collation pg_catalog."en-FJ-x-icu" is 'English (Fiji)';

alter collation pg_catalog."en-FJ-x-icu" owner to postgres;

create collation pg_catalog."en-FK-x-icu" (
    locale = 'en-FK'
    );

comment on collation pg_catalog."en-FK-x-icu" is 'English (Falkland Islands)';

alter collation pg_catalog."en-FK-x-icu" owner to postgres;

create collation pg_catalog."en-FM-x-icu" (
    locale = 'en-FM'
    );

comment on collation pg_catalog."en-FM-x-icu" is 'English (Micronesia)';

alter collation pg_catalog."en-FM-x-icu" owner to postgres;

create collation pg_catalog."en-GB-x-icu" (
    locale = 'en-GB'
    );

comment on collation pg_catalog."en-GB-x-icu" is 'English (United Kingdom)';

alter collation pg_catalog."en-GB-x-icu" owner to postgres;

create collation pg_catalog."en-GD-x-icu" (
    locale = 'en-GD'
    );

comment on collation pg_catalog."en-GD-x-icu" is 'English (Grenada)';

alter collation pg_catalog."en-GD-x-icu" owner to postgres;

create collation pg_catalog."en-GG-x-icu" (
    locale = 'en-GG'
    );

comment on collation pg_catalog."en-GG-x-icu" is 'English (Guernsey)';

alter collation pg_catalog."en-GG-x-icu" owner to postgres;

create collation pg_catalog."en-GH-x-icu" (
    locale = 'en-GH'
    );

comment on collation pg_catalog."en-GH-x-icu" is 'English (Ghana)';

alter collation pg_catalog."en-GH-x-icu" owner to postgres;

create collation pg_catalog."en-GI-x-icu" (
    locale = 'en-GI'
    );

comment on collation pg_catalog."en-GI-x-icu" is 'English (Gibraltar)';

alter collation pg_catalog."en-GI-x-icu" owner to postgres;

create collation pg_catalog."en-GM-x-icu" (
    locale = 'en-GM'
    );

comment on collation pg_catalog."en-GM-x-icu" is 'English (Gambia)';

alter collation pg_catalog."en-GM-x-icu" owner to postgres;

create collation pg_catalog."en-GU-x-icu" (
    locale = 'en-GU'
    );

comment on collation pg_catalog."en-GU-x-icu" is 'English (Guam)';

alter collation pg_catalog."en-GU-x-icu" owner to postgres;

create collation pg_catalog."en-GY-x-icu" (
    locale = 'en-GY'
    );

comment on collation pg_catalog."en-GY-x-icu" is 'English (Guyana)';

alter collation pg_catalog."en-GY-x-icu" owner to postgres;

create collation pg_catalog."en-HK-x-icu" (
    locale = 'en-HK'
    );

comment on collation pg_catalog."en-HK-x-icu" is 'English (Hong Kong SAR China)';

alter collation pg_catalog."en-HK-x-icu" owner to postgres;

create collation pg_catalog."en-IE-x-icu" (
    locale = 'en-IE'
    );

comment on collation pg_catalog."en-IE-x-icu" is 'English (Ireland)';

alter collation pg_catalog."en-IE-x-icu" owner to postgres;

create collation pg_catalog."en-IL-x-icu" (
    locale = 'en-IL'
    );

comment on collation pg_catalog."en-IL-x-icu" is 'English (Israel)';

alter collation pg_catalog."en-IL-x-icu" owner to postgres;

create collation pg_catalog."en-IM-x-icu" (
    locale = 'en-IM'
    );

comment on collation pg_catalog."en-IM-x-icu" is 'English (Isle of Man)';

alter collation pg_catalog."en-IM-x-icu" owner to postgres;

create collation pg_catalog."en-IN-x-icu" (
    locale = 'en-IN'
    );

comment on collation pg_catalog."en-IN-x-icu" is 'English (India)';

alter collation pg_catalog."en-IN-x-icu" owner to postgres;

create collation pg_catalog."en-IO-x-icu" (
    locale = 'en-IO'
    );

comment on collation pg_catalog."en-IO-x-icu" is 'English (British Indian Ocean Territory)';

alter collation pg_catalog."en-IO-x-icu" owner to postgres;

create collation pg_catalog."en-JE-x-icu" (
    locale = 'en-JE'
    );

comment on collation pg_catalog."en-JE-x-icu" is 'English (Jersey)';

alter collation pg_catalog."en-JE-x-icu" owner to postgres;

create collation pg_catalog."en-JM-x-icu" (
    locale = 'en-JM'
    );

comment on collation pg_catalog."en-JM-x-icu" is 'English (Jamaica)';

alter collation pg_catalog."en-JM-x-icu" owner to postgres;

create collation pg_catalog."en-KE-x-icu" (
    locale = 'en-KE'
    );

comment on collation pg_catalog."en-KE-x-icu" is 'English (Kenya)';

alter collation pg_catalog."en-KE-x-icu" owner to postgres;

create collation pg_catalog."en-KI-x-icu" (
    locale = 'en-KI'
    );

comment on collation pg_catalog."en-KI-x-icu" is 'English (Kiribati)';

alter collation pg_catalog."en-KI-x-icu" owner to postgres;

create collation pg_catalog."en-KN-x-icu" (
    locale = 'en-KN'
    );

comment on collation pg_catalog."en-KN-x-icu" is 'English (St. Kitts & Nevis)';

alter collation pg_catalog."en-KN-x-icu" owner to postgres;

create collation pg_catalog."en-KY-x-icu" (
    locale = 'en-KY'
    );

comment on collation pg_catalog."en-KY-x-icu" is 'English (Cayman Islands)';

alter collation pg_catalog."en-KY-x-icu" owner to postgres;

create collation pg_catalog."en-LC-x-icu" (
    locale = 'en-LC'
    );

comment on collation pg_catalog."en-LC-x-icu" is 'English (St. Lucia)';

alter collation pg_catalog."en-LC-x-icu" owner to postgres;

create collation pg_catalog."en-LR-x-icu" (
    locale = 'en-LR'
    );

comment on collation pg_catalog."en-LR-x-icu" is 'English (Liberia)';

alter collation pg_catalog."en-LR-x-icu" owner to postgres;

create collation pg_catalog."en-LS-x-icu" (
    locale = 'en-LS'
    );

comment on collation pg_catalog."en-LS-x-icu" is 'English (Lesotho)';

alter collation pg_catalog."en-LS-x-icu" owner to postgres;

create collation pg_catalog."en-MG-x-icu" (
    locale = 'en-MG'
    );

comment on collation pg_catalog."en-MG-x-icu" is 'English (Madagascar)';

alter collation pg_catalog."en-MG-x-icu" owner to postgres;

create collation pg_catalog."en-MH-x-icu" (
    locale = 'en-MH'
    );

comment on collation pg_catalog."en-MH-x-icu" is 'English (Marshall Islands)';

alter collation pg_catalog."en-MH-x-icu" owner to postgres;

create collation pg_catalog."en-MO-x-icu" (
    locale = 'en-MO'
    );

comment on collation pg_catalog."en-MO-x-icu" is 'English (Macao SAR China)';

alter collation pg_catalog."en-MO-x-icu" owner to postgres;

create collation pg_catalog."en-MP-x-icu" (
    locale = 'en-MP'
    );

comment on collation pg_catalog."en-MP-x-icu" is 'English (Northern Mariana Islands)';

alter collation pg_catalog."en-MP-x-icu" owner to postgres;

create collation pg_catalog."en-MS-x-icu" (
    locale = 'en-MS'
    );

comment on collation pg_catalog."en-MS-x-icu" is 'English (Montserrat)';

alter collation pg_catalog."en-MS-x-icu" owner to postgres;

create collation pg_catalog."en-MT-x-icu" (
    locale = 'en-MT'
    );

comment on collation pg_catalog."en-MT-x-icu" is 'English (Malta)';

alter collation pg_catalog."en-MT-x-icu" owner to postgres;

create collation pg_catalog."en-MU-x-icu" (
    locale = 'en-MU'
    );

comment on collation pg_catalog."en-MU-x-icu" is 'English (Mauritius)';

alter collation pg_catalog."en-MU-x-icu" owner to postgres;

create collation pg_catalog."en-MW-x-icu" (
    locale = 'en-MW'
    );

comment on collation pg_catalog."en-MW-x-icu" is 'English (Malawi)';

alter collation pg_catalog."en-MW-x-icu" owner to postgres;

create collation pg_catalog."en-MY-x-icu" (
    locale = 'en-MY'
    );

comment on collation pg_catalog."en-MY-x-icu" is 'English (Malaysia)';

alter collation pg_catalog."en-MY-x-icu" owner to postgres;

create collation pg_catalog."en-NA-x-icu" (
    locale = 'en-NA'
    );

comment on collation pg_catalog."en-NA-x-icu" is 'English (Namibia)';

alter collation pg_catalog."en-NA-x-icu" owner to postgres;

create collation pg_catalog."en-NF-x-icu" (
    locale = 'en-NF'
    );

comment on collation pg_catalog."en-NF-x-icu" is 'English (Norfolk Island)';

alter collation pg_catalog."en-NF-x-icu" owner to postgres;

create collation pg_catalog."en-NG-x-icu" (
    locale = 'en-NG'
    );

comment on collation pg_catalog."en-NG-x-icu" is 'English (Nigeria)';

alter collation pg_catalog."en-NG-x-icu" owner to postgres;

create collation pg_catalog."en-NL-x-icu" (
    locale = 'en-NL'
    );

comment on collation pg_catalog."en-NL-x-icu" is 'English (Netherlands)';

alter collation pg_catalog."en-NL-x-icu" owner to postgres;

create collation pg_catalog."en-NR-x-icu" (
    locale = 'en-NR'
    );

comment on collation pg_catalog."en-NR-x-icu" is 'English (Nauru)';

alter collation pg_catalog."en-NR-x-icu" owner to postgres;

create collation pg_catalog."en-NU-x-icu" (
    locale = 'en-NU'
    );

comment on collation pg_catalog."en-NU-x-icu" is 'English (Niue)';

alter collation pg_catalog."en-NU-x-icu" owner to postgres;

create collation pg_catalog."en-NZ-x-icu" (
    locale = 'en-NZ'
    );

comment on collation pg_catalog."en-NZ-x-icu" is 'English (New Zealand)';

alter collation pg_catalog."en-NZ-x-icu" owner to postgres;

create collation pg_catalog."en-PG-x-icu" (
    locale = 'en-PG'
    );

comment on collation pg_catalog."en-PG-x-icu" is 'English (Papua New Guinea)';

alter collation pg_catalog."en-PG-x-icu" owner to postgres;

create collation pg_catalog."en-PH-x-icu" (
    locale = 'en-PH'
    );

comment on collation pg_catalog."en-PH-x-icu" is 'English (Philippines)';

alter collation pg_catalog."en-PH-x-icu" owner to postgres;

create collation pg_catalog."en-PK-x-icu" (
    locale = 'en-PK'
    );

comment on collation pg_catalog."en-PK-x-icu" is 'English (Pakistan)';

alter collation pg_catalog."en-PK-x-icu" owner to postgres;

create collation pg_catalog."en-PN-x-icu" (
    locale = 'en-PN'
    );

comment on collation pg_catalog."en-PN-x-icu" is 'English (Pitcairn Islands)';

alter collation pg_catalog."en-PN-x-icu" owner to postgres;

create collation pg_catalog."en-PR-x-icu" (
    locale = 'en-PR'
    );

comment on collation pg_catalog."en-PR-x-icu" is 'English (Puerto Rico)';

alter collation pg_catalog."en-PR-x-icu" owner to postgres;

create collation pg_catalog."en-PW-x-icu" (
    locale = 'en-PW'
    );

comment on collation pg_catalog."en-PW-x-icu" is 'English (Palau)';

alter collation pg_catalog."en-PW-x-icu" owner to postgres;

create collation pg_catalog."en-RW-x-icu" (
    locale = 'en-RW'
    );

comment on collation pg_catalog."en-RW-x-icu" is 'English (Rwanda)';

alter collation pg_catalog."en-RW-x-icu" owner to postgres;

create collation pg_catalog."en-SB-x-icu" (
    locale = 'en-SB'
    );

comment on collation pg_catalog."en-SB-x-icu" is 'English (Solomon Islands)';

alter collation pg_catalog."en-SB-x-icu" owner to postgres;

create collation pg_catalog."en-SC-x-icu" (
    locale = 'en-SC'
    );

comment on collation pg_catalog."en-SC-x-icu" is 'English (Seychelles)';

alter collation pg_catalog."en-SC-x-icu" owner to postgres;

create collation pg_catalog."en-SD-x-icu" (
    locale = 'en-SD'
    );

comment on collation pg_catalog."en-SD-x-icu" is 'English (Sudan)';

alter collation pg_catalog."en-SD-x-icu" owner to postgres;

create collation pg_catalog."en-SE-x-icu" (
    locale = 'en-SE'
    );

comment on collation pg_catalog."en-SE-x-icu" is 'English (Sweden)';

alter collation pg_catalog."en-SE-x-icu" owner to postgres;

create collation pg_catalog."en-SG-x-icu" (
    locale = 'en-SG'
    );

comment on collation pg_catalog."en-SG-x-icu" is 'English (Singapore)';

alter collation pg_catalog."en-SG-x-icu" owner to postgres;

create collation pg_catalog."en-SH-x-icu" (
    locale = 'en-SH'
    );

comment on collation pg_catalog."en-SH-x-icu" is 'English (St. Helena)';

alter collation pg_catalog."en-SH-x-icu" owner to postgres;

create collation pg_catalog."en-SI-x-icu" (
    locale = 'en-SI'
    );

comment on collation pg_catalog."en-SI-x-icu" is 'English (Slovenia)';

alter collation pg_catalog."en-SI-x-icu" owner to postgres;

create collation pg_catalog."en-SL-x-icu" (
    locale = 'en-SL'
    );

comment on collation pg_catalog."en-SL-x-icu" is 'English (Sierra Leone)';

alter collation pg_catalog."en-SL-x-icu" owner to postgres;

create collation pg_catalog."en-SS-x-icu" (
    locale = 'en-SS'
    );

comment on collation pg_catalog."en-SS-x-icu" is 'English (South Sudan)';

alter collation pg_catalog."en-SS-x-icu" owner to postgres;

create collation pg_catalog."en-SX-x-icu" (
    locale = 'en-SX'
    );

comment on collation pg_catalog."en-SX-x-icu" is 'English (Sint Maarten)';

alter collation pg_catalog."en-SX-x-icu" owner to postgres;

create collation pg_catalog."en-SZ-x-icu" (
    locale = 'en-SZ'
    );

comment on collation pg_catalog."en-SZ-x-icu" is 'English (Eswatini)';

alter collation pg_catalog."en-SZ-x-icu" owner to postgres;

create collation pg_catalog."en-TC-x-icu" (
    locale = 'en-TC'
    );

comment on collation pg_catalog."en-TC-x-icu" is 'English (Turks & Caicos Islands)';

alter collation pg_catalog."en-TC-x-icu" owner to postgres;

create collation pg_catalog."en-TK-x-icu" (
    locale = 'en-TK'
    );

comment on collation pg_catalog."en-TK-x-icu" is 'English (Tokelau)';

alter collation pg_catalog."en-TK-x-icu" owner to postgres;

create collation pg_catalog."en-TO-x-icu" (
    locale = 'en-TO'
    );

comment on collation pg_catalog."en-TO-x-icu" is 'English (Tonga)';

alter collation pg_catalog."en-TO-x-icu" owner to postgres;

create collation pg_catalog."en-TT-x-icu" (
    locale = 'en-TT'
    );

comment on collation pg_catalog."en-TT-x-icu" is 'English (Trinidad & Tobago)';

alter collation pg_catalog."en-TT-x-icu" owner to postgres;

create collation pg_catalog."en-TV-x-icu" (
    locale = 'en-TV'
    );

comment on collation pg_catalog."en-TV-x-icu" is 'English (Tuvalu)';

alter collation pg_catalog."en-TV-x-icu" owner to postgres;

create collation pg_catalog."en-TZ-x-icu" (
    locale = 'en-TZ'
    );

comment on collation pg_catalog."en-TZ-x-icu" is 'English (Tanzania)';

alter collation pg_catalog."en-TZ-x-icu" owner to postgres;

create collation pg_catalog."en-UG-x-icu" (
    locale = 'en-UG'
    );

comment on collation pg_catalog."en-UG-x-icu" is 'English (Uganda)';

alter collation pg_catalog."en-UG-x-icu" owner to postgres;

create collation pg_catalog."en-UM-x-icu" (
    locale = 'en-UM'
    );

comment on collation pg_catalog."en-UM-x-icu" is 'English (U.S. Outlying Islands)';

alter collation pg_catalog."en-UM-x-icu" owner to postgres;

create collation pg_catalog."en-US-x-icu" (
    locale = 'en-US'
    );

comment on collation pg_catalog."en-US-x-icu" is 'English (United States)';

alter collation pg_catalog."en-US-x-icu" owner to postgres;

create collation pg_catalog."en-US-u-va-posix-x-icu" (
    locale = 'en-US-u-va-posix'
    );

comment on collation pg_catalog."en-US-u-va-posix-x-icu" is 'English (United States, Computer)';

alter collation pg_catalog."en-US-u-va-posix-x-icu" owner to postgres;

create collation pg_catalog."en-VC-x-icu" (
    locale = 'en-VC'
    );

comment on collation pg_catalog."en-VC-x-icu" is 'English (St. Vincent & Grenadines)';

alter collation pg_catalog."en-VC-x-icu" owner to postgres;

create collation pg_catalog."en-VG-x-icu" (
    locale = 'en-VG'
    );

comment on collation pg_catalog."en-VG-x-icu" is 'English (British Virgin Islands)';

alter collation pg_catalog."en-VG-x-icu" owner to postgres;

create collation pg_catalog."en-VI-x-icu" (
    locale = 'en-VI'
    );

comment on collation pg_catalog."en-VI-x-icu" is 'English (U.S. Virgin Islands)';

alter collation pg_catalog."en-VI-x-icu" owner to postgres;

create collation pg_catalog."en-VU-x-icu" (
    locale = 'en-VU'
    );

comment on collation pg_catalog."en-VU-x-icu" is 'English (Vanuatu)';

alter collation pg_catalog."en-VU-x-icu" owner to postgres;

create collation pg_catalog."en-WS-x-icu" (
    locale = 'en-WS'
    );

comment on collation pg_catalog."en-WS-x-icu" is 'English (Samoa)';

alter collation pg_catalog."en-WS-x-icu" owner to postgres;

create collation pg_catalog."en-ZA-x-icu" (
    locale = 'en-ZA'
    );

comment on collation pg_catalog."en-ZA-x-icu" is 'English (South Africa)';

alter collation pg_catalog."en-ZA-x-icu" owner to postgres;

create collation pg_catalog."en-ZM-x-icu" (
    locale = 'en-ZM'
    );

comment on collation pg_catalog."en-ZM-x-icu" is 'English (Zambia)';

alter collation pg_catalog."en-ZM-x-icu" owner to postgres;

create collation pg_catalog."en-ZW-x-icu" (
    locale = 'en-ZW'
    );

comment on collation pg_catalog."en-ZW-x-icu" is 'English (Zimbabwe)';

alter collation pg_catalog."en-ZW-x-icu" owner to postgres;

create collation pg_catalog."eo-x-icu" (
    locale = 'eo'
    );

comment on collation pg_catalog."eo-x-icu" is 'Esperanto';

alter collation pg_catalog."eo-x-icu" owner to postgres;

create collation pg_catalog."eo-001-x-icu" (
    locale = 'eo-001'
    );

comment on collation pg_catalog."eo-001-x-icu" is 'Esperanto (World)';

alter collation pg_catalog."eo-001-x-icu" owner to postgres;

create collation pg_catalog."es-x-icu" (
    locale = 'es'
    );

comment on collation pg_catalog."es-x-icu" is 'Spanish';

alter collation pg_catalog."es-x-icu" owner to postgres;

create collation pg_catalog."es-419-x-icu" (
    locale = 'es-419'
    );

comment on collation pg_catalog."es-419-x-icu" is 'Spanish (Latin America)';

alter collation pg_catalog."es-419-x-icu" owner to postgres;

create collation pg_catalog."es-AR-x-icu" (
    locale = 'es-AR'
    );

comment on collation pg_catalog."es-AR-x-icu" is 'Spanish (Argentina)';

alter collation pg_catalog."es-AR-x-icu" owner to postgres;

create collation pg_catalog."es-BO-x-icu" (
    locale = 'es-BO'
    );

comment on collation pg_catalog."es-BO-x-icu" is 'Spanish (Bolivia)';

alter collation pg_catalog."es-BO-x-icu" owner to postgres;

create collation pg_catalog."es-BR-x-icu" (
    locale = 'es-BR'
    );

comment on collation pg_catalog."es-BR-x-icu" is 'Spanish (Brazil)';

alter collation pg_catalog."es-BR-x-icu" owner to postgres;

create collation pg_catalog."es-BZ-x-icu" (
    locale = 'es-BZ'
    );

comment on collation pg_catalog."es-BZ-x-icu" is 'Spanish (Belize)';

alter collation pg_catalog."es-BZ-x-icu" owner to postgres;

create collation pg_catalog."es-CL-x-icu" (
    locale = 'es-CL'
    );

comment on collation pg_catalog."es-CL-x-icu" is 'Spanish (Chile)';

alter collation pg_catalog."es-CL-x-icu" owner to postgres;

create collation pg_catalog."es-CO-x-icu" (
    locale = 'es-CO'
    );

comment on collation pg_catalog."es-CO-x-icu" is 'Spanish (Colombia)';

alter collation pg_catalog."es-CO-x-icu" owner to postgres;

create collation pg_catalog."es-CR-x-icu" (
    locale = 'es-CR'
    );

comment on collation pg_catalog."es-CR-x-icu" is 'Spanish (Costa Rica)';

alter collation pg_catalog."es-CR-x-icu" owner to postgres;

create collation pg_catalog."es-CU-x-icu" (
    locale = 'es-CU'
    );

comment on collation pg_catalog."es-CU-x-icu" is 'Spanish (Cuba)';

alter collation pg_catalog."es-CU-x-icu" owner to postgres;

create collation pg_catalog."es-DO-x-icu" (
    locale = 'es-DO'
    );

comment on collation pg_catalog."es-DO-x-icu" is 'Spanish (Dominican Republic)';

alter collation pg_catalog."es-DO-x-icu" owner to postgres;

create collation pg_catalog."es-EA-x-icu" (
    locale = 'es-EA'
    );

comment on collation pg_catalog."es-EA-x-icu" is 'Spanish (Ceuta & Melilla)';

alter collation pg_catalog."es-EA-x-icu" owner to postgres;

create collation pg_catalog."es-EC-x-icu" (
    locale = 'es-EC'
    );

comment on collation pg_catalog."es-EC-x-icu" is 'Spanish (Ecuador)';

alter collation pg_catalog."es-EC-x-icu" owner to postgres;

create collation pg_catalog."es-ES-x-icu" (
    locale = 'es-ES'
    );

comment on collation pg_catalog."es-ES-x-icu" is 'Spanish (Spain)';

alter collation pg_catalog."es-ES-x-icu" owner to postgres;

create collation pg_catalog."es-GQ-x-icu" (
    locale = 'es-GQ'
    );

comment on collation pg_catalog."es-GQ-x-icu" is 'Spanish (Equatorial Guinea)';

alter collation pg_catalog."es-GQ-x-icu" owner to postgres;

create collation pg_catalog."es-GT-x-icu" (
    locale = 'es-GT'
    );

comment on collation pg_catalog."es-GT-x-icu" is 'Spanish (Guatemala)';

alter collation pg_catalog."es-GT-x-icu" owner to postgres;

create collation pg_catalog."es-HN-x-icu" (
    locale = 'es-HN'
    );

comment on collation pg_catalog."es-HN-x-icu" is 'Spanish (Honduras)';

alter collation pg_catalog."es-HN-x-icu" owner to postgres;

create collation pg_catalog."es-IC-x-icu" (
    locale = 'es-IC'
    );

comment on collation pg_catalog."es-IC-x-icu" is 'Spanish (Canary Islands)';

alter collation pg_catalog."es-IC-x-icu" owner to postgres;

create collation pg_catalog."es-MX-x-icu" (
    locale = 'es-MX'
    );

comment on collation pg_catalog."es-MX-x-icu" is 'Spanish (Mexico)';

alter collation pg_catalog."es-MX-x-icu" owner to postgres;

create collation pg_catalog."es-NI-x-icu" (
    locale = 'es-NI'
    );

comment on collation pg_catalog."es-NI-x-icu" is 'Spanish (Nicaragua)';

alter collation pg_catalog."es-NI-x-icu" owner to postgres;

create collation pg_catalog."es-PA-x-icu" (
    locale = 'es-PA'
    );

comment on collation pg_catalog."es-PA-x-icu" is 'Spanish (Panama)';

alter collation pg_catalog."es-PA-x-icu" owner to postgres;

create collation pg_catalog."es-PE-x-icu" (
    locale = 'es-PE'
    );

comment on collation pg_catalog."es-PE-x-icu" is 'Spanish (Peru)';

alter collation pg_catalog."es-PE-x-icu" owner to postgres;

create collation pg_catalog."es-PH-x-icu" (
    locale = 'es-PH'
    );

comment on collation pg_catalog."es-PH-x-icu" is 'Spanish (Philippines)';

alter collation pg_catalog."es-PH-x-icu" owner to postgres;

create collation pg_catalog."es-PR-x-icu" (
    locale = 'es-PR'
    );

comment on collation pg_catalog."es-PR-x-icu" is 'Spanish (Puerto Rico)';

alter collation pg_catalog."es-PR-x-icu" owner to postgres;

create collation pg_catalog."es-PY-x-icu" (
    locale = 'es-PY'
    );

comment on collation pg_catalog."es-PY-x-icu" is 'Spanish (Paraguay)';

alter collation pg_catalog."es-PY-x-icu" owner to postgres;

create collation pg_catalog."es-SV-x-icu" (
    locale = 'es-SV'
    );

comment on collation pg_catalog."es-SV-x-icu" is 'Spanish (El Salvador)';

alter collation pg_catalog."es-SV-x-icu" owner to postgres;

create collation pg_catalog."es-US-x-icu" (
    locale = 'es-US'
    );

comment on collation pg_catalog."es-US-x-icu" is 'Spanish (United States)';

alter collation pg_catalog."es-US-x-icu" owner to postgres;

create collation pg_catalog."es-UY-x-icu" (
    locale = 'es-UY'
    );

comment on collation pg_catalog."es-UY-x-icu" is 'Spanish (Uruguay)';

alter collation pg_catalog."es-UY-x-icu" owner to postgres;

create collation pg_catalog."es-VE-x-icu" (
    locale = 'es-VE'
    );

comment on collation pg_catalog."es-VE-x-icu" is 'Spanish (Venezuela)';

alter collation pg_catalog."es-VE-x-icu" owner to postgres;

create collation pg_catalog."et-x-icu" (
    locale = 'et'
    );

comment on collation pg_catalog."et-x-icu" is 'Estonian';

alter collation pg_catalog."et-x-icu" owner to postgres;

create collation pg_catalog."et-EE-x-icu" (
    locale = 'et-EE'
    );

comment on collation pg_catalog."et-EE-x-icu" is 'Estonian (Estonia)';

alter collation pg_catalog."et-EE-x-icu" owner to postgres;

create collation pg_catalog."eu-x-icu" (
    locale = 'eu'
    );

comment on collation pg_catalog."eu-x-icu" is 'Basque';

alter collation pg_catalog."eu-x-icu" owner to postgres;

create collation pg_catalog."eu-ES-x-icu" (
    locale = 'eu-ES'
    );

comment on collation pg_catalog."eu-ES-x-icu" is 'Basque (Spain)';

alter collation pg_catalog."eu-ES-x-icu" owner to postgres;

create collation pg_catalog."ewo-x-icu" (
    locale = 'ewo'
    );

comment on collation pg_catalog."ewo-x-icu" is 'Ewondo';

alter collation pg_catalog."ewo-x-icu" owner to postgres;

create collation pg_catalog."ewo-CM-x-icu" (
    locale = 'ewo-CM'
    );

comment on collation pg_catalog."ewo-CM-x-icu" is 'Ewondo (Cameroon)';

alter collation pg_catalog."ewo-CM-x-icu" owner to postgres;

create collation pg_catalog."fa-x-icu" (
    locale = 'fa'
    );

comment on collation pg_catalog."fa-x-icu" is 'Persian';

alter collation pg_catalog."fa-x-icu" owner to postgres;

create collation pg_catalog."fa-AF-x-icu" (
    locale = 'fa-AF'
    );

comment on collation pg_catalog."fa-AF-x-icu" is 'Persian (Afghanistan)';

alter collation pg_catalog."fa-AF-x-icu" owner to postgres;

create collation pg_catalog."fa-IR-x-icu" (
    locale = 'fa-IR'
    );

comment on collation pg_catalog."fa-IR-x-icu" is 'Persian (Iran)';

alter collation pg_catalog."fa-IR-x-icu" owner to postgres;

create collation pg_catalog."ff-x-icu" (
    locale = 'ff'
    );

comment on collation pg_catalog."ff-x-icu" is 'Fulah';

alter collation pg_catalog."ff-x-icu" owner to postgres;

create collation pg_catalog."ff-Latn-x-icu" (
    locale = 'ff-Latn'
    );

comment on collation pg_catalog."ff-Latn-x-icu" is 'Fulah (Latin)';

alter collation pg_catalog."ff-Latn-x-icu" owner to postgres;

create collation pg_catalog."ff-Latn-BF-x-icu" (
    locale = 'ff-Latn-BF'
    );

comment on collation pg_catalog."ff-Latn-BF-x-icu" is 'Fulah (Latin, Burkina Faso)';

alter collation pg_catalog."ff-Latn-BF-x-icu" owner to postgres;

create collation pg_catalog."ff-Latn-CM-x-icu" (
    locale = 'ff-Latn-CM'
    );

comment on collation pg_catalog."ff-Latn-CM-x-icu" is 'Fulah (Latin, Cameroon)';

alter collation pg_catalog."ff-Latn-CM-x-icu" owner to postgres;

create collation pg_catalog."ff-Latn-GH-x-icu" (
    locale = 'ff-Latn-GH'
    );

comment on collation pg_catalog."ff-Latn-GH-x-icu" is 'Fulah (Latin, Ghana)';

alter collation pg_catalog."ff-Latn-GH-x-icu" owner to postgres;

create collation pg_catalog."ff-Latn-GM-x-icu" (
    locale = 'ff-Latn-GM'
    );

comment on collation pg_catalog."ff-Latn-GM-x-icu" is 'Fulah (Latin, Gambia)';

alter collation pg_catalog."ff-Latn-GM-x-icu" owner to postgres;

create collation pg_catalog."ff-Latn-GN-x-icu" (
    locale = 'ff-Latn-GN'
    );

comment on collation pg_catalog."ff-Latn-GN-x-icu" is 'Fulah (Latin, Guinea)';

alter collation pg_catalog."ff-Latn-GN-x-icu" owner to postgres;

create collation pg_catalog."ff-Latn-GW-x-icu" (
    locale = 'ff-Latn-GW'
    );

comment on collation pg_catalog."ff-Latn-GW-x-icu" is 'Fulah (Latin, Guinea-Bissau)';

alter collation pg_catalog."ff-Latn-GW-x-icu" owner to postgres;

create collation pg_catalog."ff-Latn-LR-x-icu" (
    locale = 'ff-Latn-LR'
    );

comment on collation pg_catalog."ff-Latn-LR-x-icu" is 'Fulah (Latin, Liberia)';

alter collation pg_catalog."ff-Latn-LR-x-icu" owner to postgres;

create collation pg_catalog."ff-Latn-MR-x-icu" (
    locale = 'ff-Latn-MR'
    );

comment on collation pg_catalog."ff-Latn-MR-x-icu" is 'Fulah (Latin, Mauritania)';

alter collation pg_catalog."ff-Latn-MR-x-icu" owner to postgres;

create collation pg_catalog."ff-Latn-NE-x-icu" (
    locale = 'ff-Latn-NE'
    );

comment on collation pg_catalog."ff-Latn-NE-x-icu" is 'Fulah (Latin, Niger)';

alter collation pg_catalog."ff-Latn-NE-x-icu" owner to postgres;

create collation pg_catalog."ff-Latn-NG-x-icu" (
    locale = 'ff-Latn-NG'
    );

comment on collation pg_catalog."ff-Latn-NG-x-icu" is 'Fulah (Latin, Nigeria)';

alter collation pg_catalog."ff-Latn-NG-x-icu" owner to postgres;

create collation pg_catalog."ff-Latn-SL-x-icu" (
    locale = 'ff-Latn-SL'
    );

comment on collation pg_catalog."ff-Latn-SL-x-icu" is 'Fulah (Latin, Sierra Leone)';

alter collation pg_catalog."ff-Latn-SL-x-icu" owner to postgres;

create collation pg_catalog."ff-Latn-SN-x-icu" (
    locale = 'ff-Latn-SN'
    );

comment on collation pg_catalog."ff-Latn-SN-x-icu" is 'Fulah (Latin, Senegal)';

alter collation pg_catalog."ff-Latn-SN-x-icu" owner to postgres;

create collation pg_catalog."fi-x-icu" (
    locale = 'fi'
    );

comment on collation pg_catalog."fi-x-icu" is 'Finnish';

alter collation pg_catalog."fi-x-icu" owner to postgres;

create collation pg_catalog."fi-FI-x-icu" (
    locale = 'fi-FI'
    );

comment on collation pg_catalog."fi-FI-x-icu" is 'Finnish (Finland)';

alter collation pg_catalog."fi-FI-x-icu" owner to postgres;

create collation pg_catalog."fil-x-icu" (
    locale = 'fil'
    );

comment on collation pg_catalog."fil-x-icu" is 'Filipino';

alter collation pg_catalog."fil-x-icu" owner to postgres;

create collation pg_catalog."fil-PH-x-icu" (
    locale = 'fil-PH'
    );

comment on collation pg_catalog."fil-PH-x-icu" is 'Filipino (Philippines)';

alter collation pg_catalog."fil-PH-x-icu" owner to postgres;

create collation pg_catalog."fo-x-icu" (
    locale = 'fo'
    );

comment on collation pg_catalog."fo-x-icu" is 'Faroese';

alter collation pg_catalog."fo-x-icu" owner to postgres;

create collation pg_catalog."fo-DK-x-icu" (
    locale = 'fo-DK'
    );

comment on collation pg_catalog."fo-DK-x-icu" is 'Faroese (Denmark)';

alter collation pg_catalog."fo-DK-x-icu" owner to postgres;

create collation pg_catalog."fo-FO-x-icu" (
    locale = 'fo-FO'
    );

comment on collation pg_catalog."fo-FO-x-icu" is 'Faroese (Faroe Islands)';

alter collation pg_catalog."fo-FO-x-icu" owner to postgres;

create collation pg_catalog."fr-x-icu" (
    locale = 'fr'
    );

comment on collation pg_catalog."fr-x-icu" is 'French';

alter collation pg_catalog."fr-x-icu" owner to postgres;

create collation pg_catalog."fr-BE-x-icu" (
    locale = 'fr-BE'
    );

comment on collation pg_catalog."fr-BE-x-icu" is 'French (Belgium)';

alter collation pg_catalog."fr-BE-x-icu" owner to postgres;

create collation pg_catalog."fr-BF-x-icu" (
    locale = 'fr-BF'
    );

comment on collation pg_catalog."fr-BF-x-icu" is 'French (Burkina Faso)';

alter collation pg_catalog."fr-BF-x-icu" owner to postgres;

create collation pg_catalog."fr-BI-x-icu" (
    locale = 'fr-BI'
    );

comment on collation pg_catalog."fr-BI-x-icu" is 'French (Burundi)';

alter collation pg_catalog."fr-BI-x-icu" owner to postgres;

create collation pg_catalog."fr-BJ-x-icu" (
    locale = 'fr-BJ'
    );

comment on collation pg_catalog."fr-BJ-x-icu" is 'French (Benin)';

alter collation pg_catalog."fr-BJ-x-icu" owner to postgres;

create collation pg_catalog."fr-BL-x-icu" (
    locale = 'fr-BL'
    );

alter collation pg_catalog."fr-BL-x-icu" owner to postgres;

create collation pg_catalog."fr-CA-x-icu" (
    locale = 'fr-CA'
    );

comment on collation pg_catalog."fr-CA-x-icu" is 'French (Canada)';

alter collation pg_catalog."fr-CA-x-icu" owner to postgres;

create collation pg_catalog."fr-CD-x-icu" (
    locale = 'fr-CD'
    );

comment on collation pg_catalog."fr-CD-x-icu" is 'French (Congo - Kinshasa)';

alter collation pg_catalog."fr-CD-x-icu" owner to postgres;

create collation pg_catalog."fr-CF-x-icu" (
    locale = 'fr-CF'
    );

comment on collation pg_catalog."fr-CF-x-icu" is 'French (Central African Republic)';

alter collation pg_catalog."fr-CF-x-icu" owner to postgres;

create collation pg_catalog."fr-CG-x-icu" (
    locale = 'fr-CG'
    );

comment on collation pg_catalog."fr-CG-x-icu" is 'French (Congo - Brazzaville)';

alter collation pg_catalog."fr-CG-x-icu" owner to postgres;

create collation pg_catalog."fr-CH-x-icu" (
    locale = 'fr-CH'
    );

comment on collation pg_catalog."fr-CH-x-icu" is 'French (Switzerland)';

alter collation pg_catalog."fr-CH-x-icu" owner to postgres;

create collation pg_catalog."fr-CI-x-icu" (
    locale = 'fr-CI'
    );

alter collation pg_catalog."fr-CI-x-icu" owner to postgres;

create collation pg_catalog."fr-CM-x-icu" (
    locale = 'fr-CM'
    );

comment on collation pg_catalog."fr-CM-x-icu" is 'French (Cameroon)';

alter collation pg_catalog."fr-CM-x-icu" owner to postgres;

create collation pg_catalog."fr-DJ-x-icu" (
    locale = 'fr-DJ'
    );

comment on collation pg_catalog."fr-DJ-x-icu" is 'French (Djibouti)';

alter collation pg_catalog."fr-DJ-x-icu" owner to postgres;

create collation pg_catalog."fr-DZ-x-icu" (
    locale = 'fr-DZ'
    );

comment on collation pg_catalog."fr-DZ-x-icu" is 'French (Algeria)';

alter collation pg_catalog."fr-DZ-x-icu" owner to postgres;

create collation pg_catalog."fr-FR-x-icu" (
    locale = 'fr-FR'
    );

comment on collation pg_catalog."fr-FR-x-icu" is 'French (France)';

alter collation pg_catalog."fr-FR-x-icu" owner to postgres;

create collation pg_catalog."fr-GA-x-icu" (
    locale = 'fr-GA'
    );

comment on collation pg_catalog."fr-GA-x-icu" is 'French (Gabon)';

alter collation pg_catalog."fr-GA-x-icu" owner to postgres;

create collation pg_catalog."fr-GF-x-icu" (
    locale = 'fr-GF'
    );

comment on collation pg_catalog."fr-GF-x-icu" is 'French (French Guiana)';

alter collation pg_catalog."fr-GF-x-icu" owner to postgres;

create collation pg_catalog."fr-GN-x-icu" (
    locale = 'fr-GN'
    );

comment on collation pg_catalog."fr-GN-x-icu" is 'French (Guinea)';

alter collation pg_catalog."fr-GN-x-icu" owner to postgres;

create collation pg_catalog."fr-GP-x-icu" (
    locale = 'fr-GP'
    );

comment on collation pg_catalog."fr-GP-x-icu" is 'French (Guadeloupe)';

alter collation pg_catalog."fr-GP-x-icu" owner to postgres;

create collation pg_catalog."fr-GQ-x-icu" (
    locale = 'fr-GQ'
    );

comment on collation pg_catalog."fr-GQ-x-icu" is 'French (Equatorial Guinea)';

alter collation pg_catalog."fr-GQ-x-icu" owner to postgres;

create collation pg_catalog."fr-HT-x-icu" (
    locale = 'fr-HT'
    );

comment on collation pg_catalog."fr-HT-x-icu" is 'French (Haiti)';

alter collation pg_catalog."fr-HT-x-icu" owner to postgres;

create collation pg_catalog."fr-KM-x-icu" (
    locale = 'fr-KM'
    );

comment on collation pg_catalog."fr-KM-x-icu" is 'French (Comoros)';

alter collation pg_catalog."fr-KM-x-icu" owner to postgres;

create collation pg_catalog."fr-LU-x-icu" (
    locale = 'fr-LU'
    );

comment on collation pg_catalog."fr-LU-x-icu" is 'French (Luxembourg)';

alter collation pg_catalog."fr-LU-x-icu" owner to postgres;

create collation pg_catalog."fr-MA-x-icu" (
    locale = 'fr-MA'
    );

comment on collation pg_catalog."fr-MA-x-icu" is 'French (Morocco)';

alter collation pg_catalog."fr-MA-x-icu" owner to postgres;

create collation pg_catalog."fr-MC-x-icu" (
    locale = 'fr-MC'
    );

comment on collation pg_catalog."fr-MC-x-icu" is 'French (Monaco)';

alter collation pg_catalog."fr-MC-x-icu" owner to postgres;

create collation pg_catalog."fr-MF-x-icu" (
    locale = 'fr-MF'
    );

comment on collation pg_catalog."fr-MF-x-icu" is 'French (St. Martin)';

alter collation pg_catalog."fr-MF-x-icu" owner to postgres;

create collation pg_catalog."fr-MG-x-icu" (
    locale = 'fr-MG'
    );

comment on collation pg_catalog."fr-MG-x-icu" is 'French (Madagascar)';

alter collation pg_catalog."fr-MG-x-icu" owner to postgres;

create collation pg_catalog."fr-ML-x-icu" (
    locale = 'fr-ML'
    );

comment on collation pg_catalog."fr-ML-x-icu" is 'French (Mali)';

alter collation pg_catalog."fr-ML-x-icu" owner to postgres;

create collation pg_catalog."fr-MQ-x-icu" (
    locale = 'fr-MQ'
    );

comment on collation pg_catalog."fr-MQ-x-icu" is 'French (Martinique)';

alter collation pg_catalog."fr-MQ-x-icu" owner to postgres;

create collation pg_catalog."fr-MR-x-icu" (
    locale = 'fr-MR'
    );

comment on collation pg_catalog."fr-MR-x-icu" is 'French (Mauritania)';

alter collation pg_catalog."fr-MR-x-icu" owner to postgres;

create collation pg_catalog."fr-MU-x-icu" (
    locale = 'fr-MU'
    );

comment on collation pg_catalog."fr-MU-x-icu" is 'French (Mauritius)';

alter collation pg_catalog."fr-MU-x-icu" owner to postgres;

create collation pg_catalog."fr-NC-x-icu" (
    locale = 'fr-NC'
    );

comment on collation pg_catalog."fr-NC-x-icu" is 'French (New Caledonia)';

alter collation pg_catalog."fr-NC-x-icu" owner to postgres;

create collation pg_catalog."fr-NE-x-icu" (
    locale = 'fr-NE'
    );

comment on collation pg_catalog."fr-NE-x-icu" is 'French (Niger)';

alter collation pg_catalog."fr-NE-x-icu" owner to postgres;

create collation pg_catalog."fr-PF-x-icu" (
    locale = 'fr-PF'
    );

comment on collation pg_catalog."fr-PF-x-icu" is 'French (French Polynesia)';

alter collation pg_catalog."fr-PF-x-icu" owner to postgres;

create collation pg_catalog."fr-PM-x-icu" (
    locale = 'fr-PM'
    );

comment on collation pg_catalog."fr-PM-x-icu" is 'French (St. Pierre & Miquelon)';

alter collation pg_catalog."fr-PM-x-icu" owner to postgres;

create collation pg_catalog."fr-RE-x-icu" (
    locale = 'fr-RE'
    );

alter collation pg_catalog."fr-RE-x-icu" owner to postgres;

create collation pg_catalog."fr-RW-x-icu" (
    locale = 'fr-RW'
    );

comment on collation pg_catalog."fr-RW-x-icu" is 'French (Rwanda)';

alter collation pg_catalog."fr-RW-x-icu" owner to postgres;

create collation pg_catalog."fr-SC-x-icu" (
    locale = 'fr-SC'
    );

comment on collation pg_catalog."fr-SC-x-icu" is 'French (Seychelles)';

alter collation pg_catalog."fr-SC-x-icu" owner to postgres;

create collation pg_catalog."fr-SN-x-icu" (
    locale = 'fr-SN'
    );

comment on collation pg_catalog."fr-SN-x-icu" is 'French (Senegal)';

alter collation pg_catalog."fr-SN-x-icu" owner to postgres;

create collation pg_catalog."fr-SY-x-icu" (
    locale = 'fr-SY'
    );

comment on collation pg_catalog."fr-SY-x-icu" is 'French (Syria)';

alter collation pg_catalog."fr-SY-x-icu" owner to postgres;

create collation pg_catalog."fr-TD-x-icu" (
    locale = 'fr-TD'
    );

comment on collation pg_catalog."fr-TD-x-icu" is 'French (Chad)';

alter collation pg_catalog."fr-TD-x-icu" owner to postgres;

create collation pg_catalog."fr-TG-x-icu" (
    locale = 'fr-TG'
    );

comment on collation pg_catalog."fr-TG-x-icu" is 'French (Togo)';

alter collation pg_catalog."fr-TG-x-icu" owner to postgres;

create collation pg_catalog."fr-TN-x-icu" (
    locale = 'fr-TN'
    );

comment on collation pg_catalog."fr-TN-x-icu" is 'French (Tunisia)';

alter collation pg_catalog."fr-TN-x-icu" owner to postgres;

create collation pg_catalog."fr-VU-x-icu" (
    locale = 'fr-VU'
    );

comment on collation pg_catalog."fr-VU-x-icu" is 'French (Vanuatu)';

alter collation pg_catalog."fr-VU-x-icu" owner to postgres;

create collation pg_catalog."fr-WF-x-icu" (
    locale = 'fr-WF'
    );

comment on collation pg_catalog."fr-WF-x-icu" is 'French (Wallis & Futuna)';

alter collation pg_catalog."fr-WF-x-icu" owner to postgres;

create collation pg_catalog."fr-YT-x-icu" (
    locale = 'fr-YT'
    );

comment on collation pg_catalog."fr-YT-x-icu" is 'French (Mayotte)';

alter collation pg_catalog."fr-YT-x-icu" owner to postgres;

create collation pg_catalog."fur-x-icu" (
    locale = 'fur'
    );

comment on collation pg_catalog."fur-x-icu" is 'Friulian';

alter collation pg_catalog."fur-x-icu" owner to postgres;

create collation pg_catalog."fur-IT-x-icu" (
    locale = 'fur-IT'
    );

comment on collation pg_catalog."fur-IT-x-icu" is 'Friulian (Italy)';

alter collation pg_catalog."fur-IT-x-icu" owner to postgres;

create collation pg_catalog."fy-x-icu" (
    locale = 'fy'
    );

comment on collation pg_catalog."fy-x-icu" is 'Western Frisian';

alter collation pg_catalog."fy-x-icu" owner to postgres;

create collation pg_catalog."fy-NL-x-icu" (
    locale = 'fy-NL'
    );

comment on collation pg_catalog."fy-NL-x-icu" is 'Western Frisian (Netherlands)';

alter collation pg_catalog."fy-NL-x-icu" owner to postgres;

create collation pg_catalog."ga-x-icu" (
    locale = 'ga'
    );

comment on collation pg_catalog."ga-x-icu" is 'Irish';

alter collation pg_catalog."ga-x-icu" owner to postgres;

create collation pg_catalog."ga-GB-x-icu" (
    locale = 'ga-GB'
    );

comment on collation pg_catalog."ga-GB-x-icu" is 'Irish (United Kingdom)';

alter collation pg_catalog."ga-GB-x-icu" owner to postgres;

create collation pg_catalog."ga-IE-x-icu" (
    locale = 'ga-IE'
    );

comment on collation pg_catalog."ga-IE-x-icu" is 'Irish (Ireland)';

alter collation pg_catalog."ga-IE-x-icu" owner to postgres;

create collation pg_catalog."gd-x-icu" (
    locale = 'gd'
    );

comment on collation pg_catalog."gd-x-icu" is 'Scottish Gaelic';

alter collation pg_catalog."gd-x-icu" owner to postgres;

create collation pg_catalog."gd-GB-x-icu" (
    locale = 'gd-GB'
    );

comment on collation pg_catalog."gd-GB-x-icu" is 'Scottish Gaelic (United Kingdom)';

alter collation pg_catalog."gd-GB-x-icu" owner to postgres;

create collation pg_catalog."gl-x-icu" (
    locale = 'gl'
    );

comment on collation pg_catalog."gl-x-icu" is 'Galician';

alter collation pg_catalog."gl-x-icu" owner to postgres;

create collation pg_catalog."gl-ES-x-icu" (
    locale = 'gl-ES'
    );

comment on collation pg_catalog."gl-ES-x-icu" is 'Galician (Spain)';

alter collation pg_catalog."gl-ES-x-icu" owner to postgres;

create collation pg_catalog."gsw-x-icu" (
    locale = 'gsw'
    );

comment on collation pg_catalog."gsw-x-icu" is 'Swiss German';

alter collation pg_catalog."gsw-x-icu" owner to postgres;

create collation pg_catalog."gsw-CH-x-icu" (
    locale = 'gsw-CH'
    );

comment on collation pg_catalog."gsw-CH-x-icu" is 'Swiss German (Switzerland)';

alter collation pg_catalog."gsw-CH-x-icu" owner to postgres;

create collation pg_catalog."gsw-FR-x-icu" (
    locale = 'gsw-FR'
    );

comment on collation pg_catalog."gsw-FR-x-icu" is 'Swiss German (France)';

alter collation pg_catalog."gsw-FR-x-icu" owner to postgres;

create collation pg_catalog."gsw-LI-x-icu" (
    locale = 'gsw-LI'
    );

comment on collation pg_catalog."gsw-LI-x-icu" is 'Swiss German (Liechtenstein)';

alter collation pg_catalog."gsw-LI-x-icu" owner to postgres;

create collation pg_catalog."gu-x-icu" (
    locale = 'gu'
    );

comment on collation pg_catalog."gu-x-icu" is 'Gujarati';

alter collation pg_catalog."gu-x-icu" owner to postgres;

create collation pg_catalog."gu-IN-x-icu" (
    locale = 'gu-IN'
    );

comment on collation pg_catalog."gu-IN-x-icu" is 'Gujarati (India)';

alter collation pg_catalog."gu-IN-x-icu" owner to postgres;

create collation pg_catalog."guz-x-icu" (
    locale = 'guz'
    );

comment on collation pg_catalog."guz-x-icu" is 'Gusii';

alter collation pg_catalog."guz-x-icu" owner to postgres;

create collation pg_catalog."guz-KE-x-icu" (
    locale = 'guz-KE'
    );

comment on collation pg_catalog."guz-KE-x-icu" is 'Gusii (Kenya)';

alter collation pg_catalog."guz-KE-x-icu" owner to postgres;

create collation pg_catalog."gv-x-icu" (
    locale = 'gv'
    );

comment on collation pg_catalog."gv-x-icu" is 'Manx';

alter collation pg_catalog."gv-x-icu" owner to postgres;

create collation pg_catalog."gv-IM-x-icu" (
    locale = 'gv-IM'
    );

comment on collation pg_catalog."gv-IM-x-icu" is 'Manx (Isle of Man)';

alter collation pg_catalog."gv-IM-x-icu" owner to postgres;

create collation pg_catalog."ha-x-icu" (
    locale = 'ha'
    );

comment on collation pg_catalog."ha-x-icu" is 'Hausa';

alter collation pg_catalog."ha-x-icu" owner to postgres;

create collation pg_catalog."ha-GH-x-icu" (
    locale = 'ha-GH'
    );

comment on collation pg_catalog."ha-GH-x-icu" is 'Hausa (Ghana)';

alter collation pg_catalog."ha-GH-x-icu" owner to postgres;

create collation pg_catalog."ha-NE-x-icu" (
    locale = 'ha-NE'
    );

comment on collation pg_catalog."ha-NE-x-icu" is 'Hausa (Niger)';

alter collation pg_catalog."ha-NE-x-icu" owner to postgres;

create collation pg_catalog."ha-NG-x-icu" (
    locale = 'ha-NG'
    );

comment on collation pg_catalog."ha-NG-x-icu" is 'Hausa (Nigeria)';

alter collation pg_catalog."ha-NG-x-icu" owner to postgres;

create collation pg_catalog."haw-x-icu" (
    locale = 'haw'
    );

comment on collation pg_catalog."haw-x-icu" is 'Hawaiian';

alter collation pg_catalog."haw-x-icu" owner to postgres;

create collation pg_catalog."haw-US-x-icu" (
    locale = 'haw-US'
    );

comment on collation pg_catalog."haw-US-x-icu" is 'Hawaiian (United States)';

alter collation pg_catalog."haw-US-x-icu" owner to postgres;

create collation pg_catalog."he-x-icu" (
    locale = 'he'
    );

comment on collation pg_catalog."he-x-icu" is 'Hebrew';

alter collation pg_catalog."he-x-icu" owner to postgres;

create collation pg_catalog."he-IL-x-icu" (
    locale = 'he-IL'
    );

comment on collation pg_catalog."he-IL-x-icu" is 'Hebrew (Israel)';

alter collation pg_catalog."he-IL-x-icu" owner to postgres;

create collation pg_catalog."hi-x-icu" (
    locale = 'hi'
    );

comment on collation pg_catalog."hi-x-icu" is 'Hindi';

alter collation pg_catalog."hi-x-icu" owner to postgres;

create collation pg_catalog."hi-IN-x-icu" (
    locale = 'hi-IN'
    );

comment on collation pg_catalog."hi-IN-x-icu" is 'Hindi (India)';

alter collation pg_catalog."hi-IN-x-icu" owner to postgres;

create collation pg_catalog."hr-x-icu" (
    locale = 'hr'
    );

comment on collation pg_catalog."hr-x-icu" is 'Croatian';

alter collation pg_catalog."hr-x-icu" owner to postgres;

create collation pg_catalog."hr-BA-x-icu" (
    locale = 'hr-BA'
    );

comment on collation pg_catalog."hr-BA-x-icu" is 'Croatian (Bosnia & Herzegovina)';

alter collation pg_catalog."hr-BA-x-icu" owner to postgres;

create collation pg_catalog."hr-HR-x-icu" (
    locale = 'hr-HR'
    );

comment on collation pg_catalog."hr-HR-x-icu" is 'Croatian (Croatia)';

alter collation pg_catalog."hr-HR-x-icu" owner to postgres;

create collation pg_catalog."hsb-x-icu" (
    locale = 'hsb'
    );

comment on collation pg_catalog."hsb-x-icu" is 'Upper Sorbian';

alter collation pg_catalog."hsb-x-icu" owner to postgres;

create collation pg_catalog."hsb-DE-x-icu" (
    locale = 'hsb-DE'
    );

comment on collation pg_catalog."hsb-DE-x-icu" is 'Upper Sorbian (Germany)';

alter collation pg_catalog."hsb-DE-x-icu" owner to postgres;

create collation pg_catalog."hu-x-icu" (
    locale = 'hu'
    );

comment on collation pg_catalog."hu-x-icu" is 'Hungarian';

alter collation pg_catalog."hu-x-icu" owner to postgres;

create collation pg_catalog."hu-HU-x-icu" (
    locale = 'hu-HU'
    );

comment on collation pg_catalog."hu-HU-x-icu" is 'Hungarian (Hungary)';

alter collation pg_catalog."hu-HU-x-icu" owner to postgres;

create collation pg_catalog."hy-x-icu" (
    locale = 'hy'
    );

comment on collation pg_catalog."hy-x-icu" is 'Armenian';

alter collation pg_catalog."hy-x-icu" owner to postgres;

create collation pg_catalog."hy-AM-x-icu" (
    locale = 'hy-AM'
    );

comment on collation pg_catalog."hy-AM-x-icu" is 'Armenian (Armenia)';

alter collation pg_catalog."hy-AM-x-icu" owner to postgres;

create collation pg_catalog."ia-x-icu" (
    locale = 'ia'
    );

comment on collation pg_catalog."ia-x-icu" is 'Interlingua';

alter collation pg_catalog."ia-x-icu" owner to postgres;

create collation pg_catalog."ia-001-x-icu" (
    locale = 'ia-001'
    );

comment on collation pg_catalog."ia-001-x-icu" is 'Interlingua (World)';

alter collation pg_catalog."ia-001-x-icu" owner to postgres;

create collation pg_catalog."id-x-icu" (
    locale = 'id'
    );

comment on collation pg_catalog."id-x-icu" is 'Indonesian';

alter collation pg_catalog."id-x-icu" owner to postgres;

create collation pg_catalog."id-ID-x-icu" (
    locale = 'id-ID'
    );

comment on collation pg_catalog."id-ID-x-icu" is 'Indonesian (Indonesia)';

alter collation pg_catalog."id-ID-x-icu" owner to postgres;

create collation pg_catalog."ig-x-icu" (
    locale = 'ig'
    );

comment on collation pg_catalog."ig-x-icu" is 'Igbo';

alter collation pg_catalog."ig-x-icu" owner to postgres;

create collation pg_catalog."ig-NG-x-icu" (
    locale = 'ig-NG'
    );

comment on collation pg_catalog."ig-NG-x-icu" is 'Igbo (Nigeria)';

alter collation pg_catalog."ig-NG-x-icu" owner to postgres;

create collation pg_catalog."ii-x-icu" (
    locale = 'ii'
    );

comment on collation pg_catalog."ii-x-icu" is 'Sichuan Yi';

alter collation pg_catalog."ii-x-icu" owner to postgres;

create collation pg_catalog."ii-CN-x-icu" (
    locale = 'ii-CN'
    );

comment on collation pg_catalog."ii-CN-x-icu" is 'Sichuan Yi (China)';

alter collation pg_catalog."ii-CN-x-icu" owner to postgres;

create collation pg_catalog."is-x-icu" (
    locale = 'is'
    );

comment on collation pg_catalog."is-x-icu" is 'Icelandic';

alter collation pg_catalog."is-x-icu" owner to postgres;

create collation pg_catalog."is-IS-x-icu" (
    locale = 'is-IS'
    );

comment on collation pg_catalog."is-IS-x-icu" is 'Icelandic (Iceland)';

alter collation pg_catalog."is-IS-x-icu" owner to postgres;

create collation pg_catalog."it-x-icu" (
    locale = 'it'
    );

comment on collation pg_catalog."it-x-icu" is 'Italian';

alter collation pg_catalog."it-x-icu" owner to postgres;

create collation pg_catalog."it-CH-x-icu" (
    locale = 'it-CH'
    );

comment on collation pg_catalog."it-CH-x-icu" is 'Italian (Switzerland)';

alter collation pg_catalog."it-CH-x-icu" owner to postgres;

create collation pg_catalog."it-IT-x-icu" (
    locale = 'it-IT'
    );

comment on collation pg_catalog."it-IT-x-icu" is 'Italian (Italy)';

alter collation pg_catalog."it-IT-x-icu" owner to postgres;

create collation pg_catalog."it-SM-x-icu" (
    locale = 'it-SM'
    );

comment on collation pg_catalog."it-SM-x-icu" is 'Italian (San Marino)';

alter collation pg_catalog."it-SM-x-icu" owner to postgres;

create collation pg_catalog."it-VA-x-icu" (
    locale = 'it-VA'
    );

comment on collation pg_catalog."it-VA-x-icu" is 'Italian (Vatican City)';

alter collation pg_catalog."it-VA-x-icu" owner to postgres;

create collation pg_catalog."ja-x-icu" (
    locale = 'ja'
    );

comment on collation pg_catalog."ja-x-icu" is 'Japanese';

alter collation pg_catalog."ja-x-icu" owner to postgres;

create collation pg_catalog."ja-JP-x-icu" (
    locale = 'ja-JP'
    );

comment on collation pg_catalog."ja-JP-x-icu" is 'Japanese (Japan)';

alter collation pg_catalog."ja-JP-x-icu" owner to postgres;

create collation pg_catalog."jgo-x-icu" (
    locale = 'jgo'
    );

comment on collation pg_catalog."jgo-x-icu" is 'Ngomba';

alter collation pg_catalog."jgo-x-icu" owner to postgres;

create collation pg_catalog."jgo-CM-x-icu" (
    locale = 'jgo-CM'
    );

comment on collation pg_catalog."jgo-CM-x-icu" is 'Ngomba (Cameroon)';

alter collation pg_catalog."jgo-CM-x-icu" owner to postgres;

create collation pg_catalog."jmc-x-icu" (
    locale = 'jmc'
    );

comment on collation pg_catalog."jmc-x-icu" is 'Machame';

alter collation pg_catalog."jmc-x-icu" owner to postgres;

create collation pg_catalog."jmc-TZ-x-icu" (
    locale = 'jmc-TZ'
    );

comment on collation pg_catalog."jmc-TZ-x-icu" is 'Machame (Tanzania)';

alter collation pg_catalog."jmc-TZ-x-icu" owner to postgres;

create collation pg_catalog."jv-x-icu" (
    locale = 'jv'
    );

comment on collation pg_catalog."jv-x-icu" is 'Javanese';

alter collation pg_catalog."jv-x-icu" owner to postgres;

create collation pg_catalog."jv-ID-x-icu" (
    locale = 'jv-ID'
    );

comment on collation pg_catalog."jv-ID-x-icu" is 'Javanese (Indonesia)';

alter collation pg_catalog."jv-ID-x-icu" owner to postgres;

create collation pg_catalog."ka-x-icu" (
    locale = 'ka'
    );

comment on collation pg_catalog."ka-x-icu" is 'Georgian';

alter collation pg_catalog."ka-x-icu" owner to postgres;

create collation pg_catalog."ka-GE-x-icu" (
    locale = 'ka-GE'
    );

comment on collation pg_catalog."ka-GE-x-icu" is 'Georgian (Georgia)';

alter collation pg_catalog."ka-GE-x-icu" owner to postgres;

create collation pg_catalog."kab-x-icu" (
    locale = 'kab'
    );

comment on collation pg_catalog."kab-x-icu" is 'Kabyle';

alter collation pg_catalog."kab-x-icu" owner to postgres;

create collation pg_catalog."kab-DZ-x-icu" (
    locale = 'kab-DZ'
    );

comment on collation pg_catalog."kab-DZ-x-icu" is 'Kabyle (Algeria)';

alter collation pg_catalog."kab-DZ-x-icu" owner to postgres;

create collation pg_catalog."kam-x-icu" (
    locale = 'kam'
    );

comment on collation pg_catalog."kam-x-icu" is 'Kamba';

alter collation pg_catalog."kam-x-icu" owner to postgres;

create collation pg_catalog."kam-KE-x-icu" (
    locale = 'kam-KE'
    );

comment on collation pg_catalog."kam-KE-x-icu" is 'Kamba (Kenya)';

alter collation pg_catalog."kam-KE-x-icu" owner to postgres;

create collation pg_catalog."kde-x-icu" (
    locale = 'kde'
    );

comment on collation pg_catalog."kde-x-icu" is 'Makonde';

alter collation pg_catalog."kde-x-icu" owner to postgres;

create collation pg_catalog."kde-TZ-x-icu" (
    locale = 'kde-TZ'
    );

comment on collation pg_catalog."kde-TZ-x-icu" is 'Makonde (Tanzania)';

alter collation pg_catalog."kde-TZ-x-icu" owner to postgres;

create collation pg_catalog."kea-x-icu" (
    locale = 'kea'
    );

comment on collation pg_catalog."kea-x-icu" is 'Kabuverdianu';

alter collation pg_catalog."kea-x-icu" owner to postgres;

create collation pg_catalog."kea-CV-x-icu" (
    locale = 'kea-CV'
    );

comment on collation pg_catalog."kea-CV-x-icu" is 'Kabuverdianu (Cape Verde)';

alter collation pg_catalog."kea-CV-x-icu" owner to postgres;

create collation pg_catalog."khq-x-icu" (
    locale = 'khq'
    );

comment on collation pg_catalog."khq-x-icu" is 'Koyra Chiini';

alter collation pg_catalog."khq-x-icu" owner to postgres;

create collation pg_catalog."khq-ML-x-icu" (
    locale = 'khq-ML'
    );

comment on collation pg_catalog."khq-ML-x-icu" is 'Koyra Chiini (Mali)';

alter collation pg_catalog."khq-ML-x-icu" owner to postgres;

create collation pg_catalog."ki-x-icu" (
    locale = 'ki'
    );

comment on collation pg_catalog."ki-x-icu" is 'Kikuyu';

alter collation pg_catalog."ki-x-icu" owner to postgres;

create collation pg_catalog."ki-KE-x-icu" (
    locale = 'ki-KE'
    );

comment on collation pg_catalog."ki-KE-x-icu" is 'Kikuyu (Kenya)';

alter collation pg_catalog."ki-KE-x-icu" owner to postgres;

create collation pg_catalog."kk-x-icu" (
    locale = 'kk'
    );

comment on collation pg_catalog."kk-x-icu" is 'Kazakh';

alter collation pg_catalog."kk-x-icu" owner to postgres;

create collation pg_catalog."kk-KZ-x-icu" (
    locale = 'kk-KZ'
    );

comment on collation pg_catalog."kk-KZ-x-icu" is 'Kazakh (Kazakhstan)';

alter collation pg_catalog."kk-KZ-x-icu" owner to postgres;

create collation pg_catalog."kkj-x-icu" (
    locale = 'kkj'
    );

comment on collation pg_catalog."kkj-x-icu" is 'Kako';

alter collation pg_catalog."kkj-x-icu" owner to postgres;

create collation pg_catalog."kkj-CM-x-icu" (
    locale = 'kkj-CM'
    );

comment on collation pg_catalog."kkj-CM-x-icu" is 'Kako (Cameroon)';

alter collation pg_catalog."kkj-CM-x-icu" owner to postgres;

create collation pg_catalog."kl-x-icu" (
    locale = 'kl'
    );

comment on collation pg_catalog."kl-x-icu" is 'Kalaallisut';

alter collation pg_catalog."kl-x-icu" owner to postgres;

create collation pg_catalog."kl-GL-x-icu" (
    locale = 'kl-GL'
    );

comment on collation pg_catalog."kl-GL-x-icu" is 'Kalaallisut (Greenland)';

alter collation pg_catalog."kl-GL-x-icu" owner to postgres;

create collation pg_catalog."kln-x-icu" (
    locale = 'kln'
    );

comment on collation pg_catalog."kln-x-icu" is 'Kalenjin';

alter collation pg_catalog."kln-x-icu" owner to postgres;

create collation pg_catalog."kln-KE-x-icu" (
    locale = 'kln-KE'
    );

comment on collation pg_catalog."kln-KE-x-icu" is 'Kalenjin (Kenya)';

alter collation pg_catalog."kln-KE-x-icu" owner to postgres;

create collation pg_catalog."km-x-icu" (
    locale = 'km'
    );

comment on collation pg_catalog."km-x-icu" is 'Khmer';

alter collation pg_catalog."km-x-icu" owner to postgres;

create collation pg_catalog."km-KH-x-icu" (
    locale = 'km-KH'
    );

comment on collation pg_catalog."km-KH-x-icu" is 'Khmer (Cambodia)';

alter collation pg_catalog."km-KH-x-icu" owner to postgres;

create collation pg_catalog."kn-x-icu" (
    locale = 'kn'
    );

comment on collation pg_catalog."kn-x-icu" is 'Kannada';

alter collation pg_catalog."kn-x-icu" owner to postgres;

create collation pg_catalog."kn-IN-x-icu" (
    locale = 'kn-IN'
    );

comment on collation pg_catalog."kn-IN-x-icu" is 'Kannada (India)';

alter collation pg_catalog."kn-IN-x-icu" owner to postgres;

create collation pg_catalog."ko-x-icu" (
    locale = 'ko'
    );

comment on collation pg_catalog."ko-x-icu" is 'Korean';

alter collation pg_catalog."ko-x-icu" owner to postgres;

create collation pg_catalog."ko-KP-x-icu" (
    locale = 'ko-KP'
    );

comment on collation pg_catalog."ko-KP-x-icu" is 'Korean (North Korea)';

alter collation pg_catalog."ko-KP-x-icu" owner to postgres;

create collation pg_catalog."ko-KR-x-icu" (
    locale = 'ko-KR'
    );

comment on collation pg_catalog."ko-KR-x-icu" is 'Korean (South Korea)';

alter collation pg_catalog."ko-KR-x-icu" owner to postgres;

create collation pg_catalog."kok-x-icu" (
    locale = 'kok'
    );

comment on collation pg_catalog."kok-x-icu" is 'Konkani';

alter collation pg_catalog."kok-x-icu" owner to postgres;

create collation pg_catalog."kok-IN-x-icu" (
    locale = 'kok-IN'
    );

comment on collation pg_catalog."kok-IN-x-icu" is 'Konkani (India)';

alter collation pg_catalog."kok-IN-x-icu" owner to postgres;

create collation pg_catalog."ks-x-icu" (
    locale = 'ks'
    );

comment on collation pg_catalog."ks-x-icu" is 'Kashmiri';

alter collation pg_catalog."ks-x-icu" owner to postgres;

create collation pg_catalog."ks-IN-x-icu" (
    locale = 'ks-IN'
    );

comment on collation pg_catalog."ks-IN-x-icu" is 'Kashmiri (India)';

alter collation pg_catalog."ks-IN-x-icu" owner to postgres;

create collation pg_catalog."ksb-x-icu" (
    locale = 'ksb'
    );

comment on collation pg_catalog."ksb-x-icu" is 'Shambala';

alter collation pg_catalog."ksb-x-icu" owner to postgres;

create collation pg_catalog."ksb-TZ-x-icu" (
    locale = 'ksb-TZ'
    );

comment on collation pg_catalog."ksb-TZ-x-icu" is 'Shambala (Tanzania)';

alter collation pg_catalog."ksb-TZ-x-icu" owner to postgres;

create collation pg_catalog."ksf-x-icu" (
    locale = 'ksf'
    );

comment on collation pg_catalog."ksf-x-icu" is 'Bafia';

alter collation pg_catalog."ksf-x-icu" owner to postgres;

create collation pg_catalog."ksf-CM-x-icu" (
    locale = 'ksf-CM'
    );

comment on collation pg_catalog."ksf-CM-x-icu" is 'Bafia (Cameroon)';

alter collation pg_catalog."ksf-CM-x-icu" owner to postgres;

create collation pg_catalog."ksh-x-icu" (
    locale = 'ksh'
    );

comment on collation pg_catalog."ksh-x-icu" is 'Colognian';

alter collation pg_catalog."ksh-x-icu" owner to postgres;

create collation pg_catalog."ksh-DE-x-icu" (
    locale = 'ksh-DE'
    );

comment on collation pg_catalog."ksh-DE-x-icu" is 'Colognian (Germany)';

alter collation pg_catalog."ksh-DE-x-icu" owner to postgres;

create collation pg_catalog."ku-x-icu" (
    locale = 'ku'
    );

comment on collation pg_catalog."ku-x-icu" is 'Kurdish';

alter collation pg_catalog."ku-x-icu" owner to postgres;

create collation pg_catalog."ku-TR-x-icu" (
    locale = 'ku-TR'
    );

comment on collation pg_catalog."ku-TR-x-icu" is 'Kurdish (Turkey)';

alter collation pg_catalog."ku-TR-x-icu" owner to postgres;

create collation pg_catalog."kw-x-icu" (
    locale = 'kw'
    );

comment on collation pg_catalog."kw-x-icu" is 'Cornish';

alter collation pg_catalog."kw-x-icu" owner to postgres;

create collation pg_catalog."kw-GB-x-icu" (
    locale = 'kw-GB'
    );

comment on collation pg_catalog."kw-GB-x-icu" is 'Cornish (United Kingdom)';

alter collation pg_catalog."kw-GB-x-icu" owner to postgres;

create collation pg_catalog."ky-x-icu" (
    locale = 'ky'
    );

comment on collation pg_catalog."ky-x-icu" is 'Kyrgyz';

alter collation pg_catalog."ky-x-icu" owner to postgres;

create collation pg_catalog."ky-KG-x-icu" (
    locale = 'ky-KG'
    );

comment on collation pg_catalog."ky-KG-x-icu" is 'Kyrgyz (Kyrgyzstan)';

alter collation pg_catalog."ky-KG-x-icu" owner to postgres;

create collation pg_catalog."lag-x-icu" (
    locale = 'lag'
    );

comment on collation pg_catalog."lag-x-icu" is 'Langi';

alter collation pg_catalog."lag-x-icu" owner to postgres;

create collation pg_catalog."lag-TZ-x-icu" (
    locale = 'lag-TZ'
    );

comment on collation pg_catalog."lag-TZ-x-icu" is 'Langi (Tanzania)';

alter collation pg_catalog."lag-TZ-x-icu" owner to postgres;

create collation pg_catalog."lb-x-icu" (
    locale = 'lb'
    );

comment on collation pg_catalog."lb-x-icu" is 'Luxembourgish';

alter collation pg_catalog."lb-x-icu" owner to postgres;

create collation pg_catalog."lb-LU-x-icu" (
    locale = 'lb-LU'
    );

comment on collation pg_catalog."lb-LU-x-icu" is 'Luxembourgish (Luxembourg)';

alter collation pg_catalog."lb-LU-x-icu" owner to postgres;

create collation pg_catalog."lg-x-icu" (
    locale = 'lg'
    );

comment on collation pg_catalog."lg-x-icu" is 'Ganda';

alter collation pg_catalog."lg-x-icu" owner to postgres;

create collation pg_catalog."lg-UG-x-icu" (
    locale = 'lg-UG'
    );

comment on collation pg_catalog."lg-UG-x-icu" is 'Ganda (Uganda)';

alter collation pg_catalog."lg-UG-x-icu" owner to postgres;

create collation pg_catalog."lkt-x-icu" (
    locale = 'lkt'
    );

comment on collation pg_catalog."lkt-x-icu" is 'Lakota';

alter collation pg_catalog."lkt-x-icu" owner to postgres;

create collation pg_catalog."lkt-US-x-icu" (
    locale = 'lkt-US'
    );

comment on collation pg_catalog."lkt-US-x-icu" is 'Lakota (United States)';

alter collation pg_catalog."lkt-US-x-icu" owner to postgres;

create collation pg_catalog."ln-x-icu" (
    locale = 'ln'
    );

comment on collation pg_catalog."ln-x-icu" is 'Lingala';

alter collation pg_catalog."ln-x-icu" owner to postgres;

create collation pg_catalog."ln-AO-x-icu" (
    locale = 'ln-AO'
    );

comment on collation pg_catalog."ln-AO-x-icu" is 'Lingala (Angola)';

alter collation pg_catalog."ln-AO-x-icu" owner to postgres;

create collation pg_catalog."ln-CD-x-icu" (
    locale = 'ln-CD'
    );

comment on collation pg_catalog."ln-CD-x-icu" is 'Lingala (Congo - Kinshasa)';

alter collation pg_catalog."ln-CD-x-icu" owner to postgres;

create collation pg_catalog."ln-CF-x-icu" (
    locale = 'ln-CF'
    );

comment on collation pg_catalog."ln-CF-x-icu" is 'Lingala (Central African Republic)';

alter collation pg_catalog."ln-CF-x-icu" owner to postgres;

create collation pg_catalog."ln-CG-x-icu" (
    locale = 'ln-CG'
    );

comment on collation pg_catalog."ln-CG-x-icu" is 'Lingala (Congo - Brazzaville)';

alter collation pg_catalog."ln-CG-x-icu" owner to postgres;

create collation pg_catalog."lo-x-icu" (
    locale = 'lo'
    );

comment on collation pg_catalog."lo-x-icu" is 'Lao';

alter collation pg_catalog."lo-x-icu" owner to postgres;

create collation pg_catalog."lo-LA-x-icu" (
    locale = 'lo-LA'
    );

comment on collation pg_catalog."lo-LA-x-icu" is 'Lao (Laos)';

alter collation pg_catalog."lo-LA-x-icu" owner to postgres;

create collation pg_catalog."lrc-x-icu" (
    locale = 'lrc'
    );

comment on collation pg_catalog."lrc-x-icu" is 'Northern Luri';

alter collation pg_catalog."lrc-x-icu" owner to postgres;

create collation pg_catalog."lrc-IQ-x-icu" (
    locale = 'lrc-IQ'
    );

comment on collation pg_catalog."lrc-IQ-x-icu" is 'Northern Luri (Iraq)';

alter collation pg_catalog."lrc-IQ-x-icu" owner to postgres;

create collation pg_catalog."lrc-IR-x-icu" (
    locale = 'lrc-IR'
    );

comment on collation pg_catalog."lrc-IR-x-icu" is 'Northern Luri (Iran)';

alter collation pg_catalog."lrc-IR-x-icu" owner to postgres;

create collation pg_catalog."lt-x-icu" (
    locale = 'lt'
    );

comment on collation pg_catalog."lt-x-icu" is 'Lithuanian';

alter collation pg_catalog."lt-x-icu" owner to postgres;

create collation pg_catalog."lt-LT-x-icu" (
    locale = 'lt-LT'
    );

comment on collation pg_catalog."lt-LT-x-icu" is 'Lithuanian (Lithuania)';

alter collation pg_catalog."lt-LT-x-icu" owner to postgres;

create collation pg_catalog."lu-x-icu" (
    locale = 'lu'
    );

comment on collation pg_catalog."lu-x-icu" is 'Luba-Katanga';

alter collation pg_catalog."lu-x-icu" owner to postgres;

create collation pg_catalog."lu-CD-x-icu" (
    locale = 'lu-CD'
    );

comment on collation pg_catalog."lu-CD-x-icu" is 'Luba-Katanga (Congo - Kinshasa)';

alter collation pg_catalog."lu-CD-x-icu" owner to postgres;

create collation pg_catalog."luo-x-icu" (
    locale = 'luo'
    );

comment on collation pg_catalog."luo-x-icu" is 'Luo';

alter collation pg_catalog."luo-x-icu" owner to postgres;

create collation pg_catalog."luo-KE-x-icu" (
    locale = 'luo-KE'
    );

comment on collation pg_catalog."luo-KE-x-icu" is 'Luo (Kenya)';

alter collation pg_catalog."luo-KE-x-icu" owner to postgres;

create collation pg_catalog."luy-x-icu" (
    locale = 'luy'
    );

comment on collation pg_catalog."luy-x-icu" is 'Luyia';

alter collation pg_catalog."luy-x-icu" owner to postgres;

create collation pg_catalog."luy-KE-x-icu" (
    locale = 'luy-KE'
    );

comment on collation pg_catalog."luy-KE-x-icu" is 'Luyia (Kenya)';

alter collation pg_catalog."luy-KE-x-icu" owner to postgres;

create collation pg_catalog."lv-x-icu" (
    locale = 'lv'
    );

comment on collation pg_catalog."lv-x-icu" is 'Latvian';

alter collation pg_catalog."lv-x-icu" owner to postgres;

create collation pg_catalog."lv-LV-x-icu" (
    locale = 'lv-LV'
    );

comment on collation pg_catalog."lv-LV-x-icu" is 'Latvian (Latvia)';

alter collation pg_catalog."lv-LV-x-icu" owner to postgres;

create collation pg_catalog."mas-x-icu" (
    locale = 'mas'
    );

comment on collation pg_catalog."mas-x-icu" is 'Masai';

alter collation pg_catalog."mas-x-icu" owner to postgres;

create collation pg_catalog."mas-KE-x-icu" (
    locale = 'mas-KE'
    );

comment on collation pg_catalog."mas-KE-x-icu" is 'Masai (Kenya)';

alter collation pg_catalog."mas-KE-x-icu" owner to postgres;

create collation pg_catalog."mas-TZ-x-icu" (
    locale = 'mas-TZ'
    );

comment on collation pg_catalog."mas-TZ-x-icu" is 'Masai (Tanzania)';

alter collation pg_catalog."mas-TZ-x-icu" owner to postgres;

create collation pg_catalog."mer-x-icu" (
    locale = 'mer'
    );

comment on collation pg_catalog."mer-x-icu" is 'Meru';

alter collation pg_catalog."mer-x-icu" owner to postgres;

create collation pg_catalog."mer-KE-x-icu" (
    locale = 'mer-KE'
    );

comment on collation pg_catalog."mer-KE-x-icu" is 'Meru (Kenya)';

alter collation pg_catalog."mer-KE-x-icu" owner to postgres;

create collation pg_catalog."mfe-x-icu" (
    locale = 'mfe'
    );

comment on collation pg_catalog."mfe-x-icu" is 'Morisyen';

alter collation pg_catalog."mfe-x-icu" owner to postgres;

create collation pg_catalog."mfe-MU-x-icu" (
    locale = 'mfe-MU'
    );

comment on collation pg_catalog."mfe-MU-x-icu" is 'Morisyen (Mauritius)';

alter collation pg_catalog."mfe-MU-x-icu" owner to postgres;

create collation pg_catalog."mg-x-icu" (
    locale = 'mg'
    );

comment on collation pg_catalog."mg-x-icu" is 'Malagasy';

alter collation pg_catalog."mg-x-icu" owner to postgres;

create collation pg_catalog."mg-MG-x-icu" (
    locale = 'mg-MG'
    );

comment on collation pg_catalog."mg-MG-x-icu" is 'Malagasy (Madagascar)';

alter collation pg_catalog."mg-MG-x-icu" owner to postgres;

create collation pg_catalog."mgh-x-icu" (
    locale = 'mgh'
    );

comment on collation pg_catalog."mgh-x-icu" is 'Makhuwa-Meetto';

alter collation pg_catalog."mgh-x-icu" owner to postgres;

create collation pg_catalog."mgh-MZ-x-icu" (
    locale = 'mgh-MZ'
    );

comment on collation pg_catalog."mgh-MZ-x-icu" is 'Makhuwa-Meetto (Mozambique)';

alter collation pg_catalog."mgh-MZ-x-icu" owner to postgres;

create collation pg_catalog."mgo-x-icu" (
    locale = 'mgo'
    );

alter collation pg_catalog."mgo-x-icu" owner to postgres;

create collation pg_catalog."mgo-CM-x-icu" (
    locale = 'mgo-CM'
    );

alter collation pg_catalog."mgo-CM-x-icu" owner to postgres;

create collation pg_catalog."mi-x-icu" (
    locale = 'mi'
    );

comment on collation pg_catalog."mi-x-icu" is 'Maori';

alter collation pg_catalog."mi-x-icu" owner to postgres;

create collation pg_catalog."mi-NZ-x-icu" (
    locale = 'mi-NZ'
    );

comment on collation pg_catalog."mi-NZ-x-icu" is 'Maori (New Zealand)';

alter collation pg_catalog."mi-NZ-x-icu" owner to postgres;

create collation pg_catalog."mk-x-icu" (
    locale = 'mk'
    );

comment on collation pg_catalog."mk-x-icu" is 'Macedonian';

alter collation pg_catalog."mk-x-icu" owner to postgres;

create collation pg_catalog."mk-MK-x-icu" (
    locale = 'mk-MK'
    );

comment on collation pg_catalog."mk-MK-x-icu" is 'Macedonian (North Macedonia)';

alter collation pg_catalog."mk-MK-x-icu" owner to postgres;

create collation pg_catalog."ml-x-icu" (
    locale = 'ml'
    );

comment on collation pg_catalog."ml-x-icu" is 'Malayalam';

alter collation pg_catalog."ml-x-icu" owner to postgres;

create collation pg_catalog."ml-IN-x-icu" (
    locale = 'ml-IN'
    );

comment on collation pg_catalog."ml-IN-x-icu" is 'Malayalam (India)';

alter collation pg_catalog."ml-IN-x-icu" owner to postgres;

create collation pg_catalog."mn-x-icu" (
    locale = 'mn'
    );

comment on collation pg_catalog."mn-x-icu" is 'Mongolian';

alter collation pg_catalog."mn-x-icu" owner to postgres;

create collation pg_catalog."mn-MN-x-icu" (
    locale = 'mn-MN'
    );

comment on collation pg_catalog."mn-MN-x-icu" is 'Mongolian (Mongolia)';

alter collation pg_catalog."mn-MN-x-icu" owner to postgres;

create collation pg_catalog."mr-x-icu" (
    locale = 'mr'
    );

comment on collation pg_catalog."mr-x-icu" is 'Marathi';

alter collation pg_catalog."mr-x-icu" owner to postgres;

create collation pg_catalog."mr-IN-x-icu" (
    locale = 'mr-IN'
    );

comment on collation pg_catalog."mr-IN-x-icu" is 'Marathi (India)';

alter collation pg_catalog."mr-IN-x-icu" owner to postgres;

create collation pg_catalog."ms-x-icu" (
    locale = 'ms'
    );

comment on collation pg_catalog."ms-x-icu" is 'Malay';

alter collation pg_catalog."ms-x-icu" owner to postgres;

create collation pg_catalog."ms-BN-x-icu" (
    locale = 'ms-BN'
    );

comment on collation pg_catalog."ms-BN-x-icu" is 'Malay (Brunei)';

alter collation pg_catalog."ms-BN-x-icu" owner to postgres;

create collation pg_catalog."ms-MY-x-icu" (
    locale = 'ms-MY'
    );

comment on collation pg_catalog."ms-MY-x-icu" is 'Malay (Malaysia)';

alter collation pg_catalog."ms-MY-x-icu" owner to postgres;

create collation pg_catalog."ms-SG-x-icu" (
    locale = 'ms-SG'
    );

comment on collation pg_catalog."ms-SG-x-icu" is 'Malay (Singapore)';

alter collation pg_catalog."ms-SG-x-icu" owner to postgres;

create collation pg_catalog."mt-x-icu" (
    locale = 'mt'
    );

comment on collation pg_catalog."mt-x-icu" is 'Maltese';

alter collation pg_catalog."mt-x-icu" owner to postgres;

create collation pg_catalog."mt-MT-x-icu" (
    locale = 'mt-MT'
    );

comment on collation pg_catalog."mt-MT-x-icu" is 'Maltese (Malta)';

alter collation pg_catalog."mt-MT-x-icu" owner to postgres;

create collation pg_catalog."mua-x-icu" (
    locale = 'mua'
    );

comment on collation pg_catalog."mua-x-icu" is 'Mundang';

alter collation pg_catalog."mua-x-icu" owner to postgres;

create collation pg_catalog."mua-CM-x-icu" (
    locale = 'mua-CM'
    );

comment on collation pg_catalog."mua-CM-x-icu" is 'Mundang (Cameroon)';

alter collation pg_catalog."mua-CM-x-icu" owner to postgres;

create collation pg_catalog."my-x-icu" (
    locale = 'my'
    );

comment on collation pg_catalog."my-x-icu" is 'Burmese';

alter collation pg_catalog."my-x-icu" owner to postgres;

create collation pg_catalog."my-MM-x-icu" (
    locale = 'my-MM'
    );

comment on collation pg_catalog."my-MM-x-icu" is 'Burmese (Myanmar [Burma])';

alter collation pg_catalog."my-MM-x-icu" owner to postgres;

create collation pg_catalog."mzn-x-icu" (
    locale = 'mzn'
    );

comment on collation pg_catalog."mzn-x-icu" is 'Mazanderani';

alter collation pg_catalog."mzn-x-icu" owner to postgres;

create collation pg_catalog."mzn-IR-x-icu" (
    locale = 'mzn-IR'
    );

comment on collation pg_catalog."mzn-IR-x-icu" is 'Mazanderani (Iran)';

alter collation pg_catalog."mzn-IR-x-icu" owner to postgres;

create collation pg_catalog."naq-x-icu" (
    locale = 'naq'
    );

comment on collation pg_catalog."naq-x-icu" is 'Nama';

alter collation pg_catalog."naq-x-icu" owner to postgres;

create collation pg_catalog."naq-NA-x-icu" (
    locale = 'naq-NA'
    );

comment on collation pg_catalog."naq-NA-x-icu" is 'Nama (Namibia)';

alter collation pg_catalog."naq-NA-x-icu" owner to postgres;

create collation pg_catalog."nb-x-icu" (
    locale = 'nb'
    );

alter collation pg_catalog."nb-x-icu" owner to postgres;

create collation pg_catalog."nb-NO-x-icu" (
    locale = 'nb-NO'
    );

alter collation pg_catalog."nb-NO-x-icu" owner to postgres;

create collation pg_catalog."nb-SJ-x-icu" (
    locale = 'nb-SJ'
    );

alter collation pg_catalog."nb-SJ-x-icu" owner to postgres;

create collation pg_catalog."nd-x-icu" (
    locale = 'nd'
    );

comment on collation pg_catalog."nd-x-icu" is 'North Ndebele';

alter collation pg_catalog."nd-x-icu" owner to postgres;

create collation pg_catalog."nd-ZW-x-icu" (
    locale = 'nd-ZW'
    );

comment on collation pg_catalog."nd-ZW-x-icu" is 'North Ndebele (Zimbabwe)';

alter collation pg_catalog."nd-ZW-x-icu" owner to postgres;

create collation pg_catalog."nds-x-icu" (
    locale = 'nds'
    );

comment on collation pg_catalog."nds-x-icu" is 'Low German';

alter collation pg_catalog."nds-x-icu" owner to postgres;

create collation pg_catalog."nds-DE-x-icu" (
    locale = 'nds-DE'
    );

comment on collation pg_catalog."nds-DE-x-icu" is 'Low German (Germany)';

alter collation pg_catalog."nds-DE-x-icu" owner to postgres;

create collation pg_catalog."nds-NL-x-icu" (
    locale = 'nds-NL'
    );

comment on collation pg_catalog."nds-NL-x-icu" is 'Low German (Netherlands)';

alter collation pg_catalog."nds-NL-x-icu" owner to postgres;

create collation pg_catalog."ne-x-icu" (
    locale = 'ne'
    );

comment on collation pg_catalog."ne-x-icu" is 'Nepali';

alter collation pg_catalog."ne-x-icu" owner to postgres;

create collation pg_catalog."ne-IN-x-icu" (
    locale = 'ne-IN'
    );

comment on collation pg_catalog."ne-IN-x-icu" is 'Nepali (India)';

alter collation pg_catalog."ne-IN-x-icu" owner to postgres;

create collation pg_catalog."ne-NP-x-icu" (
    locale = 'ne-NP'
    );

comment on collation pg_catalog."ne-NP-x-icu" is 'Nepali (Nepal)';

alter collation pg_catalog."ne-NP-x-icu" owner to postgres;

create collation pg_catalog."nl-x-icu" (
    locale = 'nl'
    );

comment on collation pg_catalog."nl-x-icu" is 'Dutch';

alter collation pg_catalog."nl-x-icu" owner to postgres;

create collation pg_catalog."nl-AW-x-icu" (
    locale = 'nl-AW'
    );

comment on collation pg_catalog."nl-AW-x-icu" is 'Dutch (Aruba)';

alter collation pg_catalog."nl-AW-x-icu" owner to postgres;

create collation pg_catalog."nl-BE-x-icu" (
    locale = 'nl-BE'
    );

comment on collation pg_catalog."nl-BE-x-icu" is 'Dutch (Belgium)';

alter collation pg_catalog."nl-BE-x-icu" owner to postgres;

create collation pg_catalog."nl-BQ-x-icu" (
    locale = 'nl-BQ'
    );

comment on collation pg_catalog."nl-BQ-x-icu" is 'Dutch (Caribbean Netherlands)';

alter collation pg_catalog."nl-BQ-x-icu" owner to postgres;

create collation pg_catalog."nl-CW-x-icu" (
    locale = 'nl-CW'
    );

alter collation pg_catalog."nl-CW-x-icu" owner to postgres;

create collation pg_catalog."nl-NL-x-icu" (
    locale = 'nl-NL'
    );

comment on collation pg_catalog."nl-NL-x-icu" is 'Dutch (Netherlands)';

alter collation pg_catalog."nl-NL-x-icu" owner to postgres;

create collation pg_catalog."nl-SR-x-icu" (
    locale = 'nl-SR'
    );

comment on collation pg_catalog."nl-SR-x-icu" is 'Dutch (Suriname)';

alter collation pg_catalog."nl-SR-x-icu" owner to postgres;

create collation pg_catalog."nl-SX-x-icu" (
    locale = 'nl-SX'
    );

comment on collation pg_catalog."nl-SX-x-icu" is 'Dutch (Sint Maarten)';

alter collation pg_catalog."nl-SX-x-icu" owner to postgres;

create collation pg_catalog."nmg-x-icu" (
    locale = 'nmg'
    );

comment on collation pg_catalog."nmg-x-icu" is 'Kwasio';

alter collation pg_catalog."nmg-x-icu" owner to postgres;

create collation pg_catalog."nmg-CM-x-icu" (
    locale = 'nmg-CM'
    );

comment on collation pg_catalog."nmg-CM-x-icu" is 'Kwasio (Cameroon)';

alter collation pg_catalog."nmg-CM-x-icu" owner to postgres;

create collation pg_catalog."nn-x-icu" (
    locale = 'nn'
    );

comment on collation pg_catalog."nn-x-icu" is 'Norwegian Nynorsk';

alter collation pg_catalog."nn-x-icu" owner to postgres;

create collation pg_catalog."nn-NO-x-icu" (
    locale = 'nn-NO'
    );

comment on collation pg_catalog."nn-NO-x-icu" is 'Norwegian Nynorsk (Norway)';

alter collation pg_catalog."nn-NO-x-icu" owner to postgres;

create collation pg_catalog."nnh-x-icu" (
    locale = 'nnh'
    );

comment on collation pg_catalog."nnh-x-icu" is 'Ngiemboon';

alter collation pg_catalog."nnh-x-icu" owner to postgres;

create collation pg_catalog."nnh-CM-x-icu" (
    locale = 'nnh-CM'
    );

comment on collation pg_catalog."nnh-CM-x-icu" is 'Ngiemboon (Cameroon)';

alter collation pg_catalog."nnh-CM-x-icu" owner to postgres;

create collation pg_catalog."nus-x-icu" (
    locale = 'nus'
    );

comment on collation pg_catalog."nus-x-icu" is 'Nuer';

alter collation pg_catalog."nus-x-icu" owner to postgres;

create collation pg_catalog."nus-SS-x-icu" (
    locale = 'nus-SS'
    );

comment on collation pg_catalog."nus-SS-x-icu" is 'Nuer (South Sudan)';

alter collation pg_catalog."nus-SS-x-icu" owner to postgres;

create collation pg_catalog."nyn-x-icu" (
    locale = 'nyn'
    );

comment on collation pg_catalog."nyn-x-icu" is 'Nyankole';

alter collation pg_catalog."nyn-x-icu" owner to postgres;

create collation pg_catalog."nyn-UG-x-icu" (
    locale = 'nyn-UG'
    );

comment on collation pg_catalog."nyn-UG-x-icu" is 'Nyankole (Uganda)';

alter collation pg_catalog."nyn-UG-x-icu" owner to postgres;

create collation pg_catalog."om-x-icu" (
    locale = 'om'
    );

comment on collation pg_catalog."om-x-icu" is 'Oromo';

alter collation pg_catalog."om-x-icu" owner to postgres;

create collation pg_catalog."om-ET-x-icu" (
    locale = 'om-ET'
    );

comment on collation pg_catalog."om-ET-x-icu" is 'Oromo (Ethiopia)';

alter collation pg_catalog."om-ET-x-icu" owner to postgres;

create collation pg_catalog."om-KE-x-icu" (
    locale = 'om-KE'
    );

comment on collation pg_catalog."om-KE-x-icu" is 'Oromo (Kenya)';

alter collation pg_catalog."om-KE-x-icu" owner to postgres;

create collation pg_catalog."or-x-icu" (
    locale = 'or'
    );

comment on collation pg_catalog."or-x-icu" is 'Odia';

alter collation pg_catalog."or-x-icu" owner to postgres;

create collation pg_catalog."or-IN-x-icu" (
    locale = 'or-IN'
    );

comment on collation pg_catalog."or-IN-x-icu" is 'Odia (India)';

alter collation pg_catalog."or-IN-x-icu" owner to postgres;

create collation pg_catalog."os-x-icu" (
    locale = 'os'
    );

comment on collation pg_catalog."os-x-icu" is 'Ossetic';

alter collation pg_catalog."os-x-icu" owner to postgres;

create collation pg_catalog."os-GE-x-icu" (
    locale = 'os-GE'
    );

comment on collation pg_catalog."os-GE-x-icu" is 'Ossetic (Georgia)';

alter collation pg_catalog."os-GE-x-icu" owner to postgres;

create collation pg_catalog."os-RU-x-icu" (
    locale = 'os-RU'
    );

comment on collation pg_catalog."os-RU-x-icu" is 'Ossetic (Russia)';

alter collation pg_catalog."os-RU-x-icu" owner to postgres;

create collation pg_catalog."pa-x-icu" (
    locale = 'pa'
    );

comment on collation pg_catalog."pa-x-icu" is 'Punjabi';

alter collation pg_catalog."pa-x-icu" owner to postgres;

create collation pg_catalog."pa-Arab-x-icu" (
    locale = 'pa-Arab'
    );

comment on collation pg_catalog."pa-Arab-x-icu" is 'Punjabi (Arabic)';

alter collation pg_catalog."pa-Arab-x-icu" owner to postgres;

create collation pg_catalog."pa-Arab-PK-x-icu" (
    locale = 'pa-Arab-PK'
    );

comment on collation pg_catalog."pa-Arab-PK-x-icu" is 'Punjabi (Arabic, Pakistan)';

alter collation pg_catalog."pa-Arab-PK-x-icu" owner to postgres;

create collation pg_catalog."pa-Guru-x-icu" (
    locale = 'pa-Guru'
    );

comment on collation pg_catalog."pa-Guru-x-icu" is 'Punjabi (Gurmukhi)';

alter collation pg_catalog."pa-Guru-x-icu" owner to postgres;

create collation pg_catalog."pa-Guru-IN-x-icu" (
    locale = 'pa-Guru-IN'
    );

comment on collation pg_catalog."pa-Guru-IN-x-icu" is 'Punjabi (Gurmukhi, India)';

alter collation pg_catalog."pa-Guru-IN-x-icu" owner to postgres;

create collation pg_catalog."pl-x-icu" (
    locale = 'pl'
    );

comment on collation pg_catalog."pl-x-icu" is 'Polish';

alter collation pg_catalog."pl-x-icu" owner to postgres;

create collation pg_catalog."pl-PL-x-icu" (
    locale = 'pl-PL'
    );

comment on collation pg_catalog."pl-PL-x-icu" is 'Polish (Poland)';

alter collation pg_catalog."pl-PL-x-icu" owner to postgres;

create collation pg_catalog."ps-x-icu" (
    locale = 'ps'
    );

comment on collation pg_catalog."ps-x-icu" is 'Pashto';

alter collation pg_catalog."ps-x-icu" owner to postgres;

create collation pg_catalog."ps-AF-x-icu" (
    locale = 'ps-AF'
    );

comment on collation pg_catalog."ps-AF-x-icu" is 'Pashto (Afghanistan)';

alter collation pg_catalog."ps-AF-x-icu" owner to postgres;

create collation pg_catalog."ps-PK-x-icu" (
    locale = 'ps-PK'
    );

comment on collation pg_catalog."ps-PK-x-icu" is 'Pashto (Pakistan)';

alter collation pg_catalog."ps-PK-x-icu" owner to postgres;

create collation pg_catalog."pt-x-icu" (
    locale = 'pt'
    );

comment on collation pg_catalog."pt-x-icu" is 'Portuguese';

alter collation pg_catalog."pt-x-icu" owner to postgres;

create collation pg_catalog."pt-AO-x-icu" (
    locale = 'pt-AO'
    );

comment on collation pg_catalog."pt-AO-x-icu" is 'Portuguese (Angola)';

alter collation pg_catalog."pt-AO-x-icu" owner to postgres;

create collation pg_catalog."pt-BR-x-icu" (
    locale = 'pt-BR'
    );

comment on collation pg_catalog."pt-BR-x-icu" is 'Portuguese (Brazil)';

alter collation pg_catalog."pt-BR-x-icu" owner to postgres;

create collation pg_catalog."pt-CH-x-icu" (
    locale = 'pt-CH'
    );

comment on collation pg_catalog."pt-CH-x-icu" is 'Portuguese (Switzerland)';

alter collation pg_catalog."pt-CH-x-icu" owner to postgres;

create collation pg_catalog."pt-CV-x-icu" (
    locale = 'pt-CV'
    );

comment on collation pg_catalog."pt-CV-x-icu" is 'Portuguese (Cape Verde)';

alter collation pg_catalog."pt-CV-x-icu" owner to postgres;

create collation pg_catalog."pt-GQ-x-icu" (
    locale = 'pt-GQ'
    );

comment on collation pg_catalog."pt-GQ-x-icu" is 'Portuguese (Equatorial Guinea)';

alter collation pg_catalog."pt-GQ-x-icu" owner to postgres;

create collation pg_catalog."pt-GW-x-icu" (
    locale = 'pt-GW'
    );

comment on collation pg_catalog."pt-GW-x-icu" is 'Portuguese (Guinea-Bissau)';

alter collation pg_catalog."pt-GW-x-icu" owner to postgres;

create collation pg_catalog."pt-LU-x-icu" (
    locale = 'pt-LU'
    );

comment on collation pg_catalog."pt-LU-x-icu" is 'Portuguese (Luxembourg)';

alter collation pg_catalog."pt-LU-x-icu" owner to postgres;

create collation pg_catalog."pt-MO-x-icu" (
    locale = 'pt-MO'
    );

comment on collation pg_catalog."pt-MO-x-icu" is 'Portuguese (Macao SAR China)';

alter collation pg_catalog."pt-MO-x-icu" owner to postgres;

create collation pg_catalog."pt-MZ-x-icu" (
    locale = 'pt-MZ'
    );

comment on collation pg_catalog."pt-MZ-x-icu" is 'Portuguese (Mozambique)';

alter collation pg_catalog."pt-MZ-x-icu" owner to postgres;

create collation pg_catalog."pt-PT-x-icu" (
    locale = 'pt-PT'
    );

comment on collation pg_catalog."pt-PT-x-icu" is 'Portuguese (Portugal)';

alter collation pg_catalog."pt-PT-x-icu" owner to postgres;

create collation pg_catalog."pt-ST-x-icu" (
    locale = 'pt-ST'
    );

alter collation pg_catalog."pt-ST-x-icu" owner to postgres;

create collation pg_catalog."pt-TL-x-icu" (
    locale = 'pt-TL'
    );

comment on collation pg_catalog."pt-TL-x-icu" is 'Portuguese (Timor-Leste)';

alter collation pg_catalog."pt-TL-x-icu" owner to postgres;

create collation pg_catalog."qu-x-icu" (
    locale = 'qu'
    );

comment on collation pg_catalog."qu-x-icu" is 'Quechua';

alter collation pg_catalog."qu-x-icu" owner to postgres;

create collation pg_catalog."qu-BO-x-icu" (
    locale = 'qu-BO'
    );

comment on collation pg_catalog."qu-BO-x-icu" is 'Quechua (Bolivia)';

alter collation pg_catalog."qu-BO-x-icu" owner to postgres;

create collation pg_catalog."qu-EC-x-icu" (
    locale = 'qu-EC'
    );

comment on collation pg_catalog."qu-EC-x-icu" is 'Quechua (Ecuador)';

alter collation pg_catalog."qu-EC-x-icu" owner to postgres;

create collation pg_catalog."qu-PE-x-icu" (
    locale = 'qu-PE'
    );

comment on collation pg_catalog."qu-PE-x-icu" is 'Quechua (Peru)';

alter collation pg_catalog."qu-PE-x-icu" owner to postgres;

create collation pg_catalog."rm-x-icu" (
    locale = 'rm'
    );

comment on collation pg_catalog."rm-x-icu" is 'Romansh';

alter collation pg_catalog."rm-x-icu" owner to postgres;

create collation pg_catalog."rm-CH-x-icu" (
    locale = 'rm-CH'
    );

comment on collation pg_catalog."rm-CH-x-icu" is 'Romansh (Switzerland)';

alter collation pg_catalog."rm-CH-x-icu" owner to postgres;

create collation pg_catalog."rn-x-icu" (
    locale = 'rn'
    );

comment on collation pg_catalog."rn-x-icu" is 'Rundi';

alter collation pg_catalog."rn-x-icu" owner to postgres;

create collation pg_catalog."rn-BI-x-icu" (
    locale = 'rn-BI'
    );

comment on collation pg_catalog."rn-BI-x-icu" is 'Rundi (Burundi)';

alter collation pg_catalog."rn-BI-x-icu" owner to postgres;

create collation pg_catalog."ro-x-icu" (
    locale = 'ro'
    );

comment on collation pg_catalog."ro-x-icu" is 'Romanian';

alter collation pg_catalog."ro-x-icu" owner to postgres;

create collation pg_catalog."ro-MD-x-icu" (
    locale = 'ro-MD'
    );

comment on collation pg_catalog."ro-MD-x-icu" is 'Romanian (Moldova)';

alter collation pg_catalog."ro-MD-x-icu" owner to postgres;

create collation pg_catalog."ro-RO-x-icu" (
    locale = 'ro-RO'
    );

comment on collation pg_catalog."ro-RO-x-icu" is 'Romanian (Romania)';

alter collation pg_catalog."ro-RO-x-icu" owner to postgres;

create collation pg_catalog."rof-x-icu" (
    locale = 'rof'
    );

comment on collation pg_catalog."rof-x-icu" is 'Rombo';

alter collation pg_catalog."rof-x-icu" owner to postgres;

create collation pg_catalog."rof-TZ-x-icu" (
    locale = 'rof-TZ'
    );

comment on collation pg_catalog."rof-TZ-x-icu" is 'Rombo (Tanzania)';

alter collation pg_catalog."rof-TZ-x-icu" owner to postgres;

create collation pg_catalog."ru-x-icu" (
    locale = 'ru'
    );

comment on collation pg_catalog."ru-x-icu" is 'Russian';

alter collation pg_catalog."ru-x-icu" owner to postgres;

create collation pg_catalog."ru-BY-x-icu" (
    locale = 'ru-BY'
    );

comment on collation pg_catalog."ru-BY-x-icu" is 'Russian (Belarus)';

alter collation pg_catalog."ru-BY-x-icu" owner to postgres;

create collation pg_catalog."ru-KG-x-icu" (
    locale = 'ru-KG'
    );

comment on collation pg_catalog."ru-KG-x-icu" is 'Russian (Kyrgyzstan)';

alter collation pg_catalog."ru-KG-x-icu" owner to postgres;

create collation pg_catalog."ru-KZ-x-icu" (
    locale = 'ru-KZ'
    );

comment on collation pg_catalog."ru-KZ-x-icu" is 'Russian (Kazakhstan)';

alter collation pg_catalog."ru-KZ-x-icu" owner to postgres;

create collation pg_catalog."ru-MD-x-icu" (
    locale = 'ru-MD'
    );

comment on collation pg_catalog."ru-MD-x-icu" is 'Russian (Moldova)';

alter collation pg_catalog."ru-MD-x-icu" owner to postgres;

create collation pg_catalog."ru-RU-x-icu" (
    locale = 'ru-RU'
    );

comment on collation pg_catalog."ru-RU-x-icu" is 'Russian (Russia)';

alter collation pg_catalog."ru-RU-x-icu" owner to postgres;

create collation pg_catalog."ru-UA-x-icu" (
    locale = 'ru-UA'
    );

comment on collation pg_catalog."ru-UA-x-icu" is 'Russian (Ukraine)';

alter collation pg_catalog."ru-UA-x-icu" owner to postgres;

create collation pg_catalog."rw-x-icu" (
    locale = 'rw'
    );

comment on collation pg_catalog."rw-x-icu" is 'Kinyarwanda';

alter collation pg_catalog."rw-x-icu" owner to postgres;

create collation pg_catalog."rw-RW-x-icu" (
    locale = 'rw-RW'
    );

comment on collation pg_catalog."rw-RW-x-icu" is 'Kinyarwanda (Rwanda)';

alter collation pg_catalog."rw-RW-x-icu" owner to postgres;

create collation pg_catalog."rwk-x-icu" (
    locale = 'rwk'
    );

comment on collation pg_catalog."rwk-x-icu" is 'Rwa';

alter collation pg_catalog."rwk-x-icu" owner to postgres;

create collation pg_catalog."rwk-TZ-x-icu" (
    locale = 'rwk-TZ'
    );

comment on collation pg_catalog."rwk-TZ-x-icu" is 'Rwa (Tanzania)';

alter collation pg_catalog."rwk-TZ-x-icu" owner to postgres;

create collation pg_catalog."sah-x-icu" (
    locale = 'sah'
    );

comment on collation pg_catalog."sah-x-icu" is 'Sakha';

alter collation pg_catalog."sah-x-icu" owner to postgres;

create collation pg_catalog."sah-RU-x-icu" (
    locale = 'sah-RU'
    );

comment on collation pg_catalog."sah-RU-x-icu" is 'Sakha (Russia)';

alter collation pg_catalog."sah-RU-x-icu" owner to postgres;

create collation pg_catalog."saq-x-icu" (
    locale = 'saq'
    );

comment on collation pg_catalog."saq-x-icu" is 'Samburu';

alter collation pg_catalog."saq-x-icu" owner to postgres;

create collation pg_catalog."saq-KE-x-icu" (
    locale = 'saq-KE'
    );

comment on collation pg_catalog."saq-KE-x-icu" is 'Samburu (Kenya)';

alter collation pg_catalog."saq-KE-x-icu" owner to postgres;

create collation pg_catalog."sbp-x-icu" (
    locale = 'sbp'
    );

comment on collation pg_catalog."sbp-x-icu" is 'Sangu';

alter collation pg_catalog."sbp-x-icu" owner to postgres;

create collation pg_catalog."sbp-TZ-x-icu" (
    locale = 'sbp-TZ'
    );

comment on collation pg_catalog."sbp-TZ-x-icu" is 'Sangu (Tanzania)';

alter collation pg_catalog."sbp-TZ-x-icu" owner to postgres;

create collation pg_catalog."sd-x-icu" (
    locale = 'sd'
    );

comment on collation pg_catalog."sd-x-icu" is 'Sindhi';

alter collation pg_catalog."sd-x-icu" owner to postgres;

create collation pg_catalog."sd-PK-x-icu" (
    locale = 'sd-PK'
    );

comment on collation pg_catalog."sd-PK-x-icu" is 'Sindhi (Pakistan)';

alter collation pg_catalog."sd-PK-x-icu" owner to postgres;

create collation pg_catalog."se-x-icu" (
    locale = 'se'
    );

comment on collation pg_catalog."se-x-icu" is 'Northern Sami';

alter collation pg_catalog."se-x-icu" owner to postgres;

create collation pg_catalog."se-FI-x-icu" (
    locale = 'se-FI'
    );

comment on collation pg_catalog."se-FI-x-icu" is 'Northern Sami (Finland)';

alter collation pg_catalog."se-FI-x-icu" owner to postgres;

create collation pg_catalog."se-NO-x-icu" (
    locale = 'se-NO'
    );

comment on collation pg_catalog."se-NO-x-icu" is 'Northern Sami (Norway)';

alter collation pg_catalog."se-NO-x-icu" owner to postgres;

create collation pg_catalog."se-SE-x-icu" (
    locale = 'se-SE'
    );

comment on collation pg_catalog."se-SE-x-icu" is 'Northern Sami (Sweden)';

alter collation pg_catalog."se-SE-x-icu" owner to postgres;

create collation pg_catalog."seh-x-icu" (
    locale = 'seh'
    );

comment on collation pg_catalog."seh-x-icu" is 'Sena';

alter collation pg_catalog."seh-x-icu" owner to postgres;

create collation pg_catalog."seh-MZ-x-icu" (
    locale = 'seh-MZ'
    );

comment on collation pg_catalog."seh-MZ-x-icu" is 'Sena (Mozambique)';

alter collation pg_catalog."seh-MZ-x-icu" owner to postgres;

create collation pg_catalog."ses-x-icu" (
    locale = 'ses'
    );

comment on collation pg_catalog."ses-x-icu" is 'Koyraboro Senni';

alter collation pg_catalog."ses-x-icu" owner to postgres;

create collation pg_catalog."ses-ML-x-icu" (
    locale = 'ses-ML'
    );

comment on collation pg_catalog."ses-ML-x-icu" is 'Koyraboro Senni (Mali)';

alter collation pg_catalog."ses-ML-x-icu" owner to postgres;

create collation pg_catalog."sg-x-icu" (
    locale = 'sg'
    );

comment on collation pg_catalog."sg-x-icu" is 'Sango';

alter collation pg_catalog."sg-x-icu" owner to postgres;

create collation pg_catalog."sg-CF-x-icu" (
    locale = 'sg-CF'
    );

comment on collation pg_catalog."sg-CF-x-icu" is 'Sango (Central African Republic)';

alter collation pg_catalog."sg-CF-x-icu" owner to postgres;

create collation pg_catalog."shi-x-icu" (
    locale = 'shi'
    );

comment on collation pg_catalog."shi-x-icu" is 'Tachelhit';

alter collation pg_catalog."shi-x-icu" owner to postgres;

create collation pg_catalog."shi-Latn-x-icu" (
    locale = 'shi-Latn'
    );

comment on collation pg_catalog."shi-Latn-x-icu" is 'Tachelhit (Latin)';

alter collation pg_catalog."shi-Latn-x-icu" owner to postgres;

create collation pg_catalog."shi-Latn-MA-x-icu" (
    locale = 'shi-Latn-MA'
    );

comment on collation pg_catalog."shi-Latn-MA-x-icu" is 'Tachelhit (Latin, Morocco)';

alter collation pg_catalog."shi-Latn-MA-x-icu" owner to postgres;

create collation pg_catalog."shi-Tfng-x-icu" (
    locale = 'shi-Tfng'
    );

comment on collation pg_catalog."shi-Tfng-x-icu" is 'Tachelhit (Tifinagh)';

alter collation pg_catalog."shi-Tfng-x-icu" owner to postgres;

create collation pg_catalog."shi-Tfng-MA-x-icu" (
    locale = 'shi-Tfng-MA'
    );

comment on collation pg_catalog."shi-Tfng-MA-x-icu" is 'Tachelhit (Tifinagh, Morocco)';

alter collation pg_catalog."shi-Tfng-MA-x-icu" owner to postgres;

create collation pg_catalog."si-x-icu" (
    locale = 'si'
    );

comment on collation pg_catalog."si-x-icu" is 'Sinhala';

alter collation pg_catalog."si-x-icu" owner to postgres;

create collation pg_catalog."si-LK-x-icu" (
    locale = 'si-LK'
    );

comment on collation pg_catalog."si-LK-x-icu" is 'Sinhala (Sri Lanka)';

alter collation pg_catalog."si-LK-x-icu" owner to postgres;

create collation pg_catalog."sk-x-icu" (
    locale = 'sk'
    );

comment on collation pg_catalog."sk-x-icu" is 'Slovak';

alter collation pg_catalog."sk-x-icu" owner to postgres;

create collation pg_catalog."sk-SK-x-icu" (
    locale = 'sk-SK'
    );

comment on collation pg_catalog."sk-SK-x-icu" is 'Slovak (Slovakia)';

alter collation pg_catalog."sk-SK-x-icu" owner to postgres;

create collation pg_catalog."sl-x-icu" (
    locale = 'sl'
    );

comment on collation pg_catalog."sl-x-icu" is 'Slovenian';

alter collation pg_catalog."sl-x-icu" owner to postgres;

create collation pg_catalog."sl-SI-x-icu" (
    locale = 'sl-SI'
    );

comment on collation pg_catalog."sl-SI-x-icu" is 'Slovenian (Slovenia)';

alter collation pg_catalog."sl-SI-x-icu" owner to postgres;

create collation pg_catalog."smn-x-icu" (
    locale = 'smn'
    );

comment on collation pg_catalog."smn-x-icu" is 'Inari Sami';

alter collation pg_catalog."smn-x-icu" owner to postgres;

create collation pg_catalog."smn-FI-x-icu" (
    locale = 'smn-FI'
    );

comment on collation pg_catalog."smn-FI-x-icu" is 'Inari Sami (Finland)';

alter collation pg_catalog."smn-FI-x-icu" owner to postgres;

create collation pg_catalog."sn-x-icu" (
    locale = 'sn'
    );

comment on collation pg_catalog."sn-x-icu" is 'Shona';

alter collation pg_catalog."sn-x-icu" owner to postgres;

create collation pg_catalog."sn-ZW-x-icu" (
    locale = 'sn-ZW'
    );

comment on collation pg_catalog."sn-ZW-x-icu" is 'Shona (Zimbabwe)';

alter collation pg_catalog."sn-ZW-x-icu" owner to postgres;

create collation pg_catalog."so-x-icu" (
    locale = 'so'
    );

comment on collation pg_catalog."so-x-icu" is 'Somali';

alter collation pg_catalog."so-x-icu" owner to postgres;

create collation pg_catalog."so-DJ-x-icu" (
    locale = 'so-DJ'
    );

comment on collation pg_catalog."so-DJ-x-icu" is 'Somali (Djibouti)';

alter collation pg_catalog."so-DJ-x-icu" owner to postgres;

create collation pg_catalog."so-ET-x-icu" (
    locale = 'so-ET'
    );

comment on collation pg_catalog."so-ET-x-icu" is 'Somali (Ethiopia)';

alter collation pg_catalog."so-ET-x-icu" owner to postgres;

create collation pg_catalog."so-KE-x-icu" (
    locale = 'so-KE'
    );

comment on collation pg_catalog."so-KE-x-icu" is 'Somali (Kenya)';

alter collation pg_catalog."so-KE-x-icu" owner to postgres;

create collation pg_catalog."so-SO-x-icu" (
    locale = 'so-SO'
    );

comment on collation pg_catalog."so-SO-x-icu" is 'Somali (Somalia)';

alter collation pg_catalog."so-SO-x-icu" owner to postgres;

create collation pg_catalog."sq-x-icu" (
    locale = 'sq'
    );

comment on collation pg_catalog."sq-x-icu" is 'Albanian';

alter collation pg_catalog."sq-x-icu" owner to postgres;

create collation pg_catalog."sq-AL-x-icu" (
    locale = 'sq-AL'
    );

comment on collation pg_catalog."sq-AL-x-icu" is 'Albanian (Albania)';

alter collation pg_catalog."sq-AL-x-icu" owner to postgres;

create collation pg_catalog."sq-MK-x-icu" (
    locale = 'sq-MK'
    );

comment on collation pg_catalog."sq-MK-x-icu" is 'Albanian (North Macedonia)';

alter collation pg_catalog."sq-MK-x-icu" owner to postgres;

create collation pg_catalog."sq-XK-x-icu" (
    locale = 'sq-XK'
    );

comment on collation pg_catalog."sq-XK-x-icu" is 'Albanian (Kosovo)';

alter collation pg_catalog."sq-XK-x-icu" owner to postgres;

create collation pg_catalog."sr-x-icu" (
    locale = 'sr'
    );

comment on collation pg_catalog."sr-x-icu" is 'Serbian';

alter collation pg_catalog."sr-x-icu" owner to postgres;

create collation pg_catalog."sr-Cyrl-x-icu" (
    locale = 'sr-Cyrl'
    );

comment on collation pg_catalog."sr-Cyrl-x-icu" is 'Serbian (Cyrillic)';

alter collation pg_catalog."sr-Cyrl-x-icu" owner to postgres;

create collation pg_catalog."sr-Cyrl-BA-x-icu" (
    locale = 'sr-Cyrl-BA'
    );

comment on collation pg_catalog."sr-Cyrl-BA-x-icu" is 'Serbian (Cyrillic, Bosnia & Herzegovina)';

alter collation pg_catalog."sr-Cyrl-BA-x-icu" owner to postgres;

create collation pg_catalog."sr-Cyrl-ME-x-icu" (
    locale = 'sr-Cyrl-ME'
    );

comment on collation pg_catalog."sr-Cyrl-ME-x-icu" is 'Serbian (Cyrillic, Montenegro)';

alter collation pg_catalog."sr-Cyrl-ME-x-icu" owner to postgres;

create collation pg_catalog."sr-Cyrl-RS-x-icu" (
    locale = 'sr-Cyrl-RS'
    );

comment on collation pg_catalog."sr-Cyrl-RS-x-icu" is 'Serbian (Cyrillic, Serbia)';

alter collation pg_catalog."sr-Cyrl-RS-x-icu" owner to postgres;

create collation pg_catalog."sr-Cyrl-XK-x-icu" (
    locale = 'sr-Cyrl-XK'
    );

comment on collation pg_catalog."sr-Cyrl-XK-x-icu" is 'Serbian (Cyrillic, Kosovo)';

alter collation pg_catalog."sr-Cyrl-XK-x-icu" owner to postgres;

create collation pg_catalog."sr-Latn-x-icu" (
    locale = 'sr-Latn'
    );

comment on collation pg_catalog."sr-Latn-x-icu" is 'Serbian (Latin)';

alter collation pg_catalog."sr-Latn-x-icu" owner to postgres;

create collation pg_catalog."sr-Latn-BA-x-icu" (
    locale = 'sr-Latn-BA'
    );

comment on collation pg_catalog."sr-Latn-BA-x-icu" is 'Serbian (Latin, Bosnia & Herzegovina)';

alter collation pg_catalog."sr-Latn-BA-x-icu" owner to postgres;

create collation pg_catalog."sr-Latn-ME-x-icu" (
    locale = 'sr-Latn-ME'
    );

comment on collation pg_catalog."sr-Latn-ME-x-icu" is 'Serbian (Latin, Montenegro)';

alter collation pg_catalog."sr-Latn-ME-x-icu" owner to postgres;

create collation pg_catalog."sr-Latn-RS-x-icu" (
    locale = 'sr-Latn-RS'
    );

comment on collation pg_catalog."sr-Latn-RS-x-icu" is 'Serbian (Latin, Serbia)';

alter collation pg_catalog."sr-Latn-RS-x-icu" owner to postgres;

create collation pg_catalog."sr-Latn-XK-x-icu" (
    locale = 'sr-Latn-XK'
    );

comment on collation pg_catalog."sr-Latn-XK-x-icu" is 'Serbian (Latin, Kosovo)';

alter collation pg_catalog."sr-Latn-XK-x-icu" owner to postgres;

create collation pg_catalog."sv-x-icu" (
    locale = 'sv'
    );

comment on collation pg_catalog."sv-x-icu" is 'Swedish';

alter collation pg_catalog."sv-x-icu" owner to postgres;

create collation pg_catalog."sv-AX-x-icu" (
    locale = 'sv-AX'
    );

alter collation pg_catalog."sv-AX-x-icu" owner to postgres;

create collation pg_catalog."sv-FI-x-icu" (
    locale = 'sv-FI'
    );

comment on collation pg_catalog."sv-FI-x-icu" is 'Swedish (Finland)';

alter collation pg_catalog."sv-FI-x-icu" owner to postgres;

create collation pg_catalog."sv-SE-x-icu" (
    locale = 'sv-SE'
    );

comment on collation pg_catalog."sv-SE-x-icu" is 'Swedish (Sweden)';

alter collation pg_catalog."sv-SE-x-icu" owner to postgres;

create collation pg_catalog."sw-x-icu" (
    locale = 'sw'
    );

comment on collation pg_catalog."sw-x-icu" is 'Swahili';

alter collation pg_catalog."sw-x-icu" owner to postgres;

create collation pg_catalog."sw-CD-x-icu" (
    locale = 'sw-CD'
    );

comment on collation pg_catalog."sw-CD-x-icu" is 'Swahili (Congo - Kinshasa)';

alter collation pg_catalog."sw-CD-x-icu" owner to postgres;

create collation pg_catalog."sw-KE-x-icu" (
    locale = 'sw-KE'
    );

comment on collation pg_catalog."sw-KE-x-icu" is 'Swahili (Kenya)';

alter collation pg_catalog."sw-KE-x-icu" owner to postgres;

create collation pg_catalog."sw-TZ-x-icu" (
    locale = 'sw-TZ'
    );

comment on collation pg_catalog."sw-TZ-x-icu" is 'Swahili (Tanzania)';

alter collation pg_catalog."sw-TZ-x-icu" owner to postgres;

create collation pg_catalog."sw-UG-x-icu" (
    locale = 'sw-UG'
    );

comment on collation pg_catalog."sw-UG-x-icu" is 'Swahili (Uganda)';

alter collation pg_catalog."sw-UG-x-icu" owner to postgres;

create collation pg_catalog."ta-x-icu" (
    locale = 'ta'
    );

comment on collation pg_catalog."ta-x-icu" is 'Tamil';

alter collation pg_catalog."ta-x-icu" owner to postgres;

create collation pg_catalog."ta-IN-x-icu" (
    locale = 'ta-IN'
    );

comment on collation pg_catalog."ta-IN-x-icu" is 'Tamil (India)';

alter collation pg_catalog."ta-IN-x-icu" owner to postgres;

create collation pg_catalog."ta-LK-x-icu" (
    locale = 'ta-LK'
    );

comment on collation pg_catalog."ta-LK-x-icu" is 'Tamil (Sri Lanka)';

alter collation pg_catalog."ta-LK-x-icu" owner to postgres;

create collation pg_catalog."ta-MY-x-icu" (
    locale = 'ta-MY'
    );

comment on collation pg_catalog."ta-MY-x-icu" is 'Tamil (Malaysia)';

alter collation pg_catalog."ta-MY-x-icu" owner to postgres;

create collation pg_catalog."ta-SG-x-icu" (
    locale = 'ta-SG'
    );

comment on collation pg_catalog."ta-SG-x-icu" is 'Tamil (Singapore)';

alter collation pg_catalog."ta-SG-x-icu" owner to postgres;

create collation pg_catalog."te-x-icu" (
    locale = 'te'
    );

comment on collation pg_catalog."te-x-icu" is 'Telugu';

alter collation pg_catalog."te-x-icu" owner to postgres;

create collation pg_catalog."te-IN-x-icu" (
    locale = 'te-IN'
    );

comment on collation pg_catalog."te-IN-x-icu" is 'Telugu (India)';

alter collation pg_catalog."te-IN-x-icu" owner to postgres;

create collation pg_catalog."teo-x-icu" (
    locale = 'teo'
    );

comment on collation pg_catalog."teo-x-icu" is 'Teso';

alter collation pg_catalog."teo-x-icu" owner to postgres;

create collation pg_catalog."teo-KE-x-icu" (
    locale = 'teo-KE'
    );

comment on collation pg_catalog."teo-KE-x-icu" is 'Teso (Kenya)';

alter collation pg_catalog."teo-KE-x-icu" owner to postgres;

create collation pg_catalog."teo-UG-x-icu" (
    locale = 'teo-UG'
    );

comment on collation pg_catalog."teo-UG-x-icu" is 'Teso (Uganda)';

alter collation pg_catalog."teo-UG-x-icu" owner to postgres;

create collation pg_catalog."tg-x-icu" (
    locale = 'tg'
    );

comment on collation pg_catalog."tg-x-icu" is 'Tajik';

alter collation pg_catalog."tg-x-icu" owner to postgres;

create collation pg_catalog."tg-TJ-x-icu" (
    locale = 'tg-TJ'
    );

comment on collation pg_catalog."tg-TJ-x-icu" is 'Tajik (Tajikistan)';

alter collation pg_catalog."tg-TJ-x-icu" owner to postgres;

create collation pg_catalog."th-x-icu" (
    locale = 'th'
    );

comment on collation pg_catalog."th-x-icu" is 'Thai';

alter collation pg_catalog."th-x-icu" owner to postgres;

create collation pg_catalog."th-TH-x-icu" (
    locale = 'th-TH'
    );

comment on collation pg_catalog."th-TH-x-icu" is 'Thai (Thailand)';

alter collation pg_catalog."th-TH-x-icu" owner to postgres;

create collation pg_catalog."ti-x-icu" (
    locale = 'ti'
    );

comment on collation pg_catalog."ti-x-icu" is 'Tigrinya';

alter collation pg_catalog."ti-x-icu" owner to postgres;

create collation pg_catalog."ti-ER-x-icu" (
    locale = 'ti-ER'
    );

comment on collation pg_catalog."ti-ER-x-icu" is 'Tigrinya (Eritrea)';

alter collation pg_catalog."ti-ER-x-icu" owner to postgres;

create collation pg_catalog."ti-ET-x-icu" (
    locale = 'ti-ET'
    );

comment on collation pg_catalog."ti-ET-x-icu" is 'Tigrinya (Ethiopia)';

alter collation pg_catalog."ti-ET-x-icu" owner to postgres;

create collation pg_catalog."tk-x-icu" (
    locale = 'tk'
    );

comment on collation pg_catalog."tk-x-icu" is 'Turkmen';

alter collation pg_catalog."tk-x-icu" owner to postgres;

create collation pg_catalog."tk-TM-x-icu" (
    locale = 'tk-TM'
    );

comment on collation pg_catalog."tk-TM-x-icu" is 'Turkmen (Turkmenistan)';

alter collation pg_catalog."tk-TM-x-icu" owner to postgres;

create collation pg_catalog."to-x-icu" (
    locale = 'to'
    );

comment on collation pg_catalog."to-x-icu" is 'Tongan';

alter collation pg_catalog."to-x-icu" owner to postgres;

create collation pg_catalog."to-TO-x-icu" (
    locale = 'to-TO'
    );

comment on collation pg_catalog."to-TO-x-icu" is 'Tongan (Tonga)';

alter collation pg_catalog."to-TO-x-icu" owner to postgres;

create collation pg_catalog."tr-x-icu" (
    locale = 'tr'
    );

comment on collation pg_catalog."tr-x-icu" is 'Turkish';

alter collation pg_catalog."tr-x-icu" owner to postgres;

create collation pg_catalog."tr-CY-x-icu" (
    locale = 'tr-CY'
    );

comment on collation pg_catalog."tr-CY-x-icu" is 'Turkish (Cyprus)';

alter collation pg_catalog."tr-CY-x-icu" owner to postgres;

create collation pg_catalog."tr-TR-x-icu" (
    locale = 'tr-TR'
    );

comment on collation pg_catalog."tr-TR-x-icu" is 'Turkish (Turkey)';

alter collation pg_catalog."tr-TR-x-icu" owner to postgres;

create collation pg_catalog."tt-x-icu" (
    locale = 'tt'
    );

comment on collation pg_catalog."tt-x-icu" is 'Tatar';

alter collation pg_catalog."tt-x-icu" owner to postgres;

create collation pg_catalog."tt-RU-x-icu" (
    locale = 'tt-RU'
    );

comment on collation pg_catalog."tt-RU-x-icu" is 'Tatar (Russia)';

alter collation pg_catalog."tt-RU-x-icu" owner to postgres;

create collation pg_catalog."twq-x-icu" (
    locale = 'twq'
    );

comment on collation pg_catalog."twq-x-icu" is 'Tasawaq';

alter collation pg_catalog."twq-x-icu" owner to postgres;

create collation pg_catalog."twq-NE-x-icu" (
    locale = 'twq-NE'
    );

comment on collation pg_catalog."twq-NE-x-icu" is 'Tasawaq (Niger)';

alter collation pg_catalog."twq-NE-x-icu" owner to postgres;

create collation pg_catalog."tzm-x-icu" (
    locale = 'tzm'
    );

comment on collation pg_catalog."tzm-x-icu" is 'Central Atlas Tamazight';

alter collation pg_catalog."tzm-x-icu" owner to postgres;

create collation pg_catalog."tzm-MA-x-icu" (
    locale = 'tzm-MA'
    );

comment on collation pg_catalog."tzm-MA-x-icu" is 'Central Atlas Tamazight (Morocco)';

alter collation pg_catalog."tzm-MA-x-icu" owner to postgres;

create collation pg_catalog."ug-x-icu" (
    locale = 'ug'
    );

comment on collation pg_catalog."ug-x-icu" is 'Uyghur';

alter collation pg_catalog."ug-x-icu" owner to postgres;

create collation pg_catalog."ug-CN-x-icu" (
    locale = 'ug-CN'
    );

comment on collation pg_catalog."ug-CN-x-icu" is 'Uyghur (China)';

alter collation pg_catalog."ug-CN-x-icu" owner to postgres;

create collation pg_catalog."uk-x-icu" (
    locale = 'uk'
    );

comment on collation pg_catalog."uk-x-icu" is 'Ukrainian';

alter collation pg_catalog."uk-x-icu" owner to postgres;

create collation pg_catalog."uk-UA-x-icu" (
    locale = 'uk-UA'
    );

comment on collation pg_catalog."uk-UA-x-icu" is 'Ukrainian (Ukraine)';

alter collation pg_catalog."uk-UA-x-icu" owner to postgres;

create collation pg_catalog."ur-x-icu" (
    locale = 'ur'
    );

comment on collation pg_catalog."ur-x-icu" is 'Urdu';

alter collation pg_catalog."ur-x-icu" owner to postgres;

create collation pg_catalog."ur-IN-x-icu" (
    locale = 'ur-IN'
    );

comment on collation pg_catalog."ur-IN-x-icu" is 'Urdu (India)';

alter collation pg_catalog."ur-IN-x-icu" owner to postgres;

create collation pg_catalog."ur-PK-x-icu" (
    locale = 'ur-PK'
    );

comment on collation pg_catalog."ur-PK-x-icu" is 'Urdu (Pakistan)';

alter collation pg_catalog."ur-PK-x-icu" owner to postgres;

create collation pg_catalog."uz-x-icu" (
    locale = 'uz'
    );

comment on collation pg_catalog."uz-x-icu" is 'Uzbek';

alter collation pg_catalog."uz-x-icu" owner to postgres;

create collation pg_catalog."uz-Arab-x-icu" (
    locale = 'uz-Arab'
    );

comment on collation pg_catalog."uz-Arab-x-icu" is 'Uzbek (Arabic)';

alter collation pg_catalog."uz-Arab-x-icu" owner to postgres;

create collation pg_catalog."uz-Arab-AF-x-icu" (
    locale = 'uz-Arab-AF'
    );

comment on collation pg_catalog."uz-Arab-AF-x-icu" is 'Uzbek (Arabic, Afghanistan)';

alter collation pg_catalog."uz-Arab-AF-x-icu" owner to postgres;

create collation pg_catalog."uz-Cyrl-x-icu" (
    locale = 'uz-Cyrl'
    );

comment on collation pg_catalog."uz-Cyrl-x-icu" is 'Uzbek (Cyrillic)';

alter collation pg_catalog."uz-Cyrl-x-icu" owner to postgres;

create collation pg_catalog."uz-Cyrl-UZ-x-icu" (
    locale = 'uz-Cyrl-UZ'
    );

comment on collation pg_catalog."uz-Cyrl-UZ-x-icu" is 'Uzbek (Cyrillic, Uzbekistan)';

alter collation pg_catalog."uz-Cyrl-UZ-x-icu" owner to postgres;

create collation pg_catalog."uz-Latn-x-icu" (
    locale = 'uz-Latn'
    );

comment on collation pg_catalog."uz-Latn-x-icu" is 'Uzbek (Latin)';

alter collation pg_catalog."uz-Latn-x-icu" owner to postgres;

create collation pg_catalog."uz-Latn-UZ-x-icu" (
    locale = 'uz-Latn-UZ'
    );

comment on collation pg_catalog."uz-Latn-UZ-x-icu" is 'Uzbek (Latin, Uzbekistan)';

alter collation pg_catalog."uz-Latn-UZ-x-icu" owner to postgres;

create collation pg_catalog."vai-x-icu" (
    locale = 'vai'
    );

comment on collation pg_catalog."vai-x-icu" is 'Vai';

alter collation pg_catalog."vai-x-icu" owner to postgres;

create collation pg_catalog."vai-Latn-x-icu" (
    locale = 'vai-Latn'
    );

comment on collation pg_catalog."vai-Latn-x-icu" is 'Vai (Latin)';

alter collation pg_catalog."vai-Latn-x-icu" owner to postgres;

create collation pg_catalog."vai-Latn-LR-x-icu" (
    locale = 'vai-Latn-LR'
    );

comment on collation pg_catalog."vai-Latn-LR-x-icu" is 'Vai (Latin, Liberia)';

alter collation pg_catalog."vai-Latn-LR-x-icu" owner to postgres;

create collation pg_catalog."vai-Vaii-x-icu" (
    locale = 'vai-Vaii'
    );

comment on collation pg_catalog."vai-Vaii-x-icu" is 'Vai (Vai)';

alter collation pg_catalog."vai-Vaii-x-icu" owner to postgres;

create collation pg_catalog."vai-Vaii-LR-x-icu" (
    locale = 'vai-Vaii-LR'
    );

comment on collation pg_catalog."vai-Vaii-LR-x-icu" is 'Vai (Vai, Liberia)';

alter collation pg_catalog."vai-Vaii-LR-x-icu" owner to postgres;

create collation pg_catalog."vi-x-icu" (
    locale = 'vi'
    );

comment on collation pg_catalog."vi-x-icu" is 'Vietnamese';

alter collation pg_catalog."vi-x-icu" owner to postgres;

create collation pg_catalog."vi-VN-x-icu" (
    locale = 'vi-VN'
    );

comment on collation pg_catalog."vi-VN-x-icu" is 'Vietnamese (Vietnam)';

alter collation pg_catalog."vi-VN-x-icu" owner to postgres;

create collation pg_catalog."vun-x-icu" (
    locale = 'vun'
    );

comment on collation pg_catalog."vun-x-icu" is 'Vunjo';

alter collation pg_catalog."vun-x-icu" owner to postgres;

create collation pg_catalog."vun-TZ-x-icu" (
    locale = 'vun-TZ'
    );

comment on collation pg_catalog."vun-TZ-x-icu" is 'Vunjo (Tanzania)';

alter collation pg_catalog."vun-TZ-x-icu" owner to postgres;

create collation pg_catalog."wae-x-icu" (
    locale = 'wae'
    );

comment on collation pg_catalog."wae-x-icu" is 'Walser';

alter collation pg_catalog."wae-x-icu" owner to postgres;

create collation pg_catalog."wae-CH-x-icu" (
    locale = 'wae-CH'
    );

comment on collation pg_catalog."wae-CH-x-icu" is 'Walser (Switzerland)';

alter collation pg_catalog."wae-CH-x-icu" owner to postgres;

create collation pg_catalog."wo-x-icu" (
    locale = 'wo'
    );

comment on collation pg_catalog."wo-x-icu" is 'Wolof';

alter collation pg_catalog."wo-x-icu" owner to postgres;

create collation pg_catalog."wo-SN-x-icu" (
    locale = 'wo-SN'
    );

comment on collation pg_catalog."wo-SN-x-icu" is 'Wolof (Senegal)';

alter collation pg_catalog."wo-SN-x-icu" owner to postgres;

create collation pg_catalog."xh-x-icu" (
    locale = 'xh'
    );

comment on collation pg_catalog."xh-x-icu" is 'Xhosa';

alter collation pg_catalog."xh-x-icu" owner to postgres;

create collation pg_catalog."xh-ZA-x-icu" (
    locale = 'xh-ZA'
    );

comment on collation pg_catalog."xh-ZA-x-icu" is 'Xhosa (South Africa)';

alter collation pg_catalog."xh-ZA-x-icu" owner to postgres;

create collation pg_catalog."xog-x-icu" (
    locale = 'xog'
    );

comment on collation pg_catalog."xog-x-icu" is 'Soga';

alter collation pg_catalog."xog-x-icu" owner to postgres;

create collation pg_catalog."xog-UG-x-icu" (
    locale = 'xog-UG'
    );

comment on collation pg_catalog."xog-UG-x-icu" is 'Soga (Uganda)';

alter collation pg_catalog."xog-UG-x-icu" owner to postgres;

create collation pg_catalog."yav-x-icu" (
    locale = 'yav'
    );

comment on collation pg_catalog."yav-x-icu" is 'Yangben';

alter collation pg_catalog."yav-x-icu" owner to postgres;

create collation pg_catalog."yav-CM-x-icu" (
    locale = 'yav-CM'
    );

comment on collation pg_catalog."yav-CM-x-icu" is 'Yangben (Cameroon)';

alter collation pg_catalog."yav-CM-x-icu" owner to postgres;

create collation pg_catalog."yi-x-icu" (
    locale = 'yi'
    );

comment on collation pg_catalog."yi-x-icu" is 'Yiddish';

alter collation pg_catalog."yi-x-icu" owner to postgres;

create collation pg_catalog."yi-001-x-icu" (
    locale = 'yi-001'
    );

comment on collation pg_catalog."yi-001-x-icu" is 'Yiddish (World)';

alter collation pg_catalog."yi-001-x-icu" owner to postgres;

create collation pg_catalog."yo-x-icu" (
    locale = 'yo'
    );

comment on collation pg_catalog."yo-x-icu" is 'Yoruba';

alter collation pg_catalog."yo-x-icu" owner to postgres;

create collation pg_catalog."yo-BJ-x-icu" (
    locale = 'yo-BJ'
    );

comment on collation pg_catalog."yo-BJ-x-icu" is 'Yoruba (Benin)';

alter collation pg_catalog."yo-BJ-x-icu" owner to postgres;

create collation pg_catalog."yo-NG-x-icu" (
    locale = 'yo-NG'
    );

comment on collation pg_catalog."yo-NG-x-icu" is 'Yoruba (Nigeria)';

alter collation pg_catalog."yo-NG-x-icu" owner to postgres;

create collation pg_catalog."yue-x-icu" (
    locale = 'yue'
    );

comment on collation pg_catalog."yue-x-icu" is 'Cantonese';

alter collation pg_catalog."yue-x-icu" owner to postgres;

create collation pg_catalog."yue-Hans-x-icu" (
    locale = 'yue-Hans'
    );

comment on collation pg_catalog."yue-Hans-x-icu" is 'Cantonese (Simplified)';

alter collation pg_catalog."yue-Hans-x-icu" owner to postgres;

create collation pg_catalog."yue-Hans-CN-x-icu" (
    locale = 'yue-Hans-CN'
    );

comment on collation pg_catalog."yue-Hans-CN-x-icu" is 'Cantonese (Simplified, China)';

alter collation pg_catalog."yue-Hans-CN-x-icu" owner to postgres;

create collation pg_catalog."yue-Hant-x-icu" (
    locale = 'yue-Hant'
    );

comment on collation pg_catalog."yue-Hant-x-icu" is 'Cantonese (Traditional)';

alter collation pg_catalog."yue-Hant-x-icu" owner to postgres;

create collation pg_catalog."yue-Hant-HK-x-icu" (
    locale = 'yue-Hant-HK'
    );

comment on collation pg_catalog."yue-Hant-HK-x-icu" is 'Cantonese (Traditional, Hong Kong SAR China)';

alter collation pg_catalog."yue-Hant-HK-x-icu" owner to postgres;

create collation pg_catalog."zgh-x-icu" (
    locale = 'zgh'
    );

comment on collation pg_catalog."zgh-x-icu" is 'Standard Moroccan Tamazight';

alter collation pg_catalog."zgh-x-icu" owner to postgres;

create collation pg_catalog."zgh-MA-x-icu" (
    locale = 'zgh-MA'
    );

comment on collation pg_catalog."zgh-MA-x-icu" is 'Standard Moroccan Tamazight (Morocco)';

alter collation pg_catalog."zgh-MA-x-icu" owner to postgres;

create collation pg_catalog."zh-x-icu" (
    locale = 'zh'
    );

comment on collation pg_catalog."zh-x-icu" is 'Chinese';

alter collation pg_catalog."zh-x-icu" owner to postgres;

create collation pg_catalog."zh-Hans-x-icu" (
    locale = 'zh-Hans'
    );

comment on collation pg_catalog."zh-Hans-x-icu" is 'Chinese (Simplified)';

alter collation pg_catalog."zh-Hans-x-icu" owner to postgres;

create collation pg_catalog."zh-Hans-CN-x-icu" (
    locale = 'zh-Hans-CN'
    );

comment on collation pg_catalog."zh-Hans-CN-x-icu" is 'Chinese (Simplified, China)';

alter collation pg_catalog."zh-Hans-CN-x-icu" owner to postgres;

create collation pg_catalog."zh-Hans-HK-x-icu" (
    locale = 'zh-Hans-HK'
    );

comment on collation pg_catalog."zh-Hans-HK-x-icu" is 'Chinese (Simplified, Hong Kong SAR China)';

alter collation pg_catalog."zh-Hans-HK-x-icu" owner to postgres;

create collation pg_catalog."zh-Hans-MO-x-icu" (
    locale = 'zh-Hans-MO'
    );

comment on collation pg_catalog."zh-Hans-MO-x-icu" is 'Chinese (Simplified, Macao SAR China)';

alter collation pg_catalog."zh-Hans-MO-x-icu" owner to postgres;

create collation pg_catalog."zh-Hans-SG-x-icu" (
    locale = 'zh-Hans-SG'
    );

comment on collation pg_catalog."zh-Hans-SG-x-icu" is 'Chinese (Simplified, Singapore)';

alter collation pg_catalog."zh-Hans-SG-x-icu" owner to postgres;

create collation pg_catalog."zh-Hant-x-icu" (
    locale = 'zh-Hant'
    );

comment on collation pg_catalog."zh-Hant-x-icu" is 'Chinese (Traditional)';

alter collation pg_catalog."zh-Hant-x-icu" owner to postgres;

create collation pg_catalog."zh-Hant-HK-x-icu" (
    locale = 'zh-Hant-HK'
    );

comment on collation pg_catalog."zh-Hant-HK-x-icu" is 'Chinese (Traditional, Hong Kong SAR China)';

alter collation pg_catalog."zh-Hant-HK-x-icu" owner to postgres;

create collation pg_catalog."zh-Hant-MO-x-icu" (
    locale = 'zh-Hant-MO'
    );

comment on collation pg_catalog."zh-Hant-MO-x-icu" is 'Chinese (Traditional, Macao SAR China)';

alter collation pg_catalog."zh-Hant-MO-x-icu" owner to postgres;

create collation pg_catalog."zh-Hant-TW-x-icu" (
    locale = 'zh-Hant-TW'
    );

comment on collation pg_catalog."zh-Hant-TW-x-icu" is 'Chinese (Traditional, Taiwan)';

alter collation pg_catalog."zh-Hant-TW-x-icu" owner to postgres;

create collation pg_catalog."zu-x-icu" (
    locale = 'zu'
    );

comment on collation pg_catalog."zu-x-icu" is 'Zulu';

alter collation pg_catalog."zu-x-icu" owner to postgres;

create collation pg_catalog."zu-ZA-x-icu" (
    locale = 'zu-ZA'
    );

comment on collation pg_catalog."zu-ZA-x-icu" is 'Zulu (South Africa)';

alter collation pg_catalog."zu-ZA-x-icu" owner to postgres;

create aggregate pg_catalog.avg(bigint) (
    sfunc = int8_avg_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_avg,
    combinefunc = int8_avg_combine,
    serialfunc = int8_avg_serialize,
    deserialfunc = int8_avg_deserialize,
    parallel = safe,
    msfunc = int8_avg_accum,
    minvfunc = int8_avg_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_avg
    );

comment on aggregate pg_catalog.avg(bigint) is 'the average (arithmetic mean) as numeric of all bigint values';

alter aggregate pg_catalog.avg(bigint) owner to postgres;

create aggregate pg_catalog.avg(integer) (
    sfunc = int4_avg_accum,
    stype = bigint[],
    finalfunc = int8_avg,
    combinefunc = int4_avg_combine,
    initcond = '{0,0}',
    parallel = safe,
    msfunc = int4_avg_accum,
    minvfunc = int4_avg_accum_inv,
    mstype = bigint[],
    mfinalfunc = int8_avg,
    minitcond = '{0,0}'
    );

comment on aggregate pg_catalog.avg(integer) is 'the average (arithmetic mean) as numeric of all integer values';

alter aggregate pg_catalog.avg(integer) owner to postgres;

create aggregate pg_catalog.avg(smallint) (
    sfunc = int2_avg_accum,
    stype = bigint[],
    finalfunc = int8_avg,
    combinefunc = int4_avg_combine,
    initcond = '{0,0}',
    parallel = safe,
    msfunc = int2_avg_accum,
    minvfunc = int2_avg_accum_inv,
    mstype = bigint[],
    mfinalfunc = int8_avg,
    minitcond = '{0,0}'
    );

comment on aggregate pg_catalog.avg(smallint) is 'the average (arithmetic mean) as numeric of all smallint values';

alter aggregate pg_catalog.avg(smallint) owner to postgres;

create aggregate pg_catalog.avg(numeric) (
    sfunc = numeric_avg_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_avg,
    combinefunc = numeric_avg_combine,
    serialfunc = numeric_avg_serialize,
    deserialfunc = numeric_avg_deserialize,
    parallel = safe,
    msfunc = numeric_avg_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_avg
    );

comment on aggregate pg_catalog.avg(numeric) is 'the average (arithmetic mean) as numeric of all numeric values';

alter aggregate pg_catalog.avg(numeric) owner to postgres;

create aggregate pg_catalog.avg(real) (
    sfunc = float4_accum,
    stype = double precision[],
    finalfunc = float8_avg,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.avg(real) is 'the average (arithmetic mean) as float8 of all float4 values';

alter aggregate pg_catalog.avg(real) owner to postgres;

create aggregate pg_catalog.avg(double precision) (
    sfunc = float8_accum,
    stype = double precision[],
    finalfunc = float8_avg,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.avg(double precision) is 'the average (arithmetic mean) as float8 of all float8 values';

alter aggregate pg_catalog.avg(double precision) owner to postgres;

create aggregate pg_catalog.avg(interval) (
    sfunc = interval_accum,
    stype = interval[],
    finalfunc = interval_avg,
    combinefunc = interval_combine,
    initcond = '{0 second,0 second}',
    parallel = safe,
    msfunc = interval_accum,
    minvfunc = interval_accum_inv,
    mstype = interval[],
    mfinalfunc = interval_avg,
    minitcond = '{0 second,0 second}'
    );

comment on aggregate pg_catalog.avg(interval) is 'the average (arithmetic mean) as interval of all interval values';

alter aggregate pg_catalog.avg(interval) owner to postgres;

create aggregate pg_catalog.sum(bigint) (
    sfunc = int8_avg_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_sum,
    combinefunc = int8_avg_combine,
    serialfunc = int8_avg_serialize,
    deserialfunc = int8_avg_deserialize,
    parallel = safe,
    msfunc = int8_avg_accum,
    minvfunc = int8_avg_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_sum
    );

comment on aggregate pg_catalog.sum(bigint) is 'sum as numeric across all bigint input values';

alter aggregate pg_catalog.sum(bigint) owner to postgres;

create aggregate pg_catalog.sum(integer) (
    sfunc = int4_sum,
    stype = bigint,
    combinefunc = int8pl,
    parallel = safe,
    msfunc = int4_avg_accum,
    minvfunc = int4_avg_accum_inv,
    mstype = bigint[],
    mfinalfunc = int2int4_sum,
    minitcond = '{0,0}'
    );

comment on aggregate pg_catalog.sum(integer) is 'sum as bigint across all integer input values';

alter aggregate pg_catalog.sum(integer) owner to postgres;

create aggregate pg_catalog.sum(smallint) (
    sfunc = int2_sum,
    stype = bigint,
    combinefunc = int8pl,
    parallel = safe,
    msfunc = int2_avg_accum,
    minvfunc = int2_avg_accum_inv,
    mstype = bigint[],
    mfinalfunc = int2int4_sum,
    minitcond = '{0,0}'
    );

comment on aggregate pg_catalog.sum(smallint) is 'sum as bigint across all smallint input values';

alter aggregate pg_catalog.sum(smallint) owner to postgres;

create aggregate pg_catalog.sum(real) (
    sfunc = float4pl,
    stype = real,
    combinefunc = float4pl,
    parallel = safe
    );

comment on aggregate pg_catalog.sum(real) is 'sum as float4 across all float4 input values';

alter aggregate pg_catalog.sum(real) owner to postgres;

create aggregate pg_catalog.sum(double precision) (
    sfunc = float8pl,
    stype = double precision,
    combinefunc = float8pl,
    parallel = safe
    );

comment on aggregate pg_catalog.sum(double precision) is 'sum as float8 across all float8 input values';

alter aggregate pg_catalog.sum(double precision) owner to postgres;

create aggregate pg_catalog.sum() (
    sfunc = cash_pl,
    stype = money,
    combinefunc = cash_pl,
    parallel = safe,
    msfunc = cash_pl,
    minvfunc = cash_mi,
    mstype = money
    );

comment on aggregate pg_catalog.sum() is 'sum as money across all money input values';

alter aggregate pg_catalog.sum() owner to postgres;

create aggregate pg_catalog.sum(interval) (
    sfunc = interval_pl,
    stype = interval,
    combinefunc = interval_pl,
    parallel = safe,
    msfunc = interval_pl,
    minvfunc = interval_mi,
    mstype = interval
    );

comment on aggregate pg_catalog.sum(interval) is 'sum as interval across all interval input values';

alter aggregate pg_catalog.sum(interval) owner to postgres;

create aggregate pg_catalog.sum() (
    sfunc = numeric_avg_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_sum,
    combinefunc = numeric_avg_combine,
    serialfunc = numeric_avg_serialize,
    deserialfunc = numeric_avg_deserialize,
    parallel = safe,
    msfunc = numeric_avg_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_sum
    );

comment on aggregate pg_catalog.sum() is 'sum as numeric across all numeric input values';

alter aggregate pg_catalog.sum() owner to postgres;

create aggregate pg_catalog.count("any") (
    sfunc = int8inc_any,
    stype = bigint,
    combinefunc = int8pl,
    initcond = '0',
    parallel = safe,
    msfunc = int8inc_any,
    minvfunc = int8dec_any,
    mstype = bigint,
    minitcond = '0'
    );

comment on aggregate pg_catalog.count("any") is 'number of input rows for which the input expression is not null';

alter aggregate pg_catalog.count("any") owner to postgres;

create aggregate pg_catalog.variance(bigint) (
    sfunc = int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_var_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = int8_accum,
    minvfunc = int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_var_samp
    );

comment on aggregate pg_catalog.variance(bigint) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(bigint) owner to postgres;

create aggregate pg_catalog.variance(integer) (
    sfunc = int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_var_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int4_accum,
    minvfunc = int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_var_samp
    );

comment on aggregate pg_catalog.variance(integer) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(integer) owner to postgres;

create aggregate pg_catalog.variance() (
    sfunc = int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_var_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int2_accum,
    minvfunc = int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_var_samp
    );

comment on aggregate pg_catalog.variance() is 'historical alias for var_samp';

alter aggregate pg_catalog.variance() owner to postgres;

create aggregate pg_catalog.variance(real) (
    sfunc = float4_accum,
    stype = double precision[],
    finalfunc = float8_var_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.variance(real) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(real) owner to postgres;

create aggregate pg_catalog.variance(double precision) (
    sfunc = float8_accum,
    stype = double precision[],
    finalfunc = float8_var_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.variance(double precision) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(double precision) owner to postgres;

create aggregate pg_catalog.variance() (
    sfunc = numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_var_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = numeric_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_var_samp
    );

comment on aggregate pg_catalog.variance() is 'historical alias for var_samp';

alter aggregate pg_catalog.variance() owner to postgres;

create aggregate pg_catalog.stddev(bigint) (
    sfunc = int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_stddev_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = int8_accum,
    minvfunc = int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_stddev_samp
    );

comment on aggregate pg_catalog.stddev(bigint) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(bigint) owner to postgres;

create aggregate pg_catalog.stddev(integer) (
    sfunc = int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_stddev_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int4_accum,
    minvfunc = int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_stddev_samp
    );

comment on aggregate pg_catalog.stddev(integer) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(integer) owner to postgres;

create aggregate pg_catalog.stddev() (
    sfunc = int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_stddev_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int2_accum,
    minvfunc = int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_stddev_samp
    );

comment on aggregate pg_catalog.stddev() is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev() owner to postgres;

create aggregate pg_catalog.stddev(real) (
    sfunc = float4_accum,
    stype = double precision[],
    finalfunc = float8_stddev_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev(real) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(real) owner to postgres;

create aggregate pg_catalog.stddev(double precision) (
    sfunc = float8_accum,
    stype = double precision[],
    finalfunc = float8_stddev_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev(double precision) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(double precision) owner to postgres;

create aggregate pg_catalog.stddev() (
    sfunc = numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_stddev_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = numeric_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_stddev_samp
    );

comment on aggregate pg_catalog.stddev() is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev() owner to postgres;

create aggregate pg_catalog.bit_and(smallint) (
    sfunc = int2and,
    stype = smallint,
    combinefunc = int2and,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_and(smallint) is 'bitwise-and smallint aggregate';

alter aggregate pg_catalog.bit_and(smallint) owner to postgres;

create aggregate pg_catalog.bit_or(smallint) (
    sfunc = int2or,
    stype = smallint,
    combinefunc = int2or,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_or(smallint) is 'bitwise-or smallint aggregate';

alter aggregate pg_catalog.bit_or(smallint) owner to postgres;

create aggregate pg_catalog.bit_and(integer) (
    sfunc = int4and,
    stype = integer,
    combinefunc = int4and,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_and(integer) is 'bitwise-and integer aggregate';

alter aggregate pg_catalog.bit_and(integer) owner to postgres;

create aggregate pg_catalog.bit_or(integer) (
    sfunc = int4or,
    stype = integer,
    combinefunc = int4or,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_or(integer) is 'bitwise-or integer aggregate';

alter aggregate pg_catalog.bit_or(integer) owner to postgres;

create aggregate pg_catalog.bit_and(bigint) (
    sfunc = int8and,
    stype = bigint,
    combinefunc = int8and,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_and(bigint) is 'bitwise-and bigint aggregate';

alter aggregate pg_catalog.bit_and(bigint) owner to postgres;

create aggregate pg_catalog.bit_or(bigint) (
    sfunc = int8or,
    stype = bigint,
    combinefunc = int8or,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_or(bigint) is 'bitwise-or bigint aggregate';

alter aggregate pg_catalog.bit_or(bigint) owner to postgres;

create aggregate pg_catalog.bit_and(bit) (
    sfunc = bitand,
    stype = bit,
    combinefunc = bitand,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_and(bit) is 'bitwise-and bit aggregate';

alter aggregate pg_catalog.bit_and(bit) owner to postgres;

create aggregate pg_catalog.bit_or(bit) (
    sfunc = bitor,
    stype = bit,
    combinefunc = bitor,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_or(bit) is 'bitwise-or bit aggregate';

alter aggregate pg_catalog.bit_or(bit) owner to postgres;

create aggregate pg_catalog.array_agg(anynonarray) (
    sfunc = array_agg_transfn,
    stype = internal,
    finalfunc = array_agg_finalfn,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.array_agg(anynonarray) is 'concatenate aggregate input into an array';

alter aggregate pg_catalog.array_agg(anynonarray) owner to postgres;

create aggregate pg_catalog.var_samp() (
    sfunc = int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_var_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = int8_accum,
    minvfunc = int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_var_samp
    );

comment on aggregate pg_catalog.var_samp() is 'sample variance of bigint input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp() owner to postgres;

create aggregate pg_catalog.var_samp(integer) (
    sfunc = int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_var_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int4_accum,
    minvfunc = int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_var_samp
    );

comment on aggregate pg_catalog.var_samp(integer) is 'sample variance of integer input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(integer) owner to postgres;

create aggregate pg_catalog.var_samp(smallint) (
    sfunc = int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_var_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int2_accum,
    minvfunc = int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_var_samp
    );

comment on aggregate pg_catalog.var_samp(smallint) is 'sample variance of smallint input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(smallint) owner to postgres;

create aggregate pg_catalog.var_samp(real) (
    sfunc = float4_accum,
    stype = double precision[],
    finalfunc = float8_var_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.var_samp(real) is 'sample variance of float4 input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(real) owner to postgres;

create aggregate pg_catalog.var_samp(double precision) (
    sfunc = float8_accum,
    stype = double precision[],
    finalfunc = float8_var_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.var_samp(double precision) is 'sample variance of float8 input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(double precision) owner to postgres;

create aggregate pg_catalog.var_samp(numeric) (
    sfunc = numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_var_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = numeric_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_var_samp
    );

comment on aggregate pg_catalog.var_samp(numeric) is 'sample variance of numeric input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(numeric) owner to postgres;

create aggregate pg_catalog.stddev_samp() (
    sfunc = int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_stddev_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = int8_accum,
    minvfunc = int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_stddev_samp
    );

comment on aggregate pg_catalog.stddev_samp() is 'sample standard deviation of bigint input values';

alter aggregate pg_catalog.stddev_samp() owner to postgres;

create aggregate pg_catalog.stddev_samp(integer) (
    sfunc = int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_stddev_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int4_accum,
    minvfunc = int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_stddev_samp
    );

comment on aggregate pg_catalog.stddev_samp(integer) is 'sample standard deviation of integer input values';

alter aggregate pg_catalog.stddev_samp(integer) owner to postgres;

create aggregate pg_catalog.stddev_samp(smallint) (
    sfunc = int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_stddev_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int2_accum,
    minvfunc = int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_stddev_samp
    );

comment on aggregate pg_catalog.stddev_samp(smallint) is 'sample standard deviation of smallint input values';

alter aggregate pg_catalog.stddev_samp(smallint) owner to postgres;

create aggregate pg_catalog.stddev_samp(real) (
    sfunc = float4_accum,
    stype = double precision[],
    finalfunc = float8_stddev_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev_samp(real) is 'sample standard deviation of float4 input values';

alter aggregate pg_catalog.stddev_samp(real) owner to postgres;

create aggregate pg_catalog.stddev_samp(double precision) (
    sfunc = float8_accum,
    stype = double precision[],
    finalfunc = float8_stddev_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev_samp(double precision) is 'sample standard deviation of float8 input values';

alter aggregate pg_catalog.stddev_samp(double precision) owner to postgres;

create aggregate pg_catalog.stddev_samp(numeric) (
    sfunc = numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_stddev_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = numeric_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_stddev_samp
    );

comment on aggregate pg_catalog.stddev_samp(numeric) is 'sample standard deviation of numeric input values';

alter aggregate pg_catalog.stddev_samp(numeric) owner to postgres;

create aggregate pg_catalog.var_pop() (
    sfunc = int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_var_pop,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = int8_accum,
    minvfunc = int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_var_pop
    );

comment on aggregate pg_catalog.var_pop() is 'population variance of bigint input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop() owner to postgres;

create aggregate pg_catalog.var_pop(integer) (
    sfunc = int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_var_pop,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int4_accum,
    minvfunc = int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_var_pop
    );

comment on aggregate pg_catalog.var_pop(integer) is 'population variance of integer input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(integer) owner to postgres;

create aggregate pg_catalog.var_pop(smallint) (
    sfunc = int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_var_pop,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int2_accum,
    minvfunc = int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_var_pop
    );

comment on aggregate pg_catalog.var_pop(smallint) is 'population variance of smallint input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(smallint) owner to postgres;

create aggregate pg_catalog.var_pop(real) (
    sfunc = float4_accum,
    stype = double precision[],
    finalfunc = float8_var_pop,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.var_pop(real) is 'population variance of float4 input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(real) owner to postgres;

create aggregate pg_catalog.var_pop(double precision) (
    sfunc = float8_accum,
    stype = double precision[],
    finalfunc = float8_var_pop,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.var_pop(double precision) is 'population variance of float8 input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(double precision) owner to postgres;

create aggregate pg_catalog.var_pop(numeric) (
    sfunc = numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_var_pop,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = numeric_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_var_pop
    );

comment on aggregate pg_catalog.var_pop(numeric) is 'population variance of numeric input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(numeric) owner to postgres;

create aggregate pg_catalog.stddev_pop() (
    sfunc = int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_stddev_pop,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = int8_accum,
    minvfunc = int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_stddev_pop
    );

comment on aggregate pg_catalog.stddev_pop() is 'population standard deviation of bigint input values';

alter aggregate pg_catalog.stddev_pop() owner to postgres;

create aggregate pg_catalog.stddev_pop(integer) (
    sfunc = int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_stddev_pop,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int4_accum,
    minvfunc = int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_stddev_pop
    );

comment on aggregate pg_catalog.stddev_pop(integer) is 'population standard deviation of integer input values';

alter aggregate pg_catalog.stddev_pop(integer) owner to postgres;

create aggregate pg_catalog.stddev_pop(smallint) (
    sfunc = int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_stddev_pop,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int2_accum,
    minvfunc = int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_stddev_pop
    );

comment on aggregate pg_catalog.stddev_pop(smallint) is 'population standard deviation of smallint input values';

alter aggregate pg_catalog.stddev_pop(smallint) owner to postgres;

create aggregate pg_catalog.stddev_pop(real) (
    sfunc = float4_accum,
    stype = double precision[],
    finalfunc = float8_stddev_pop,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev_pop(real) is 'population standard deviation of float4 input values';

alter aggregate pg_catalog.stddev_pop(real) owner to postgres;

create aggregate pg_catalog.stddev_pop(double precision) (
    sfunc = float8_accum,
    stype = double precision[],
    finalfunc = float8_stddev_pop,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev_pop(double precision) is 'population standard deviation of float8 input values';

alter aggregate pg_catalog.stddev_pop(double precision) owner to postgres;

create aggregate pg_catalog.stddev_pop(numeric) (
    sfunc = numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_stddev_pop,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = numeric_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_stddev_pop
    );

comment on aggregate pg_catalog.stddev_pop(numeric) is 'population standard deviation of numeric input values';

alter aggregate pg_catalog.stddev_pop(numeric) owner to postgres;

create aggregate pg_catalog.count() (
    sfunc = int8inc,
    stype = bigint,
    combinefunc = int8pl,
    initcond = '0',
    parallel = safe,
    msfunc = int8inc,
    minvfunc = int8dec,
    mstype = bigint,
    minitcond = '0'
    );

comment on aggregate pg_catalog.count() is 'number of input rows';

alter aggregate pg_catalog.count() owner to postgres;

create aggregate pg_catalog.regr_count() (
    sfunc = int8inc_float8_float8,
    stype = bigint,
    combinefunc = int8pl,
    initcond = '0',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_count() is 'number of input rows in which both expressions are not null';

alter aggregate pg_catalog.regr_count() owner to postgres;

create aggregate pg_catalog.regr_sxx() (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_sxx,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_sxx() is 'sum of squares of the independent variable (sum(X^2) - sum(X)^2/N)';

alter aggregate pg_catalog.regr_sxx() owner to postgres;

create aggregate pg_catalog.regr_syy() (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_syy,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_syy() is 'sum of squares of the dependent variable (sum(Y^2) - sum(Y)^2/N)';

alter aggregate pg_catalog.regr_syy() owner to postgres;

create aggregate pg_catalog.regr_sxy() (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_sxy,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_sxy() is 'sum of products of independent times dependent variable (sum(X*Y) - sum(X) * sum(Y)/N)';

alter aggregate pg_catalog.regr_sxy() owner to postgres;

create aggregate pg_catalog.regr_avgx() (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_avgx,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_avgx() is 'average of the independent variable (sum(X)/N)';

alter aggregate pg_catalog.regr_avgx() owner to postgres;

create aggregate pg_catalog.regr_avgy() (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_avgy,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_avgy() is 'average of the dependent variable (sum(Y)/N)';

alter aggregate pg_catalog.regr_avgy() owner to postgres;

create aggregate pg_catalog.regr_r2() (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_r2,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_r2() is 'square of the correlation coefficient';

alter aggregate pg_catalog.regr_r2() owner to postgres;

create aggregate pg_catalog.regr_slope() (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_slope,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_slope() is 'slope of the least-squares-fit linear equation determined by the (X, Y) pairs';

alter aggregate pg_catalog.regr_slope() owner to postgres;

create aggregate pg_catalog.regr_intercept() (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_intercept,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_intercept() is 'y-intercept of the least-squares-fit linear equation determined by the (X, Y) pairs';

alter aggregate pg_catalog.regr_intercept() owner to postgres;

create aggregate pg_catalog.covar_pop() (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_covar_pop,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.covar_pop() is 'population covariance';

alter aggregate pg_catalog.covar_pop() owner to postgres;

create aggregate pg_catalog.covar_samp() (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_covar_samp,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.covar_samp() is 'sample covariance';

alter aggregate pg_catalog.covar_samp() owner to postgres;

create aggregate pg_catalog.corr() (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_corr,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.corr() is 'correlation coefficient';

alter aggregate pg_catalog.corr() owner to postgres;

create aggregate pg_catalog.xmlagg() (
    sfunc = xmlconcat2,
    stype = xml,
    parallel = safe
    );

comment on aggregate pg_catalog.xmlagg() is 'concatenate XML values';

alter aggregate pg_catalog.xmlagg() owner to postgres;

create aggregate pg_catalog.json_agg() (
    sfunc = json_agg_transfn,
    stype = internal,
    finalfunc = json_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.json_agg() is 'aggregate input into json';

alter aggregate pg_catalog.json_agg() owner to postgres;

create aggregate pg_catalog.json_object_agg() (
    sfunc = json_object_agg_transfn,
    stype = internal,
    finalfunc = json_object_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.json_object_agg() is 'aggregate input into a json object';

alter aggregate pg_catalog.json_object_agg() owner to postgres;

create aggregate pg_catalog.jsonb_agg() (
    sfunc = jsonb_agg_transfn,
    stype = internal,
    finalfunc = jsonb_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.jsonb_agg() is 'aggregate input into jsonb';

alter aggregate pg_catalog.jsonb_agg() owner to postgres;

create aggregate pg_catalog.jsonb_object_agg() (
    sfunc = jsonb_object_agg_transfn,
    stype = internal,
    finalfunc = jsonb_object_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.jsonb_object_agg() is 'aggregate inputs into jsonb object';

alter aggregate pg_catalog.jsonb_object_agg() owner to postgres;

create aggregate pg_catalog.string_agg() (
    sfunc = string_agg_transfn,
    stype = internal,
    finalfunc = string_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.string_agg() is 'concatenate aggregate input into a string';

alter aggregate pg_catalog.string_agg() owner to postgres;

create aggregate pg_catalog.string_agg() (
    sfunc = bytea_string_agg_transfn,
    stype = internal,
    finalfunc = bytea_string_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.string_agg() is 'concatenate aggregate input into a bytea';

alter aggregate pg_catalog.string_agg() owner to postgres;

create aggregate pg_catalog.percentile_disc() (
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_disc_final,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_disc() is 'discrete percentile';

alter aggregate pg_catalog.percentile_disc() owner to postgres;

create aggregate pg_catalog.percentile_cont() (
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_cont_float8_final,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_cont() is 'continuous distribution percentile';

alter aggregate pg_catalog.percentile_cont() owner to postgres;

create aggregate pg_catalog.percentile_cont() (
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_cont_interval_final,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_cont() is 'continuous distribution percentile';

alter aggregate pg_catalog.percentile_cont() owner to postgres;

create aggregate pg_catalog.percentile_disc() (
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_disc_multi_final,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_disc() is 'multiple discrete percentiles';

alter aggregate pg_catalog.percentile_disc() owner to postgres;

create aggregate pg_catalog.percentile_cont() (
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_cont_float8_multi_final,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_cont() is 'multiple continuous percentiles';

alter aggregate pg_catalog.percentile_cont() owner to postgres;

create aggregate pg_catalog.percentile_cont() (
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_cont_interval_multi_final,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_cont() is 'multiple continuous percentiles';

alter aggregate pg_catalog.percentile_cont() owner to postgres;

create aggregate pg_catalog.mode() (
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = mode_final,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.mode() is 'most common value';

alter aggregate pg_catalog.mode() owner to postgres;

create aggregate pg_catalog.rank() (
    sfunc = ordered_set_transition_multi,
    stype = internal,
    finalfunc = rank_final,
    finalfunc_extra,
    parallel = safe,
    hypothetical
    );

comment on aggregate pg_catalog.rank() is 'rank of hypothetical row';

alter aggregate pg_catalog.rank() owner to postgres;

create aggregate pg_catalog.percent_rank() (
    sfunc = ordered_set_transition_multi,
    stype = internal,
    finalfunc = percent_rank_final,
    finalfunc_extra,
    parallel = safe,
    hypothetical
    );

comment on aggregate pg_catalog.percent_rank() is 'fractional rank of hypothetical row';

alter aggregate pg_catalog.percent_rank() owner to postgres;

create aggregate pg_catalog.cume_dist() (
    sfunc = ordered_set_transition_multi,
    stype = internal,
    finalfunc = cume_dist_final,
    finalfunc_extra,
    parallel = safe,
    hypothetical
    );

comment on aggregate pg_catalog.cume_dist() is 'cumulative distribution of hypothetical row';

alter aggregate pg_catalog.cume_dist() owner to postgres;

create aggregate pg_catalog.dense_rank() (
    sfunc = ordered_set_transition_multi,
    stype = internal,
    finalfunc = dense_rank_final,
    finalfunc_extra,
    parallel = safe,
    hypothetical
    );

comment on aggregate pg_catalog.dense_rank() is 'rank of hypothetical row without gaps';

alter aggregate pg_catalog.dense_rank() owner to postgres;

create aggregate pg_catalog.array_agg(anyarray) (
    sfunc = array_agg_array_transfn,
    stype = internal,
    finalfunc = array_agg_array_finalfn,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.array_agg(anyarray) is 'concatenate aggregate input into an array';

alter aggregate pg_catalog.array_agg(anyarray) owner to postgres;

create operator family pg_catalog.array_ops using btree;

alter operator family pg_catalog.array_ops using btree add
    function 1(anyarray, anyarray) pg_catalog.btarraycmp();

alter operator family pg_catalog.array_ops using btree owner to postgres;

create operator class pg_catalog.array_ops default for type anyarray using btree as
    operator 1 pg_catalog.<(anyarray, anyarray),
    operator 2 pg_catalog.<=(anyarray, anyarray),
    operator 3 pg_catalog.=(anyarray, anyarray),
    operator 4 pg_catalog.>=(anyarray, anyarray),
    operator 5 pg_catalog.>(anyarray, anyarray);

alter operator class pg_catalog.array_ops using btree owner to postgres;

create operator family pg_catalog.bit_ops using btree;

alter operator family pg_catalog.bit_ops using btree add
    function 1(bit, bit) pg_catalog.bitcmp();

alter operator family pg_catalog.bit_ops using btree owner to postgres;

create operator class pg_catalog.bit_ops default for type bit using btree as
    operator 1 pg_catalog.<(bit, bit),
    operator 2 pg_catalog.<=(bit, bit),
    operator 3 pg_catalog.=(bit, bit),
    operator 4 pg_catalog.>=(bit, bit),
    operator 5 pg_catalog.>(bit, bit);

alter operator class pg_catalog.bit_ops using btree owner to postgres;

create operator family pg_catalog.bool_ops using btree;

alter operator family pg_catalog.bool_ops using btree add
    function 1(boolean, boolean) pg_catalog.btboolcmp();

alter operator family pg_catalog.bool_ops using btree owner to postgres;

create operator class pg_catalog.bool_ops default for type boolean using btree as
    operator 1 pg_catalog.<(boolean, boolean),
    operator 2 pg_catalog.<=(boolean, boolean),
    operator 3 pg_catalog.=(boolean, boolean),
    operator 4 pg_catalog.>=(boolean, boolean),
    operator 5 pg_catalog.>(boolean, boolean);

alter operator class pg_catalog.bool_ops using btree owner to postgres;

create operator family pg_catalog.bpchar_ops using btree;

alter operator family pg_catalog.bpchar_ops using btree add
    function 1(character, character) pg_catalog.bpcharcmp(),
    function 2(character, character) pg_catalog.bpchar_sortsupport();

alter operator family pg_catalog.bpchar_ops using btree owner to postgres;

create operator class pg_catalog.bpchar_ops default for type character using btree as
    operator 1 pg_catalog.<(char, char),
    operator 2 pg_catalog.<=(char, char),
    operator 3 pg_catalog.=(char, char),
    operator 4 pg_catalog.>=(char, char),
    operator 5 pg_catalog.>(char, char);

alter operator class pg_catalog.bpchar_ops using btree owner to postgres;

create operator family pg_catalog.bpchar_ops using hash;

alter operator family pg_catalog.bpchar_ops using hash add
    function 1(character, character) pg_catalog.hashbpchar(),
    function 2(character, character) pg_catalog.hashbpcharextended();

alter operator family pg_catalog.bpchar_ops using hash owner to postgres;

create operator class pg_catalog.bpchar_ops default for type character using hash as
    operator 1 pg_catalog.=(char, char);

alter operator class pg_catalog.bpchar_ops using hash owner to postgres;

create operator family pg_catalog.bytea_ops using btree;

alter operator family pg_catalog.bytea_ops using btree add
    function 1(bytea, bytea) pg_catalog.byteacmp(),
    function 2(bytea, bytea) pg_catalog.bytea_sortsupport();

alter operator family pg_catalog.bytea_ops using btree owner to postgres;

create operator class pg_catalog.bytea_ops default for type bytea using btree as
    operator 1 pg_catalog.<(bytea, bytea),
    operator 2 pg_catalog.<=(bytea, bytea),
    operator 3 pg_catalog.=(bytea, bytea),
    operator 4 pg_catalog.>=(bytea, bytea),
    operator 5 pg_catalog.>(bytea, bytea);

alter operator class pg_catalog.bytea_ops using btree owner to postgres;

create operator family pg_catalog.char_ops using btree;

alter operator family pg_catalog.char_ops using btree add
    function 1("char", "char") pg_catalog.btcharcmp();

alter operator family pg_catalog.char_ops using btree owner to postgres;

create operator class pg_catalog.char_ops default for type "char" using btree as
    operator 1 pg_catalog.<("char", "char"),
    operator 2 pg_catalog.<=("char", "char"),
    operator 3 pg_catalog.=("char", "char"),
    operator 4 pg_catalog.>=("char", "char"),
    operator 5 pg_catalog.>("char", "char");

alter operator class pg_catalog.char_ops using btree owner to postgres;

create operator family pg_catalog.char_ops using hash;

alter operator family pg_catalog.char_ops using hash add
    function 1("char", "char") pg_catalog.hashchar(),
    function 2("char", "char") pg_catalog.hashcharextended();

alter operator family pg_catalog.char_ops using hash owner to postgres;

create operator class pg_catalog.char_ops default for type "char" using hash as
    operator 1 pg_catalog.=("char", "char");

alter operator class pg_catalog.char_ops using hash owner to postgres;

create operator family pg_catalog.datetime_ops using btree;

alter operator family pg_catalog.datetime_ops using btree add
    function 1(date, date) pg_catalog.date_cmp(),
    function 2(date, date) pg_catalog.date_sortsupport(),
    function 1(date, timestamp without time zone) pg_catalog.date_cmp_timestamp(),
    function 1(date, timestamp with time zone) pg_catalog.date_cmp_timestamptz(),
    function 1(timestamp without time zone, timestamp without time zone) pg_catalog.timestamp_cmp(),
    function 2(timestamp without time zone, timestamp without time zone) pg_catalog.timestamp_sortsupport(),
    function 1(timestamp without time zone, date) pg_catalog.timestamp_cmp_date(),
    function 1(timestamp without time zone, timestamp with time zone) pg_catalog.timestamp_cmp_timestamptz(),
    function 1(timestamp with time zone, timestamp with time zone) pg_catalog.timestamptz_cmp(),
    function 2(timestamp with time zone, timestamp with time zone) pg_catalog.timestamp_sortsupport(),
    function 1(timestamp with time zone, date) pg_catalog.timestamptz_cmp_date(),
    function 1(timestamp with time zone, timestamp without time zone) pg_catalog.timestamptz_cmp_timestamp(),
    function 3(date, interval) pg_catalog.in_range(date, date, interval),
    function 3(timestamp without time zone, interval) pg_catalog.in_range(timestamp, timestamp, interval),
    function 3(timestamp with time zone, interval) pg_catalog.in_range(timestamp with time zone, timestamp with time zone);

alter operator family pg_catalog.datetime_ops using btree owner to postgres;

create operator class pg_catalog.date_ops default for type date using btree family pg_catalog.datetime_ops as
    operator 1 pg_catalog.<(date, date),
    operator 2 pg_catalog.<=(date, date),
    operator 3 pg_catalog.=(date, date),
    operator 4 pg_catalog.>=(date, date),
    operator 5 pg_catalog.>(date, date),
    operator 1 pg_catalog.<(date, timestamp),
    operator 2 pg_catalog.<=(date, timestamp),
    operator 3 pg_catalog.=(date, timestamp),
    operator 4 pg_catalog.>=(date, timestamp),
    operator 5 pg_catalog.>(date, timestamp),
    operator 1 pg_catalog.<(date, timestamp with time zone),
    operator 2 pg_catalog.<=(date, timestamp with time zone),
    operator 3 pg_catalog.=(date, timestamp with time zone),
    operator 4 pg_catalog.>=(date, timestamp with time zone),
    operator 5 pg_catalog.>(date, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp, timestamp),
    operator 2 pg_catalog.<=(timestamp, timestamp),
    operator 3 pg_catalog.=(timestamp, timestamp),
    operator 4 pg_catalog.>=(timestamp, timestamp),
    operator 5 pg_catalog.>(timestamp, timestamp),
    operator 1 pg_catalog.<(timestamp, date),
    operator 2 pg_catalog.<=(timestamp, date),
    operator 3 pg_catalog.=(timestamp, date),
    operator 4 pg_catalog.>=(timestamp, date),
    operator 5 pg_catalog.>(timestamp, date),
    operator 1 pg_catalog.<(timestamp, timestamp with time zone),
    operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
    operator 3 pg_catalog.=(timestamp, timestamp with time zone),
    operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
    operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
    operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
    operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp with time zone, date),
    operator 2 pg_catalog.<=(timestamp with time zone, date),
    operator 3 pg_catalog.=(timestamp with time zone, date),
    operator 4 pg_catalog.>=(timestamp with time zone, date),
    operator 5 pg_catalog.>(timestamp with time zone, date),
    operator 1 pg_catalog.<(timestamp with time zone, timestamp),
    operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
    operator 3 pg_catalog.=(timestamp with time zone, timestamp),
    operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
    operator 5 pg_catalog.>(timestamp with time zone, timestamp);

alter operator class pg_catalog.date_ops using btree owner to postgres;

create operator class pg_catalog.timestamptz_ops default for type timestamp with time zone using btree family pg_catalog.datetime_ops as
    operator 1 pg_catalog.<(date, date),
    operator 2 pg_catalog.<=(date, date),
    operator 3 pg_catalog.=(date, date),
    operator 4 pg_catalog.>=(date, date),
    operator 5 pg_catalog.>(date, date),
    operator 1 pg_catalog.<(date, timestamp),
    operator 2 pg_catalog.<=(date, timestamp),
    operator 3 pg_catalog.=(date, timestamp),
    operator 4 pg_catalog.>=(date, timestamp),
    operator 5 pg_catalog.>(date, timestamp),
    operator 1 pg_catalog.<(date, timestamp with time zone),
    operator 2 pg_catalog.<=(date, timestamp with time zone),
    operator 3 pg_catalog.=(date, timestamp with time zone),
    operator 4 pg_catalog.>=(date, timestamp with time zone),
    operator 5 pg_catalog.>(date, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp, timestamp),
    operator 2 pg_catalog.<=(timestamp, timestamp),
    operator 3 pg_catalog.=(timestamp, timestamp),
    operator 4 pg_catalog.>=(timestamp, timestamp),
    operator 5 pg_catalog.>(timestamp, timestamp),
    operator 1 pg_catalog.<(timestamp, date),
    operator 2 pg_catalog.<=(timestamp, date),
    operator 3 pg_catalog.=(timestamp, date),
    operator 4 pg_catalog.>=(timestamp, date),
    operator 5 pg_catalog.>(timestamp, date),
    operator 1 pg_catalog.<(timestamp, timestamp with time zone),
    operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
    operator 3 pg_catalog.=(timestamp, timestamp with time zone),
    operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
    operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
    operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
    operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp with time zone, date),
    operator 2 pg_catalog.<=(timestamp with time zone, date),
    operator 3 pg_catalog.=(timestamp with time zone, date),
    operator 4 pg_catalog.>=(timestamp with time zone, date),
    operator 5 pg_catalog.>(timestamp with time zone, date),
    operator 1 pg_catalog.<(timestamp with time zone, timestamp),
    operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
    operator 3 pg_catalog.=(timestamp with time zone, timestamp),
    operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
    operator 5 pg_catalog.>(timestamp with time zone, timestamp);

alter operator class pg_catalog.timestamptz_ops using btree owner to postgres;

create operator class pg_catalog.timestamp_ops default for type timestamp without time zone using btree family pg_catalog.datetime_ops as
    operator 1 pg_catalog.<(date, date),
    operator 2 pg_catalog.<=(date, date),
    operator 3 pg_catalog.=(date, date),
    operator 4 pg_catalog.>=(date, date),
    operator 5 pg_catalog.>(date, date),
    operator 1 pg_catalog.<(date, timestamp),
    operator 2 pg_catalog.<=(date, timestamp),
    operator 3 pg_catalog.=(date, timestamp),
    operator 4 pg_catalog.>=(date, timestamp),
    operator 5 pg_catalog.>(date, timestamp),
    operator 1 pg_catalog.<(date, timestamp with time zone),
    operator 2 pg_catalog.<=(date, timestamp with time zone),
    operator 3 pg_catalog.=(date, timestamp with time zone),
    operator 4 pg_catalog.>=(date, timestamp with time zone),
    operator 5 pg_catalog.>(date, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp, timestamp),
    operator 2 pg_catalog.<=(timestamp, timestamp),
    operator 3 pg_catalog.=(timestamp, timestamp),
    operator 4 pg_catalog.>=(timestamp, timestamp),
    operator 5 pg_catalog.>(timestamp, timestamp),
    operator 1 pg_catalog.<(timestamp, date),
    operator 2 pg_catalog.<=(timestamp, date),
    operator 3 pg_catalog.=(timestamp, date),
    operator 4 pg_catalog.>=(timestamp, date),
    operator 5 pg_catalog.>(timestamp, date),
    operator 1 pg_catalog.<(timestamp, timestamp with time zone),
    operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
    operator 3 pg_catalog.=(timestamp, timestamp with time zone),
    operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
    operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
    operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
    operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp with time zone, date),
    operator 2 pg_catalog.<=(timestamp with time zone, date),
    operator 3 pg_catalog.=(timestamp with time zone, date),
    operator 4 pg_catalog.>=(timestamp with time zone, date),
    operator 5 pg_catalog.>(timestamp with time zone, date),
    operator 1 pg_catalog.<(timestamp with time zone, timestamp),
    operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
    operator 3 pg_catalog.=(timestamp with time zone, timestamp),
    operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
    operator 5 pg_catalog.>(timestamp with time zone, timestamp);

alter operator class pg_catalog.timestamp_ops using btree owner to postgres;

create operator family pg_catalog.date_ops using hash;

alter operator family pg_catalog.date_ops using hash add
    function 1(date, date) pg_catalog.hashint4(),
    function 2(date, date) pg_catalog.hashint4extended();

alter operator family pg_catalog.date_ops using hash owner to postgres;

create operator class pg_catalog.date_ops default for type date using hash as
    operator 1 pg_catalog.=(date, date);

alter operator class pg_catalog.date_ops using hash owner to postgres;

create operator family pg_catalog.array_ops using hash;

alter operator family pg_catalog.array_ops using hash add
    function 1(anyarray, anyarray) pg_catalog.hash_array(),
    function 2(anyarray, anyarray) pg_catalog.hash_array_extended();

alter operator family pg_catalog.array_ops using hash owner to postgres;

create operator class pg_catalog.array_ops default for type anyarray using hash as
    operator 1 pg_catalog.=(anyarray, anyarray);

alter operator class pg_catalog.array_ops using hash owner to postgres;

create operator family pg_catalog.point_ops using gist;

alter operator family pg_catalog.point_ops using gist add
    function 1(point, point) pg_catalog.gist_point_consistent(),
    function 2(point, point) pg_catalog.gist_box_union(),
    function 3(point, point) pg_catalog.gist_point_compress(),
    function 5(point, point) pg_catalog.gist_box_penalty(),
    function 6(point, point) pg_catalog.gist_box_picksplit(),
    function 7(point, point) pg_catalog.gist_box_same(),
    function 8(point, point) pg_catalog.gist_point_distance(),
    function 9(point, point) pg_catalog.gist_point_fetch();

alter operator family pg_catalog.point_ops using gist owner to postgres;

create operator class pg_catalog.point_ops default for type point using gist as storage box operator 11 pg_catalog.>^(point, point),
	operator 1 pg_catalog.<<(point, point),
	operator 5 pg_catalog.>>(point, point),
	operator 10 pg_catalog.<^(point, point),
	operator 6 pg_catalog.~=(point, point),
	operator 15 pg_catalog.<->(point, point) for order by float_ops,
	operator 28 pg_catalog.<@(point, box),
	operator 48 pg_catalog.<@(point, polygon),
	operator 68 pg_catalog.<@(point, circle);

alter operator class pg_catalog.point_ops using gist owner to postgres;

create operator family pg_catalog.float_ops using btree;

alter operator family pg_catalog.float_ops using btree add
    function 1(real, real) pg_catalog.btfloat4cmp(),
    function 2(real, real) pg_catalog.btfloat4sortsupport(),
    function 1(real, double precision) pg_catalog.btfloat48cmp(),
    function 1(double precision, double precision) pg_catalog.btfloat8cmp(),
    function 2(double precision, double precision) pg_catalog.btfloat8sortsupport(),
    function 1(double precision, real) pg_catalog.btfloat84cmp(),
    function 3(double precision, double precision) pg_catalog.in_range(double precision, double precision, double precision),
    function 3(real, double precision) pg_catalog.in_range();

alter operator family pg_catalog.float_ops using btree owner to postgres;

create operator class pg_catalog.float8_ops default for type double precision using btree family pg_catalog.float_ops as
    operator 1 pg_catalog.<(real, real),
    operator 2 pg_catalog.<=(real, real),
    operator 3 pg_catalog.=(real, real),
    operator 4 pg_catalog.>=(real, real),
    operator 5 pg_catalog.>(real, real),
    operator 1 pg_catalog.<(real, double precision),
    operator 2 pg_catalog.<=(real, double precision),
    operator 3 pg_catalog.=(real, double precision),
    operator 4 pg_catalog.>=(real, double precision),
    operator 5 pg_catalog.>(real, double precision),
    operator 1 pg_catalog.<(double precision, double precision),
    operator 2 pg_catalog.<=(double precision, double precision),
    operator 3 pg_catalog.=(double precision, double precision),
    operator 4 pg_catalog.>=(double precision, double precision),
    operator 5 pg_catalog.>(double precision, double precision),
    operator 1 pg_catalog.<(double precision, real),
    operator 2 pg_catalog.<=(double precision, real),
    operator 3 pg_catalog.=(double precision, real),
    operator 4 pg_catalog.>=(double precision, real),
    operator 5 pg_catalog.>(double precision, real);

alter operator class pg_catalog.float8_ops using btree owner to postgres;

create operator class pg_catalog.float4_ops default for type real using btree family pg_catalog.float_ops as
    operator 1 pg_catalog.<(real, real),
    operator 2 pg_catalog.<=(real, real),
    operator 3 pg_catalog.=(real, real),
    operator 4 pg_catalog.>=(real, real),
    operator 5 pg_catalog.>(real, real),
    operator 1 pg_catalog.<(real, double precision),
    operator 2 pg_catalog.<=(real, double precision),
    operator 3 pg_catalog.=(real, double precision),
    operator 4 pg_catalog.>=(real, double precision),
    operator 5 pg_catalog.>(real, double precision),
    operator 1 pg_catalog.<(double precision, double precision),
    operator 2 pg_catalog.<=(double precision, double precision),
    operator 3 pg_catalog.=(double precision, double precision),
    operator 4 pg_catalog.>=(double precision, double precision),
    operator 5 pg_catalog.>(double precision, double precision),
    operator 1 pg_catalog.<(double precision, real),
    operator 2 pg_catalog.<=(double precision, real),
    operator 3 pg_catalog.=(double precision, real),
    operator 4 pg_catalog.>=(double precision, real),
    operator 5 pg_catalog.>(double precision, real);

alter operator class pg_catalog.float4_ops using btree owner to postgres;

create operator family pg_catalog.float_ops using hash;

alter operator family pg_catalog.float_ops using hash add
    function 1(real, real) pg_catalog.hashfloat4(),
    function 2(real, real) pg_catalog.hashfloat4extended(),
    function 1(double precision, double precision) pg_catalog.hashfloat8(),
    function 2(double precision, double precision) pg_catalog.hashfloat8extended();

alter operator family pg_catalog.float_ops using hash owner to postgres;

create operator class pg_catalog.float4_ops default for type real using hash family pg_catalog.float_ops as
    operator 1 pg_catalog.=(real, real),
    operator 1 pg_catalog.=(double precision, double precision),
    operator 1 pg_catalog.=(real, double precision),
    operator 1 pg_catalog.=(double precision, real);

alter operator class pg_catalog.float4_ops using hash owner to postgres;

create operator class pg_catalog.float8_ops default for type double precision using hash family pg_catalog.float_ops as
    operator 1 pg_catalog.=(real, real),
    operator 1 pg_catalog.=(double precision, double precision),
    operator 1 pg_catalog.=(real, double precision),
    operator 1 pg_catalog.=(double precision, real);

alter operator class pg_catalog.float8_ops using hash owner to postgres;

create operator family pg_catalog.network_ops using btree;

alter operator family pg_catalog.network_ops using btree add
    function 1(inet, inet) pg_catalog.network_cmp();

alter operator family pg_catalog.network_ops using btree owner to postgres;

create operator class pg_catalog.cidr_ops for type inet using btree family pg_catalog.network_ops as
    operator 1 pg_catalog.<(inet, inet),
    operator 2 pg_catalog.<=(inet, inet),
    operator 3 pg_catalog.=(inet, inet),
    operator 4 pg_catalog.>=(inet, inet),
    operator 5 pg_catalog.>(inet, inet);

alter operator class pg_catalog.cidr_ops using btree owner to postgres;

create operator class pg_catalog.inet_ops default for type inet using btree family pg_catalog.network_ops as
    operator 1 pg_catalog.<(inet, inet),
    operator 2 pg_catalog.<=(inet, inet),
    operator 3 pg_catalog.=(inet, inet),
    operator 4 pg_catalog.>=(inet, inet),
    operator 5 pg_catalog.>(inet, inet);

alter operator class pg_catalog.inet_ops using btree owner to postgres;

create operator family pg_catalog.network_ops using hash;

alter operator family pg_catalog.network_ops using hash add
    function 1(inet, inet) pg_catalog.hashinet(),
    function 2(inet, inet) pg_catalog.hashinetextended();

alter operator family pg_catalog.network_ops using hash owner to postgres;

create operator class pg_catalog.cidr_ops for type inet using hash family pg_catalog.network_ops as
    operator 1 pg_catalog.=(inet, inet);

alter operator class pg_catalog.cidr_ops using hash owner to postgres;

create operator class pg_catalog.inet_ops default for type inet using hash family pg_catalog.network_ops as
    operator 1 pg_catalog.=(inet, inet);

alter operator class pg_catalog.inet_ops using hash owner to postgres;

create operator family pg_catalog.integer_ops using btree;

alter operator family pg_catalog.integer_ops using btree add
    function 1(smallint, smallint) pg_catalog.btint2cmp(),
    function 2(smallint, smallint) pg_catalog.btint2sortsupport(),
    function 1(smallint, integer) pg_catalog.btint24cmp(),
    function 1(smallint, bigint) pg_catalog.btint28cmp(),
    function 3(smallint, bigint) pg_catalog.in_range(smallint, smallint, bigint),
    function 3(smallint, integer) pg_catalog.in_range(smallint, smallint, integer),
    function 3(smallint, smallint) pg_catalog.in_range(smallint, smallint, smallint),
    function 1(integer, integer) pg_catalog.btint4cmp(),
    function 2(integer, integer) pg_catalog.btint4sortsupport(),
    function 1(integer, bigint) pg_catalog.btint48cmp(),
    function 1(integer, smallint) pg_catalog.btint42cmp(),
    function 3(integer, bigint) pg_catalog.in_range(integer, integer, bigint),
    function 3(integer, integer) pg_catalog.in_range(integer, integer, integer),
    function 3(integer, smallint) pg_catalog.in_range(smallint),
    function 1(bigint, bigint) pg_catalog.btint8cmp(),
    function 2(bigint, bigint) pg_catalog.btint8sortsupport(),
    function 1(bigint, integer) pg_catalog.btint84cmp(),
    function 1(bigint, smallint) pg_catalog.btint82cmp(),
    function 3(bigint, bigint) pg_catalog.in_range();

alter operator family pg_catalog.integer_ops using btree owner to postgres;

create operator class pg_catalog.int4_ops default for type integer using btree family pg_catalog.integer_ops as
    operator 1 pg_catalog.<(smallint, smallint),
    operator 2 pg_catalog.<=(smallint, smallint),
    operator 3 pg_catalog.=(smallint, smallint),
    operator 4 pg_catalog.>=(smallint, smallint),
    operator 5 pg_catalog.>(smallint, smallint),
    operator 1 pg_catalog.<(smallint, integer),
    operator 2 pg_catalog.<=(smallint, integer),
    operator 3 pg_catalog.=(smallint, integer),
    operator 4 pg_catalog.>=(smallint, integer),
    operator 5 pg_catalog.>(smallint, integer),
    operator 1 pg_catalog.<(smallint, bigint),
    operator 2 pg_catalog.<=(smallint, bigint),
    operator 3 pg_catalog.=(smallint, bigint),
    operator 4 pg_catalog.>=(smallint, bigint),
    operator 5 pg_catalog.>(smallint, bigint),
    operator 1 pg_catalog.<(integer, integer),
    operator 2 pg_catalog.<=(integer, integer),
    operator 3 pg_catalog.=(integer, integer),
    operator 4 pg_catalog.>=(integer, integer),
    operator 5 pg_catalog.>(integer, integer),
    operator 1 pg_catalog.<(integer, smallint),
    operator 2 pg_catalog.<=(integer, smallint),
    operator 3 pg_catalog.=(integer, smallint),
    operator 4 pg_catalog.>=(integer, smallint),
    operator 5 pg_catalog.>(integer, smallint),
    operator 1 pg_catalog.<(integer, bigint),
    operator 2 pg_catalog.<=(integer, bigint),
    operator 3 pg_catalog.=(integer, bigint),
    operator 4 pg_catalog.>=(integer, bigint),
    operator 5 pg_catalog.>(integer, bigint),
    operator 1 pg_catalog.<(bigint, bigint),
    operator 2 pg_catalog.<=(bigint, bigint),
    operator 3 pg_catalog.=(bigint, bigint),
    operator 4 pg_catalog.>=(bigint, bigint),
    operator 5 pg_catalog.>(bigint, bigint),
    operator 1 pg_catalog.<(bigint, smallint),
    operator 2 pg_catalog.<=(bigint, smallint),
    operator 3 pg_catalog.=(bigint, smallint),
    operator 4 pg_catalog.>=(bigint, smallint),
    operator 5 pg_catalog.>(bigint, smallint),
    operator 1 pg_catalog.<(bigint, integer),
    operator 2 pg_catalog.<=(bigint, integer),
    operator 3 pg_catalog.=(bigint, integer),
    operator 4 pg_catalog.>=(bigint, integer),
    operator 5 pg_catalog.>(bigint, integer);

alter operator class pg_catalog.int4_ops using btree owner to postgres;

create operator class pg_catalog.int2_ops default for type smallint using btree family pg_catalog.integer_ops as
    operator 1 pg_catalog.<(smallint, smallint),
    operator 2 pg_catalog.<=(smallint, smallint),
    operator 3 pg_catalog.=(smallint, smallint),
    operator 4 pg_catalog.>=(smallint, smallint),
    operator 5 pg_catalog.>(smallint, smallint),
    operator 1 pg_catalog.<(smallint, integer),
    operator 2 pg_catalog.<=(smallint, integer),
    operator 3 pg_catalog.=(smallint, integer),
    operator 4 pg_catalog.>=(smallint, integer),
    operator 5 pg_catalog.>(smallint, integer),
    operator 1 pg_catalog.<(smallint, bigint),
    operator 2 pg_catalog.<=(smallint, bigint),
    operator 3 pg_catalog.=(smallint, bigint),
    operator 4 pg_catalog.>=(smallint, bigint),
    operator 5 pg_catalog.>(smallint, bigint),
    operator 1 pg_catalog.<(integer, integer),
    operator 2 pg_catalog.<=(integer, integer),
    operator 3 pg_catalog.=(integer, integer),
    operator 4 pg_catalog.>=(integer, integer),
    operator 5 pg_catalog.>(integer, integer),
    operator 1 pg_catalog.<(integer, smallint),
    operator 2 pg_catalog.<=(integer, smallint),
    operator 3 pg_catalog.=(integer, smallint),
    operator 4 pg_catalog.>=(integer, smallint),
    operator 5 pg_catalog.>(integer, smallint),
    operator 1 pg_catalog.<(integer, bigint),
    operator 2 pg_catalog.<=(integer, bigint),
    operator 3 pg_catalog.=(integer, bigint),
    operator 4 pg_catalog.>=(integer, bigint),
    operator 5 pg_catalog.>(integer, bigint),
    operator 1 pg_catalog.<(bigint, bigint),
    operator 2 pg_catalog.<=(bigint, bigint),
    operator 3 pg_catalog.=(bigint, bigint),
    operator 4 pg_catalog.>=(bigint, bigint),
    operator 5 pg_catalog.>(bigint, bigint),
    operator 1 pg_catalog.<(bigint, smallint),
    operator 2 pg_catalog.<=(bigint, smallint),
    operator 3 pg_catalog.=(bigint, smallint),
    operator 4 pg_catalog.>=(bigint, smallint),
    operator 5 pg_catalog.>(bigint, smallint),
    operator 1 pg_catalog.<(bigint, integer),
    operator 2 pg_catalog.<=(bigint, integer),
    operator 3 pg_catalog.=(bigint, integer),
    operator 4 pg_catalog.>=(bigint, integer),
    operator 5 pg_catalog.>(bigint, integer);

alter operator class pg_catalog.int2_ops using btree owner to postgres;

create operator class pg_catalog.int8_ops default for type bigint using btree family pg_catalog.integer_ops as
    operator 1 pg_catalog.<(smallint, smallint),
    operator 2 pg_catalog.<=(smallint, smallint),
    operator 3 pg_catalog.=(smallint, smallint),
    operator 4 pg_catalog.>=(smallint, smallint),
    operator 5 pg_catalog.>(smallint, smallint),
    operator 1 pg_catalog.<(smallint, integer),
    operator 2 pg_catalog.<=(smallint, integer),
    operator 3 pg_catalog.=(smallint, integer),
    operator 4 pg_catalog.>=(smallint, integer),
    operator 5 pg_catalog.>(smallint, integer),
    operator 1 pg_catalog.<(smallint, bigint),
    operator 2 pg_catalog.<=(smallint, bigint),
    operator 3 pg_catalog.=(smallint, bigint),
    operator 4 pg_catalog.>=(smallint, bigint),
    operator 5 pg_catalog.>(smallint, bigint),
    operator 1 pg_catalog.<(integer, integer),
    operator 2 pg_catalog.<=(integer, integer),
    operator 3 pg_catalog.=(integer, integer),
    operator 4 pg_catalog.>=(integer, integer),
    operator 5 pg_catalog.>(integer, integer),
    operator 1 pg_catalog.<(integer, smallint),
    operator 2 pg_catalog.<=(integer, smallint),
    operator 3 pg_catalog.=(integer, smallint),
    operator 4 pg_catalog.>=(integer, smallint),
    operator 5 pg_catalog.>(integer, smallint),
    operator 1 pg_catalog.<(integer, bigint),
    operator 2 pg_catalog.<=(integer, bigint),
    operator 3 pg_catalog.=(integer, bigint),
    operator 4 pg_catalog.>=(integer, bigint),
    operator 5 pg_catalog.>(integer, bigint),
    operator 1 pg_catalog.<(bigint, bigint),
    operator 2 pg_catalog.<=(bigint, bigint),
    operator 3 pg_catalog.=(bigint, bigint),
    operator 4 pg_catalog.>=(bigint, bigint),
    operator 5 pg_catalog.>(bigint, bigint),
    operator 1 pg_catalog.<(bigint, smallint),
    operator 2 pg_catalog.<=(bigint, smallint),
    operator 3 pg_catalog.=(bigint, smallint),
    operator 4 pg_catalog.>=(bigint, smallint),
    operator 5 pg_catalog.>(bigint, smallint),
    operator 1 pg_catalog.<(bigint, integer),
    operator 2 pg_catalog.<=(bigint, integer),
    operator 3 pg_catalog.=(bigint, integer),
    operator 4 pg_catalog.>=(bigint, integer),
    operator 5 pg_catalog.>(bigint, integer);

alter operator class pg_catalog.int8_ops using btree owner to postgres;

create operator family pg_catalog.integer_ops using hash;

alter operator family pg_catalog.integer_ops using hash add
    function 1(smallint, smallint) pg_catalog.hashint2(),
    function 2(smallint, smallint) pg_catalog.hashint2extended(),
    function 1(integer, integer) pg_catalog.hashint4(),
    function 2(integer, integer) pg_catalog.hashint4extended(),
    function 1(bigint, bigint) pg_catalog.hashint8(),
    function 2(bigint, bigint) pg_catalog.hashint8extended();

alter operator family pg_catalog.integer_ops using hash owner to postgres;

create operator class pg_catalog.int2_ops default for type smallint using hash family pg_catalog.integer_ops as
    operator 1 pg_catalog.=(smallint, smallint),
    operator 1 pg_catalog.=(integer, integer),
    operator 1 pg_catalog.=(bigint, bigint),
    operator 1 pg_catalog.=(smallint, integer),
    operator 1 pg_catalog.=(smallint, bigint),
    operator 1 pg_catalog.=(integer, smallint),
    operator 1 pg_catalog.=(integer, bigint),
    operator 1 pg_catalog.=(bigint, smallint),
    operator 1 pg_catalog.=(bigint, integer);

alter operator class pg_catalog.int2_ops using hash owner to postgres;

create operator class pg_catalog.int4_ops default for type integer using hash family pg_catalog.integer_ops as
    operator 1 pg_catalog.=(smallint, smallint),
    operator 1 pg_catalog.=(integer, integer),
    operator 1 pg_catalog.=(bigint, bigint),
    operator 1 pg_catalog.=(smallint, integer),
    operator 1 pg_catalog.=(smallint, bigint),
    operator 1 pg_catalog.=(integer, smallint),
    operator 1 pg_catalog.=(integer, bigint),
    operator 1 pg_catalog.=(bigint, smallint),
    operator 1 pg_catalog.=(bigint, integer);

alter operator class pg_catalog.int4_ops using hash owner to postgres;

create operator class pg_catalog.int8_ops default for type bigint using hash family pg_catalog.integer_ops as
    operator 1 pg_catalog.=(smallint, smallint),
    operator 1 pg_catalog.=(integer, integer),
    operator 1 pg_catalog.=(bigint, bigint),
    operator 1 pg_catalog.=(smallint, integer),
    operator 1 pg_catalog.=(smallint, bigint),
    operator 1 pg_catalog.=(integer, smallint),
    operator 1 pg_catalog.=(integer, bigint),
    operator 1 pg_catalog.=(bigint, smallint),
    operator 1 pg_catalog.=(bigint, integer);

alter operator class pg_catalog.int8_ops using hash owner to postgres;

create operator family pg_catalog.interval_ops using btree;

alter operator family pg_catalog.interval_ops using btree add
    function 1(interval, interval) pg_catalog.interval_cmp(),
    function 3(interval, interval) pg_catalog.in_range(interval, interval);

alter operator family pg_catalog.interval_ops using btree owner to postgres;

create operator class pg_catalog.interval_ops default for type interval using btree as
    operator 1 pg_catalog.<(interval, interval),
    operator 2 pg_catalog.<=(interval, interval),
    operator 3 pg_catalog.=(interval, interval),
    operator 4 pg_catalog.>=(interval, interval),
    operator 5 pg_catalog.>(interval, interval);

alter operator class pg_catalog.interval_ops using btree owner to postgres;

create operator family pg_catalog.interval_ops using hash;

alter operator family pg_catalog.interval_ops using hash add
    function 1(interval, interval) pg_catalog.interval_hash(),
    function 2(interval, interval) pg_catalog.interval_hash_extended();

alter operator family pg_catalog.interval_ops using hash owner to postgres;

create operator class pg_catalog.interval_ops default for type interval using hash as
    operator 1 pg_catalog.=(interval, interval);

alter operator class pg_catalog.interval_ops using hash owner to postgres;

create operator family pg_catalog.macaddr_ops using btree;

alter operator family pg_catalog.macaddr_ops using btree add
    function 1(macaddr, macaddr) pg_catalog.macaddr_cmp(),
    function 2(macaddr, macaddr) pg_catalog.macaddr_sortsupport();

alter operator family pg_catalog.macaddr_ops using btree owner to postgres;

create operator class pg_catalog.macaddr_ops default for type macaddr using btree as
    operator 1 pg_catalog.<(macaddr, macaddr),
    operator 2 pg_catalog.<=(macaddr, macaddr),
    operator 3 pg_catalog.=(macaddr, macaddr),
    operator 4 pg_catalog.>=(macaddr, macaddr),
    operator 5 pg_catalog.>(macaddr, macaddr);

alter operator class pg_catalog.macaddr_ops using btree owner to postgres;

create operator family pg_catalog.macaddr_ops using hash;

alter operator family pg_catalog.macaddr_ops using hash add
    function 1(macaddr, macaddr) pg_catalog.hashmacaddr(),
    function 2(macaddr, macaddr) pg_catalog.hashmacaddrextended();

alter operator family pg_catalog.macaddr_ops using hash owner to postgres;

create operator class pg_catalog.macaddr_ops default for type macaddr using hash as
    operator 1 pg_catalog.=(macaddr, macaddr);

alter operator class pg_catalog.macaddr_ops using hash owner to postgres;

create operator family pg_catalog.numeric_ops using btree;

alter operator family pg_catalog.numeric_ops using btree add
    function 1(numeric, numeric) pg_catalog.numeric_cmp(),
    function 2(numeric, numeric) pg_catalog.numeric_sortsupport(),
    function 3(numeric, numeric) pg_catalog.in_range(numeric, numeric, numeric);

alter operator family pg_catalog.numeric_ops using btree owner to postgres;

create operator class pg_catalog.numeric_ops default for type numeric using btree as
    operator 1 pg_catalog.<(numeric, numeric),
    operator 2 pg_catalog.<=(numeric, numeric),
    operator 3 pg_catalog.=(numeric, numeric),
    operator 4 pg_catalog.>=(numeric, numeric),
    operator 5 pg_catalog.>(numeric, numeric);

alter operator class pg_catalog.numeric_ops using btree owner to postgres;

create operator family pg_catalog.oid_ops using btree;

alter operator family pg_catalog.oid_ops using btree add
    function 1(oid, oid) pg_catalog.btoidcmp(),
    function 2(oid, oid) pg_catalog.btoidsortsupport();

alter operator family pg_catalog.oid_ops using btree owner to postgres;

create operator class pg_catalog.oid_ops default for type oid using btree as
    operator 1 pg_catalog.<(oid, oid),
    operator 2 pg_catalog.<=(oid, oid),
    operator 3 pg_catalog.=(oid, oid),
    operator 4 pg_catalog.>=(oid, oid),
    operator 5 pg_catalog.>(oid, oid);

alter operator class pg_catalog.oid_ops using btree owner to postgres;

create operator family pg_catalog.oid_ops using hash;

alter operator family pg_catalog.oid_ops using hash add
    function 1(oid, oid) pg_catalog.hashoid(),
    function 2(oid, oid) pg_catalog.hashoidextended();

alter operator family pg_catalog.oid_ops using hash owner to postgres;

create operator class pg_catalog.oid_ops default for type oid using hash as
    operator 1 pg_catalog.=(oid, oid);

alter operator class pg_catalog.oid_ops using hash owner to postgres;

create operator family pg_catalog.oidvector_ops using btree;

alter operator family pg_catalog.oidvector_ops using btree add
    function 1(oidvector, oidvector) pg_catalog.btoidvectorcmp();

alter operator family pg_catalog.oidvector_ops using btree owner to postgres;

create operator class pg_catalog.oidvector_ops default for type oidvector using btree as
    operator 1 pg_catalog.<(oidvector, oidvector),
    operator 2 pg_catalog.<=(oidvector, oidvector),
    operator 3 pg_catalog.=(oidvector, oidvector),
    operator 4 pg_catalog.>=(oidvector, oidvector),
    operator 5 pg_catalog.>(oidvector, oidvector);

alter operator class pg_catalog.oidvector_ops using btree owner to postgres;

create operator family pg_catalog.oidvector_ops using hash;

alter operator family pg_catalog.oidvector_ops using hash add
    function 1(oidvector, oidvector) pg_catalog.hashoidvector(),
    function 2(oidvector, oidvector) pg_catalog.hashoidvectorextended();

alter operator family pg_catalog.oidvector_ops using hash owner to postgres;

create operator class pg_catalog.oidvector_ops default for type oidvector using hash as
    operator 1 pg_catalog.=(oidvector, oidvector);

alter operator class pg_catalog.oidvector_ops using hash owner to postgres;

create operator family pg_catalog.text_ops using btree;

alter operator family pg_catalog.text_ops using btree add
    function 1(text, text) pg_catalog.bttextcmp(),
    function 2(text, text) pg_catalog.bttextsortsupport(),
    function 1(name, name) pg_catalog.btnamecmp(),
    function 2(name, name) pg_catalog.btnamesortsupport(),
    function 1(name, text) pg_catalog.btnametextcmp(),
    function 1(text, name) pg_catalog.bttextnamecmp();

alter operator family pg_catalog.text_ops using btree owner to postgres;

create operator class pg_catalog.text_ops default for type text using btree as
    operator 1 pg_catalog.<(text, text),
    operator 2 pg_catalog.<=(text, text),
    operator 3 pg_catalog.=(text, text),
    operator 4 pg_catalog.>=(text, text),
    operator 5 pg_catalog.>(text, text),
    operator 1 pg_catalog.<(name, name),
    operator 2 pg_catalog.<=(name, name),
    operator 3 pg_catalog.=(name, name),
    operator 4 pg_catalog.>=(name, name),
    operator 5 pg_catalog.>(name, name),
    operator 1 pg_catalog.<(name, text),
    operator 2 pg_catalog.<=(name, text),
    operator 3 pg_catalog.=(name, text),
    operator 4 pg_catalog.>=(name, text),
    operator 5 pg_catalog.>(name, text),
    operator 1 pg_catalog.<(text, name),
    operator 2 pg_catalog.<=(text, name),
    operator 3 pg_catalog.=(text, name),
    operator 4 pg_catalog.>=(text, name),
    operator 5 pg_catalog.>(text, name);

alter operator class pg_catalog.text_ops using btree owner to postgres;

create operator class pg_catalog.name_ops default for type name using btree family pg_catalog.text_ops as storage cstring operator 1 pg_catalog.<(text, text),
	operator 2 pg_catalog.<=(text, text),
	operator 3 pg_catalog.=(text, text),
	operator 4 pg_catalog.>=(text, text),
	operator 5 pg_catalog.>(text, text),
	operator 1 pg_catalog.<(name, name),
	operator 2 pg_catalog.<=(name, name),
	operator 3 pg_catalog.=(name, name),
	operator 4 pg_catalog.>=(name, name),
	operator 5 pg_catalog.>(name, name),
	operator 1 pg_catalog.<(name, text),
	operator 2 pg_catalog.<=(name, text),
	operator 3 pg_catalog.=(name, text),
	operator 4 pg_catalog.>=(name, text),
	operator 5 pg_catalog.>(name, text),
	operator 1 pg_catalog.<(text, name),
	operator 2 pg_catalog.<=(text, name),
	operator 3 pg_catalog.=(text, name),
	operator 4 pg_catalog.>=(text, name),
	operator 5 pg_catalog.>(text, name);

alter operator class pg_catalog.name_ops using btree owner to postgres;

create operator class pg_catalog.varchar_ops for type text using btree family pg_catalog.text_ops as
    operator 1 pg_catalog.<(text, text),
    operator 2 pg_catalog.<=(text, text),
    operator 3 pg_catalog.=(text, text),
    operator 4 pg_catalog.>=(text, text),
    operator 5 pg_catalog.>(text, text),
    operator 1 pg_catalog.<(name, name),
    operator 2 pg_catalog.<=(name, name),
    operator 3 pg_catalog.=(name, name),
    operator 4 pg_catalog.>=(name, name),
    operator 5 pg_catalog.>(name, name),
    operator 1 pg_catalog.<(name, text),
    operator 2 pg_catalog.<=(name, text),
    operator 3 pg_catalog.=(name, text),
    operator 4 pg_catalog.>=(name, text),
    operator 5 pg_catalog.>(name, text),
    operator 1 pg_catalog.<(text, name),
    operator 2 pg_catalog.<=(text, name),
    operator 3 pg_catalog.=(text, name),
    operator 4 pg_catalog.>=(text, name),
    operator 5 pg_catalog.>(text, name);

alter operator class pg_catalog.varchar_ops using btree owner to postgres;

create operator family pg_catalog.text_ops using hash;

alter operator family pg_catalog.text_ops using hash add
    function 1(text, text) pg_catalog.hashtext(),
    function 2(text, text) pg_catalog.hashtextextended(),
    function 1(name, name) pg_catalog.hashname(),
    function 2(name, name) pg_catalog.hashnameextended();

alter operator family pg_catalog.text_ops using hash owner to postgres;

create operator class pg_catalog.name_ops default for type name using hash family pg_catalog.text_ops as
    operator 1 pg_catalog.=(text, text),
    operator 1 pg_catalog.=(name, name),
    operator 1 pg_catalog.=(name, text),
    operator 1 pg_catalog.=(text, name);

alter operator class pg_catalog.name_ops using hash owner to postgres;

create operator class pg_catalog.text_ops default for type text using hash as
    operator 1 pg_catalog.=(text, text),
    operator 1 pg_catalog.=(name, name),
    operator 1 pg_catalog.=(name, text),
    operator 1 pg_catalog.=(text, name);

alter operator class pg_catalog.text_ops using hash owner to postgres;

create operator class pg_catalog.varchar_ops for type text using hash family pg_catalog.text_ops as
    operator 1 pg_catalog.=(text, text),
    operator 1 pg_catalog.=(name, name),
    operator 1 pg_catalog.=(name, text),
    operator 1 pg_catalog.=(text, name);

alter operator class pg_catalog.varchar_ops using hash owner to postgres;

create operator family pg_catalog.time_ops using btree;

alter operator family pg_catalog.time_ops using btree add
    function 1(time without time zone, time without time zone) pg_catalog.time_cmp(),
    function 3(time without time zone, interval) pg_catalog.in_range(time, time);

alter operator family pg_catalog.time_ops using btree owner to postgres;

create operator class pg_catalog.time_ops default for type time without time zone using btree as
    operator 1 pg_catalog.<(time, time),
    operator 2 pg_catalog.<=(time, time),
    operator 3 pg_catalog.=(time, time),
    operator 4 pg_catalog.>=(time, time),
    operator 5 pg_catalog.>(time, time);

alter operator class pg_catalog.time_ops using btree owner to postgres;

create operator family pg_catalog.time_ops using hash;

alter operator family pg_catalog.time_ops using hash add
    function 1(time without time zone, time without time zone) pg_catalog.time_hash(),
    function 2(time without time zone, time without time zone) pg_catalog.time_hash_extended();

alter operator family pg_catalog.time_ops using hash owner to postgres;

create operator class pg_catalog.time_ops default for type time without time zone using hash as
    operator 1 pg_catalog.=(time, time);

alter operator class pg_catalog.time_ops using hash owner to postgres;

create operator family pg_catalog.numeric_ops using hash;

alter operator family pg_catalog.numeric_ops using hash add
    function 1(numeric, numeric) pg_catalog.hash_numeric(),
    function 2(numeric, numeric) pg_catalog.hash_numeric_extended();

alter operator family pg_catalog.numeric_ops using hash owner to postgres;

create operator class pg_catalog.numeric_ops default for type numeric using hash as
    operator 1 pg_catalog.=(numeric, numeric);

alter operator class pg_catalog.numeric_ops using hash owner to postgres;

create operator family pg_catalog.timestamptz_ops using hash;

alter operator family pg_catalog.timestamptz_ops using hash add
    function 1(timestamp with time zone, timestamp with time zone) pg_catalog.timestamp_hash(),
    function 2(timestamp with time zone, timestamp with time zone) pg_catalog.timestamp_hash_extended();

alter operator family pg_catalog.timestamptz_ops using hash owner to postgres;

create operator class pg_catalog.timestamptz_ops default for type timestamp with time zone using hash as
    operator 1 pg_catalog.=(timestamp with time zone, timestamp with time zone);

alter operator class pg_catalog.timestamptz_ops using hash owner to postgres;

create operator family pg_catalog.timetz_ops using btree;

alter operator family pg_catalog.timetz_ops using btree add
    function 1(time with time zone, time with time zone) pg_catalog.timetz_cmp(),
    function 3(time with time zone, interval) pg_catalog.in_range(time with time zone, time with time zone);

alter operator family pg_catalog.timetz_ops using btree owner to postgres;

create operator class pg_catalog.timetz_ops default for type time with time zone using btree as
    operator 1 pg_catalog.<(time with time zone, time with time zone),
    operator 2 pg_catalog.<=(time with time zone, time with time zone),
    operator 3 pg_catalog.=(time with time zone, time with time zone),
    operator 4 pg_catalog.>=(time with time zone, time with time zone),
    operator 5 pg_catalog.>(time with time zone, time with time zone);

alter operator class pg_catalog.timetz_ops using btree owner to postgres;

create operator family pg_catalog.timetz_ops using hash;

alter operator family pg_catalog.timetz_ops using hash add
    function 1(time with time zone, time with time zone) pg_catalog.timetz_hash(),
    function 2(time with time zone, time with time zone) pg_catalog.timetz_hash_extended();

alter operator family pg_catalog.timetz_ops using hash owner to postgres;

create operator class pg_catalog.timetz_ops default for type time with time zone using hash as
    operator 1 pg_catalog.=(time with time zone, time with time zone);

alter operator class pg_catalog.timetz_ops using hash owner to postgres;

create operator family pg_catalog.varbit_ops using btree;

alter operator family pg_catalog.varbit_ops using btree add
    function 1(bit varying, bit varying) pg_catalog.varbitcmp();

alter operator family pg_catalog.varbit_ops using btree owner to postgres;

create operator class pg_catalog.varbit_ops default for type bit varying using btree as
    operator 1 pg_catalog.<(bit varying, bit varying),
    operator 2 pg_catalog.<=(bit varying, bit varying),
    operator 3 pg_catalog.=(bit varying, bit varying),
    operator 4 pg_catalog.>=(bit varying, bit varying),
    operator 5 pg_catalog.>(bit varying, bit varying);

alter operator class pg_catalog.varbit_ops using btree owner to postgres;

create operator family pg_catalog.timestamp_ops using hash;

alter operator family pg_catalog.timestamp_ops using hash add
    function 1(timestamp without time zone, timestamp without time zone) pg_catalog.timestamp_hash(),
    function 2(timestamp without time zone, timestamp without time zone) pg_catalog.timestamp_hash_extended();

alter operator family pg_catalog.timestamp_ops using hash owner to postgres;

create operator class pg_catalog.timestamp_ops default for type timestamp without time zone using hash as
    operator 1 pg_catalog.=(timestamp, timestamp);

alter operator class pg_catalog.timestamp_ops using hash owner to postgres;

create operator family pg_catalog.text_pattern_ops using btree;

alter operator family pg_catalog.text_pattern_ops using btree add
    function 1(text, text) pg_catalog.bttext_pattern_cmp(),
    function 2(text, text) pg_catalog.bttext_pattern_sortsupport();

alter operator family pg_catalog.text_pattern_ops using btree owner to postgres;

create operator class pg_catalog.text_pattern_ops for type text using btree as
    operator 1 pg_catalog.~<~(text, text),
    operator 2 pg_catalog.~<=~(text, text),
    operator 3 pg_catalog.=(text, text),
    operator 4 pg_catalog.~>=~(text, text),
    operator 5 pg_catalog.~>~(text, text);

alter operator class pg_catalog.text_pattern_ops using btree owner to postgres;

create operator class pg_catalog.varchar_pattern_ops for type text using btree family pg_catalog.text_pattern_ops as
    operator 1 pg_catalog.~<~(text, text),
    operator 2 pg_catalog.~<=~(text, text),
    operator 3 pg_catalog.=(text, text),
    operator 4 pg_catalog.~>=~(text, text),
    operator 5 pg_catalog.~>~(text, text);

alter operator class pg_catalog.varchar_pattern_ops using btree owner to postgres;

create operator family pg_catalog.bpchar_pattern_ops using btree;

alter operator family pg_catalog.bpchar_pattern_ops using btree add
    function 1(character, character) pg_catalog.btbpchar_pattern_cmp(),
    function 2(character, character) pg_catalog.btbpchar_pattern_sortsupport();

alter operator family pg_catalog.bpchar_pattern_ops using btree owner to postgres;

create operator class pg_catalog.bpchar_pattern_ops for type character using btree as
    operator 1 pg_catalog.~<~(char, char),
    operator 2 pg_catalog.~<=~(char, char),
    operator 3 pg_catalog.=(char, char),
    operator 4 pg_catalog.~>=~(char, char),
    operator 5 pg_catalog.~>~(char, char);

alter operator class pg_catalog.bpchar_pattern_ops using btree owner to postgres;

create operator family pg_catalog.money_ops using btree;

alter operator family pg_catalog.money_ops using btree add
    function 1(money, money) pg_catalog.cash_cmp();

alter operator family pg_catalog.money_ops using btree owner to postgres;

create operator class pg_catalog.money_ops default for type money using btree as
    operator 1 pg_catalog.<(money, money),
    operator 2 pg_catalog.<=(money, money),
    operator 3 pg_catalog.=(money, money),
    operator 4 pg_catalog.>=(money, money),
    operator 5 pg_catalog.>(money, money);

alter operator class pg_catalog.money_ops using btree owner to postgres;

create operator family pg_catalog.bool_ops using hash;

alter operator family pg_catalog.bool_ops using hash add
    function 1(boolean, boolean) pg_catalog.hashchar(),
    function 2(boolean, boolean) pg_catalog.hashcharextended();

alter operator family pg_catalog.bool_ops using hash owner to postgres;

create operator class pg_catalog.bool_ops default for type boolean using hash as
    operator 1 pg_catalog.=(boolean, boolean);

alter operator class pg_catalog.bool_ops using hash owner to postgres;

create operator family pg_catalog.bytea_ops using hash;

alter operator family pg_catalog.bytea_ops using hash add
    function 1(bytea, bytea) pg_catalog.hashvarlena(),
    function 2(bytea, bytea) pg_catalog.hashvarlenaextended();

alter operator family pg_catalog.bytea_ops using hash owner to postgres;

create operator class pg_catalog.bytea_ops default for type bytea using hash as
    operator 1 pg_catalog.=(bytea, bytea);

alter operator class pg_catalog.bytea_ops using hash owner to postgres;

create operator family pg_catalog.xid_ops using hash;

alter operator family pg_catalog.xid_ops using hash add
    function 1(xid, xid) pg_catalog.hashint4(),
    function 2(xid, xid) pg_catalog.hashint4extended();

alter operator family pg_catalog.xid_ops using hash owner to postgres;

create operator class pg_catalog.xid_ops default for type xid using hash as
    operator 1 pg_catalog.=(xid, xid);

alter operator class pg_catalog.xid_ops using hash owner to postgres;

create operator family pg_catalog.cid_ops using hash;

alter operator family pg_catalog.cid_ops using hash add
    function 1(cid, cid) pg_catalog.hashint4(),
    function 2(cid, cid) pg_catalog.hashint4extended();

alter operator family pg_catalog.cid_ops using hash owner to postgres;

create operator class pg_catalog.cid_ops default for type cid using hash as
    operator 1 pg_catalog.=(cid, cid);

alter operator class pg_catalog.cid_ops using hash owner to postgres;

create operator family pg_catalog.tid_ops using hash;

alter operator family pg_catalog.tid_ops using hash add
    function 1(tid, tid) pg_catalog.hashtid(),
    function 2(tid, tid) pg_catalog.hashtidextended();

alter operator family pg_catalog.tid_ops using hash owner to postgres;

create operator class pg_catalog.tid_ops default for type tid using hash as
    operator 1 pg_catalog.=(tid, tid);

alter operator class pg_catalog.tid_ops using hash owner to postgres;

create operator family pg_catalog.text_pattern_ops using hash;

alter operator family pg_catalog.text_pattern_ops using hash add
    function 1(text, text) pg_catalog.hashtext(),
    function 2(text, text) pg_catalog.hashtextextended();

alter operator family pg_catalog.text_pattern_ops using hash owner to postgres;

create operator class pg_catalog.text_pattern_ops for type text using hash as
    operator 1 pg_catalog.=(text, text);

alter operator class pg_catalog.text_pattern_ops using hash owner to postgres;

create operator class pg_catalog.varchar_pattern_ops for type text using hash family pg_catalog.text_pattern_ops as
    operator 1 pg_catalog.=(text, text);

alter operator class pg_catalog.varchar_pattern_ops using hash owner to postgres;

create operator family pg_catalog.bpchar_pattern_ops using hash;

alter operator family pg_catalog.bpchar_pattern_ops using hash add
    function 1(character, character) pg_catalog.hashbpchar(),
    function 2(character, character) pg_catalog.hashbpcharextended();

alter operator family pg_catalog.bpchar_pattern_ops using hash owner to postgres;

create operator class pg_catalog.bpchar_pattern_ops for type character using hash as
    operator 1 pg_catalog.=(char, char);

alter operator class pg_catalog.bpchar_pattern_ops using hash owner to postgres;

create operator family pg_catalog.aclitem_ops using hash;

alter operator family pg_catalog.aclitem_ops using hash add
    function 1(aclitem, aclitem) pg_catalog.hash_aclitem(),
    function 2(aclitem, aclitem) pg_catalog.hash_aclitem_extended();

alter operator family pg_catalog.aclitem_ops using hash owner to postgres;

create operator class pg_catalog.aclitem_ops default for type aclitem using hash as
    operator 1 pg_catalog.=(aclitem, aclitem);

alter operator class pg_catalog.aclitem_ops using hash owner to postgres;

create operator family pg_catalog.box_ops using gist;

alter operator family pg_catalog.box_ops using gist add
    function 1(box, box) pg_catalog.gist_box_consistent(),
    function 2(box, box) pg_catalog.gist_box_union(),
    function 5(box, box) pg_catalog.gist_box_penalty(),
    function 6(box, box) pg_catalog.gist_box_picksplit(),
    function 7(box, box) pg_catalog.gist_box_same();

alter operator family pg_catalog.box_ops using gist owner to postgres;

create operator class pg_catalog.box_ops default for type box using gist as
    operator 1 pg_catalog.<<(box, box),
    operator 2 pg_catalog.&<(box, box),
    operator 3 pg_catalog.&&(box, box),
    operator 4 pg_catalog.&>(box, box),
    operator 5 pg_catalog.>>(box, box),
    operator 6 pg_catalog.~=(box, box),
    operator 7 pg_catalog.@>(box, box),
    operator 8 pg_catalog.<@(box, box),
    operator 9 pg_catalog.&<|(box, box),
    operator 10 pg_catalog.<<|(box, box),
    operator 11 pg_catalog.|>>(box, box),
    operator 12 pg_catalog.|&>(box, box),
    operator 13 pg_catalog.~(box, box),
    operator 14 pg_catalog.@(box, box);

alter operator class pg_catalog.box_ops using gist owner to postgres;

create operator family pg_catalog.poly_ops using gist;

alter operator family pg_catalog.poly_ops using gist add
    function 1(polygon, polygon) pg_catalog.gist_poly_consistent(),
    function 2(polygon, polygon) pg_catalog.gist_box_union(),
    function 3(polygon, polygon) pg_catalog.gist_poly_compress(),
    function 5(polygon, polygon) pg_catalog.gist_box_penalty(),
    function 6(polygon, polygon) pg_catalog.gist_box_picksplit(),
    function 7(polygon, polygon) pg_catalog.gist_box_same(),
    function 8(polygon, polygon) pg_catalog.gist_poly_distance();

alter operator family pg_catalog.poly_ops using gist owner to postgres;

create operator class pg_catalog.poly_ops default for type polygon using gist as storage box operator 1 pg_catalog.<<(polygon, polygon),
	operator 2 pg_catalog.&<(polygon, polygon),
	operator 3 pg_catalog.&&(polygon, polygon),
	operator 4 pg_catalog.&>(polygon, polygon),
	operator 5 pg_catalog.>>(polygon, polygon),
	operator 6 pg_catalog.~=(polygon, polygon),
	operator 7 pg_catalog.@>(polygon, polygon),
	operator 8 pg_catalog.<@(polygon, polygon),
	operator 9 pg_catalog.&<|(polygon, polygon),
	operator 10 pg_catalog.<<|(polygon, polygon),
	operator 11 pg_catalog.|>>(polygon, polygon),
	operator 12 pg_catalog.|&>(polygon, polygon),
	operator 13 pg_catalog.~(polygon, polygon),
	operator 14 pg_catalog.@(polygon, polygon),
	operator 15 pg_catalog.<->(polygon, point) for order by float_ops;

alter operator class pg_catalog.poly_ops using gist owner to postgres;

create operator family pg_catalog.circle_ops using gist;

alter operator family pg_catalog.circle_ops using gist add
    function 1(circle, circle) pg_catalog.gist_circle_consistent(),
    function 2(circle, circle) pg_catalog.gist_box_union(),
    function 3(circle, circle) pg_catalog.gist_circle_compress(),
    function 5(circle, circle) pg_catalog.gist_box_penalty(),
    function 6(circle, circle) pg_catalog.gist_box_picksplit(),
    function 7(circle, circle) pg_catalog.gist_box_same(),
    function 8(circle, circle) pg_catalog.gist_circle_distance();

alter operator family pg_catalog.circle_ops using gist owner to postgres;

create operator class pg_catalog.circle_ops default for type circle using gist as storage box operator 1 pg_catalog.<<(circle, circle),
	operator 2 pg_catalog.&<(circle, circle),
	operator 3 pg_catalog.&&(circle, circle),
	operator 4 pg_catalog.&>(circle, circle),
	operator 5 pg_catalog.>>(circle, circle),
	operator 6 pg_catalog.~=(circle, circle),
	operator 7 pg_catalog.@>(circle, circle),
	operator 8 pg_catalog.<@(circle, circle),
	operator 9 pg_catalog.&<|(circle, circle),
	operator 10 pg_catalog.<<|(circle, circle),
	operator 11 pg_catalog.|>>(circle, circle),
	operator 12 pg_catalog.|&>(circle, circle),
	operator 13 pg_catalog.~(circle, circle),
	operator 14 pg_catalog.@(circle, circle),
	operator 15 pg_catalog.<->(circle, point) for order by float_ops;

alter operator class pg_catalog.circle_ops using gist owner to postgres;

create operator family pg_catalog.array_ops using gin;

alter operator family pg_catalog.array_ops using gin add
    function 2(anyarray, anyarray) pg_catalog.ginarrayextract(),
    function 3(anyarray, anyarray) pg_catalog.ginqueryarrayextract(),
    function 4(anyarray, anyarray) pg_catalog.ginarrayconsistent(),
    function 6(anyarray, anyarray) pg_catalog.ginarraytriconsistent();

alter operator family pg_catalog.array_ops using gin owner to postgres;

create operator class pg_catalog.array_ops default for type anyarray using gin as storage anyelement operator 1 pg_catalog.&&(anyarray, anyarray),
	operator 2 pg_catalog.@>(anyarray, anyarray),
	operator 3 pg_catalog.<@(anyarray, anyarray),
	operator 4 pg_catalog.=(anyarray, anyarray);

alter operator class pg_catalog.array_ops using gin owner to postgres;

create operator family pg_catalog.tid_ops using btree;

alter operator family pg_catalog.tid_ops using btree add
    function 1(tid, tid) pg_catalog.bttidcmp();

alter operator family pg_catalog.tid_ops using btree owner to postgres;

create operator class pg_catalog.tid_ops default for type tid using btree as
    operator 1 pg_catalog.<(tid, tid),
    operator 2 pg_catalog.<=(tid, tid),
    operator 3 pg_catalog.=(tid, tid),
    operator 4 pg_catalog.>=(tid, tid),
    operator 5 pg_catalog.>(tid, tid);

alter operator class pg_catalog.tid_ops using btree owner to postgres;

create operator family pg_catalog.uuid_ops using btree;

alter operator family pg_catalog.uuid_ops using btree add
    function 1(uuid, uuid) pg_catalog.uuid_cmp(),
    function 2(uuid, uuid) pg_catalog.uuid_sortsupport();

alter operator family pg_catalog.uuid_ops using btree owner to postgres;

create operator class pg_catalog.uuid_ops default for type uuid using btree as
    operator 1 pg_catalog.<(uuid, uuid),
    operator 2 pg_catalog.<=(uuid, uuid),
    operator 3 pg_catalog.=(uuid, uuid),
    operator 4 pg_catalog.>=(uuid, uuid),
    operator 5 pg_catalog.>(uuid, uuid);

alter operator class pg_catalog.uuid_ops using btree owner to postgres;

create operator family pg_catalog.uuid_ops using hash;

alter operator family pg_catalog.uuid_ops using hash add
    function 1(uuid, uuid) pg_catalog.uuid_hash(),
    function 2(uuid, uuid) pg_catalog.uuid_hash_extended();

alter operator family pg_catalog.uuid_ops using hash owner to postgres;

create operator class pg_catalog.uuid_ops default for type uuid using hash as
    operator 1 pg_catalog.=(uuid, uuid);

alter operator class pg_catalog.uuid_ops using hash owner to postgres;

create operator family pg_catalog.record_ops using btree;

alter operator family pg_catalog.record_ops using btree add
    function 1(record, record) pg_catalog.btrecordcmp();

alter operator family pg_catalog.record_ops using btree owner to postgres;

create operator class pg_catalog.record_ops default for type record using btree as
    operator 1 pg_catalog.<(record, record),
    operator 2 pg_catalog.<=(record, record),
    operator 3 pg_catalog.=(record, record),
    operator 4 pg_catalog.>=(record, record),
    operator 5 pg_catalog.>(record, record);

alter operator class pg_catalog.record_ops using btree owner to postgres;

create operator family pg_catalog.record_image_ops using btree;

alter operator family pg_catalog.record_image_ops using btree add
    function 1(record, record) pg_catalog.btrecordimagecmp();

alter operator family pg_catalog.record_image_ops using btree owner to postgres;

create operator class pg_catalog.record_image_ops for type record using btree as
    operator 1 pg_catalog.*<(record, record),
    operator 2 pg_catalog.*<=(record, record),
    operator 3 pg_catalog.*=(record, record),
    operator 4 pg_catalog.*>=(record, record),
    operator 5 pg_catalog.*>(record, record);

alter operator class pg_catalog.record_image_ops using btree owner to postgres;

create operator family pg_catalog.pg_lsn_ops using btree;

alter operator family pg_catalog.pg_lsn_ops using btree add
    function 1(pg_lsn, pg_lsn) pg_catalog.pg_lsn_cmp();

alter operator family pg_catalog.pg_lsn_ops using btree owner to postgres;

create operator class pg_catalog.pg_lsn_ops default for type pg_lsn using btree as
    operator 1 pg_catalog.<(pg_lsn, pg_lsn),
    operator 2 pg_catalog.<=(pg_lsn, pg_lsn),
    operator 3 pg_catalog.=(pg_lsn, pg_lsn),
    operator 4 pg_catalog.>=(pg_lsn, pg_lsn),
    operator 5 pg_catalog.>(pg_lsn, pg_lsn);

alter operator class pg_catalog.pg_lsn_ops using btree owner to postgres;

create operator family pg_catalog.pg_lsn_ops using hash;

alter operator family pg_catalog.pg_lsn_ops using hash add
    function 1(pg_lsn, pg_lsn) pg_catalog.pg_lsn_hash(),
    function 2(pg_lsn, pg_lsn) pg_catalog.pg_lsn_hash_extended();

alter operator family pg_catalog.pg_lsn_ops using hash owner to postgres;

create operator class pg_catalog.pg_lsn_ops default for type pg_lsn using hash as
    operator 1 pg_catalog.=(pg_lsn, pg_lsn);

alter operator class pg_catalog.pg_lsn_ops using hash owner to postgres;

create operator family pg_catalog.macaddr8_ops using btree;

alter operator family pg_catalog.macaddr8_ops using btree add
    function 1(macaddr8, macaddr8) pg_catalog.macaddr8_cmp();

alter operator family pg_catalog.macaddr8_ops using btree owner to postgres;

create operator class pg_catalog.macaddr8_ops default for type macaddr8 using btree as
    operator 1 pg_catalog.<(macaddr8, macaddr8),
    operator 2 pg_catalog.<=(macaddr8, macaddr8),
    operator 3 pg_catalog.=(macaddr8, macaddr8),
    operator 4 pg_catalog.>=(macaddr8, macaddr8),
    operator 5 pg_catalog.>(macaddr8, macaddr8);

alter operator class pg_catalog.macaddr8_ops using btree owner to postgres;

create operator family pg_catalog.macaddr8_ops using hash;

alter operator family pg_catalog.macaddr8_ops using hash add
    function 1(macaddr8, macaddr8) pg_catalog.hashmacaddr8(),
    function 2(macaddr8, macaddr8) pg_catalog.hashmacaddr8extended();

alter operator family pg_catalog.macaddr8_ops using hash owner to postgres;

create operator class pg_catalog.macaddr8_ops default for type macaddr8 using hash as
    operator 1 pg_catalog.=(macaddr8, macaddr8);

alter operator class pg_catalog.macaddr8_ops using hash owner to postgres;

create operator family pg_catalog.range_ops using spgist;

alter operator family pg_catalog.range_ops using spgist add
    function 1(anyrange, anyrange) pg_catalog.spg_range_quad_config(),
    function 2(anyrange, anyrange) pg_catalog.spg_range_quad_choose(),
    function 3(anyrange, anyrange) pg_catalog.spg_range_quad_picksplit(),
    function 4(anyrange, anyrange) pg_catalog.spg_range_quad_inner_consistent(),
    function 5(anyrange, anyrange) pg_catalog.spg_range_quad_leaf_consistent();

alter operator family pg_catalog.range_ops using spgist owner to postgres;

create operator class pg_catalog.range_ops default for type anyrange using spgist as
    operator 1 pg_catalog.<<(anyrange, anyrange),
    operator 2 pg_catalog.&<(anyrange, anyrange),
    operator 3 pg_catalog.&&(anyrange, anyrange),
    operator 4 pg_catalog.&>(anyrange, anyrange),
    operator 5 pg_catalog.>>(anyrange, anyrange),
    operator 6 pg_catalog.-|-(anyrange, anyrange),
    operator 7 pg_catalog.@>(anyrange, anyrange),
    operator 8 pg_catalog.<@(anyrange, anyrange),
    operator 16 pg_catalog.@>(anyrange, anyelement),
    operator 18 pg_catalog.=(anyrange, anyrange);

alter operator class pg_catalog.range_ops using spgist owner to postgres;

create operator family pg_catalog.enum_ops using btree;

alter operator family pg_catalog.enum_ops using btree add
    function 1(anyenum, anyenum) pg_catalog.enum_cmp();

alter operator family pg_catalog.enum_ops using btree owner to postgres;

create operator class pg_catalog.enum_ops default for type anyenum using btree as
    operator 1 pg_catalog.<(anyenum, anyenum),
    operator 2 pg_catalog.<=(anyenum, anyenum),
    operator 3 pg_catalog.=(anyenum, anyenum),
    operator 4 pg_catalog.>=(anyenum, anyenum),
    operator 5 pg_catalog.>(anyenum, anyenum);

alter operator class pg_catalog.enum_ops using btree owner to postgres;

create operator family pg_catalog.enum_ops using hash;

alter operator family pg_catalog.enum_ops using hash add
    function 1(anyenum, anyenum) pg_catalog.hashenum(),
    function 2(anyenum, anyenum) pg_catalog.hashenumextended();

alter operator family pg_catalog.enum_ops using hash owner to postgres;

create operator class pg_catalog.enum_ops default for type anyenum using hash as
    operator 1 pg_catalog.=(anyenum, anyenum);

alter operator class pg_catalog.enum_ops using hash owner to postgres;

create operator family pg_catalog.network_ops using gist;

alter operator family pg_catalog.network_ops using gist add
    function 1(inet, inet) pg_catalog.inet_gist_consistent(),
    function 2(inet, inet) pg_catalog.inet_gist_union(),
    function 3(inet, inet) pg_catalog.inet_gist_compress(),
    function 5(inet, inet) pg_catalog.inet_gist_penalty(),
    function 6(inet, inet) pg_catalog.inet_gist_picksplit(),
    function 7(inet, inet) pg_catalog.inet_gist_same(),
    function 9(inet, inet) pg_catalog.inet_gist_fetch();

alter operator family pg_catalog.network_ops using gist owner to postgres;

create operator class pg_catalog.inet_ops for type inet using gist family pg_catalog.network_ops as
    operator 3 pg_catalog.&&(inet, inet),
    operator 18 pg_catalog.=(inet, inet),
    operator 19 pg_catalog.<>(inet, inet),
    operator 20 pg_catalog.<(inet, inet),
    operator 21 pg_catalog.<=(inet, inet),
    operator 22 pg_catalog.>(inet, inet),
    operator 23 pg_catalog.>=(inet, inet),
    operator 24 pg_catalog.<<(inet, inet),
    operator 25 pg_catalog.<<=(inet, inet),
    operator 26 pg_catalog.>>(inet, inet),
    operator 27 pg_catalog.>>=(inet, inet);

alter operator class pg_catalog.inet_ops using gist owner to postgres;

create operator family pg_catalog.tsvector_ops using btree;

alter operator family pg_catalog.tsvector_ops using btree add
    function 1(tsvector, tsvector) pg_catalog.tsvector_cmp();

alter operator family pg_catalog.tsvector_ops using btree owner to postgres;

create operator class pg_catalog.tsvector_ops default for type tsvector using btree as
    operator 1 pg_catalog.<(tsvector, tsvector),
    operator 2 pg_catalog.<=(tsvector, tsvector),
    operator 3 pg_catalog.=(tsvector, tsvector),
    operator 4 pg_catalog.>=(tsvector, tsvector),
    operator 5 pg_catalog.>(tsvector, tsvector);

alter operator class pg_catalog.tsvector_ops using btree owner to postgres;

create operator family pg_catalog.tsvector_ops using gist;

alter operator family pg_catalog.tsvector_ops using gist add
    function 1(tsvector, tsvector) pg_catalog.gtsvector_consistent(),
    function 2(tsvector, tsvector) pg_catalog.gtsvector_union(),
    function 3(tsvector, tsvector) pg_catalog.gtsvector_compress(),
    function 4(tsvector, tsvector) pg_catalog.gtsvector_decompress(),
    function 5(tsvector, tsvector) pg_catalog.gtsvector_penalty(),
    function 6(tsvector, tsvector) pg_catalog.gtsvector_picksplit(),
    function 7(tsvector, tsvector) pg_catalog.gtsvector_same();

alter operator family pg_catalog.tsvector_ops using gist owner to postgres;

create operator class pg_catalog.tsvector_ops default for type tsvector using gist as storage gtsvector operator 1 pg_catalog.@@(tsvector, tsquery);

alter operator class pg_catalog.tsvector_ops using gist owner to postgres;

create operator family pg_catalog.tsvector_ops using gin;

alter operator family pg_catalog.tsvector_ops using gin add
    function 1(tsvector, tsvector) pg_catalog.gin_cmp_tslexeme(),
    function 2(tsvector, tsvector) pg_catalog.gin_extract_tsvector(),
    function 3(tsvector, tsvector) pg_catalog.gin_extract_tsquery(tsvector, internal, internal),
    function 4(tsvector, tsvector) pg_catalog.gin_tsquery_consistent(tsvector, internal, internal),
    function 5(tsvector, tsvector) pg_catalog.gin_cmp_prefix(),
    function 6(tsvector, tsvector) pg_catalog.gin_tsquery_triconsistent();

alter operator family pg_catalog.tsvector_ops using gin owner to postgres;

create operator class pg_catalog.tsvector_ops default for type tsvector using gin as storage text operator 1 pg_catalog.@@(tsvector, tsquery),
	operator 2 pg_catalog.@@@(tsvector, tsquery);

alter operator class pg_catalog.tsvector_ops using gin owner to postgres;

create operator family pg_catalog.tsquery_ops using btree;

alter operator family pg_catalog.tsquery_ops using btree add
    function 1(tsquery, tsquery) pg_catalog.tsquery_cmp();

alter operator family pg_catalog.tsquery_ops using btree owner to postgres;

create operator class pg_catalog.tsquery_ops default for type tsquery using btree as
    operator 1 pg_catalog.<(tsquery, tsquery),
    operator 2 pg_catalog.<=(tsquery, tsquery),
    operator 3 pg_catalog.=(tsquery, tsquery),
    operator 4 pg_catalog.>=(tsquery, tsquery),
    operator 5 pg_catalog.>(tsquery, tsquery);

alter operator class pg_catalog.tsquery_ops using btree owner to postgres;

create operator family pg_catalog.tsquery_ops using gist;

alter operator family pg_catalog.tsquery_ops using gist add
    function 1(tsquery, tsquery) pg_catalog.gtsquery_consistent(),
    function 2(tsquery, tsquery) pg_catalog.gtsquery_union(),
    function 3(tsquery, tsquery) pg_catalog.gtsquery_compress(),
    function 5(tsquery, tsquery) pg_catalog.gtsquery_penalty(),
    function 6(tsquery, tsquery) pg_catalog.gtsquery_picksplit(),
    function 7(tsquery, tsquery) pg_catalog.gtsquery_same();

alter operator family pg_catalog.tsquery_ops using gist owner to postgres;

create operator class pg_catalog.tsquery_ops default for type tsquery using gist as storage bigint operator 7 pg_catalog.@>(tsquery, tsquery),
	operator 8 pg_catalog.<@(tsquery, tsquery);

alter operator class pg_catalog.tsquery_ops using gist owner to postgres;

create operator family pg_catalog.network_ops using spgist;

alter operator family pg_catalog.network_ops using spgist add
    function 1(inet, inet) pg_catalog.inet_spg_config(),
    function 2(inet, inet) pg_catalog.inet_spg_choose(),
    function 3(inet, inet) pg_catalog.inet_spg_picksplit(),
    function 4(inet, inet) pg_catalog.inet_spg_inner_consistent(),
    function 5(inet, inet) pg_catalog.inet_spg_leaf_consistent();

alter operator family pg_catalog.network_ops using spgist owner to postgres;

create operator class pg_catalog.inet_ops default for type inet using spgist family pg_catalog.network_ops as
    operator 3 pg_catalog.&&(inet, inet),
    operator 18 pg_catalog.=(inet, inet),
    operator 19 pg_catalog.<>(inet, inet),
    operator 20 pg_catalog.<(inet, inet),
    operator 21 pg_catalog.<=(inet, inet),
    operator 22 pg_catalog.>(inet, inet),
    operator 23 pg_catalog.>=(inet, inet),
    operator 24 pg_catalog.<<(inet, inet),
    operator 25 pg_catalog.<<=(inet, inet),
    operator 26 pg_catalog.>>(inet, inet),
    operator 27 pg_catalog.>>=(inet, inet);

alter operator class pg_catalog.inet_ops using spgist owner to postgres;

create operator family pg_catalog.range_ops using btree;

alter operator family pg_catalog.range_ops using btree add
    function 1(anyrange, anyrange) pg_catalog.range_cmp();

alter operator family pg_catalog.range_ops using btree owner to postgres;

create operator class pg_catalog.range_ops default for type anyrange using btree as
    operator 1 pg_catalog.<(anyrange, anyrange),
    operator 2 pg_catalog.<=(anyrange, anyrange),
    operator 3 pg_catalog.=(anyrange, anyrange),
    operator 4 pg_catalog.>=(anyrange, anyrange),
    operator 5 pg_catalog.>(anyrange, anyrange);

alter operator class pg_catalog.range_ops using btree owner to postgres;

create operator family pg_catalog.range_ops using hash;

alter operator family pg_catalog.range_ops using hash add
    function 1(anyrange, anyrange) pg_catalog.hash_range(),
    function 2(anyrange, anyrange) pg_catalog.hash_range_extended();

alter operator family pg_catalog.range_ops using hash owner to postgres;

create operator class pg_catalog.range_ops default for type anyrange using hash as
    operator 1 pg_catalog.=(anyrange, anyrange);

alter operator class pg_catalog.range_ops using hash owner to postgres;

create operator family pg_catalog.range_ops using gist;

alter operator family pg_catalog.range_ops using gist add
    function 1(anyrange, anyrange) pg_catalog.range_gist_consistent(),
    function 2(anyrange, anyrange) pg_catalog.range_gist_union(),
    function 5(anyrange, anyrange) pg_catalog.range_gist_penalty(),
    function 6(anyrange, anyrange) pg_catalog.range_gist_picksplit(),
    function 7(anyrange, anyrange) pg_catalog.range_gist_same();

alter operator family pg_catalog.range_ops using gist owner to postgres;

create operator class pg_catalog.range_ops default for type anyrange using gist as
    operator 1 pg_catalog.<<(anyrange, anyrange),
    operator 2 pg_catalog.&<(anyrange, anyrange),
    operator 3 pg_catalog.&&(anyrange, anyrange),
    operator 4 pg_catalog.&>(anyrange, anyrange),
    operator 5 pg_catalog.>>(anyrange, anyrange),
    operator 6 pg_catalog.-|-(anyrange, anyrange),
    operator 7 pg_catalog.@>(anyrange, anyrange),
    operator 8 pg_catalog.<@(anyrange, anyrange),
    operator 16 pg_catalog.@>(anyrange, anyelement),
    operator 18 pg_catalog.=(anyrange, anyrange);

alter operator class pg_catalog.range_ops using gist owner to postgres;

create operator family pg_catalog.quad_point_ops using spgist;

alter operator family pg_catalog.quad_point_ops using spgist add
    function 1(point, point) pg_catalog.spg_quad_config(),
    function 2(point, point) pg_catalog.spg_quad_choose(),
    function 3(point, point) pg_catalog.spg_quad_picksplit(),
    function 4(point, point) pg_catalog.spg_quad_inner_consistent(),
    function 5(point, point) pg_catalog.spg_quad_leaf_consistent();

alter operator family pg_catalog.quad_point_ops using spgist owner to postgres;

create operator class pg_catalog.quad_point_ops default for type point using spgist as
    operator 11 pg_catalog.>^(point, point),
    operator 1 pg_catalog.<<(point, point),
    operator 5 pg_catalog.>>(point, point),
    operator 10 pg_catalog.<^(point, point),
    operator 6 pg_catalog.~=(point, point),
    operator 8 pg_catalog.<@(point, box),
    operator 15 pg_catalog.<->(point, point) for order by float_ops;

alter operator class pg_catalog.quad_point_ops using spgist owner to postgres;

create operator family pg_catalog.kd_point_ops using spgist;

alter operator family pg_catalog.kd_point_ops using spgist add
    function 1(point, point) pg_catalog.spg_kd_config(),
    function 2(point, point) pg_catalog.spg_kd_choose(),
    function 3(point, point) pg_catalog.spg_kd_picksplit(),
    function 4(point, point) pg_catalog.spg_kd_inner_consistent(),
    function 5(point, point) pg_catalog.spg_quad_leaf_consistent();

alter operator family pg_catalog.kd_point_ops using spgist owner to postgres;

create operator class pg_catalog.kd_point_ops for type point using spgist as
    operator 11 pg_catalog.>^(point, point),
    operator 1 pg_catalog.<<(point, point),
    operator 5 pg_catalog.>>(point, point),
    operator 10 pg_catalog.<^(point, point),
    operator 6 pg_catalog.~=(point, point),
    operator 8 pg_catalog.<@(point, box),
    operator 15 pg_catalog.<->(point, point) for order by float_ops;

alter operator class pg_catalog.kd_point_ops using spgist owner to postgres;

create operator family pg_catalog.text_ops using spgist;

alter operator family pg_catalog.text_ops using spgist add
    function 1(text, text) pg_catalog.spg_text_config(),
    function 2(text, text) pg_catalog.spg_text_choose(),
    function 3(text, text) pg_catalog.spg_text_picksplit(),
    function 4(text, text) pg_catalog.spg_text_inner_consistent(),
    function 5(text, text) pg_catalog.spg_text_leaf_consistent();

alter operator family pg_catalog.text_ops using spgist owner to postgres;

create operator class pg_catalog.text_ops default for type text using spgist as
    operator 1 pg_catalog.~<~(text, text),
    operator 2 pg_catalog.~<=~(text, text),
    operator 3 pg_catalog.=(text, text),
    operator 4 pg_catalog.~>=~(text, text),
    operator 5 pg_catalog.~>~(text, text),
    operator 11 pg_catalog.<(text, text),
    operator 12 pg_catalog.<=(text, text),
    operator 14 pg_catalog.>=(text, text),
    operator 15 pg_catalog.>(text, text),
    operator 28 pg_catalog.^@(text, text);

alter operator class pg_catalog.text_ops using spgist owner to postgres;

create operator family pg_catalog.jsonb_ops using btree;

alter operator family pg_catalog.jsonb_ops using btree add
    function 1(jsonb, jsonb) pg_catalog.jsonb_cmp();

alter operator family pg_catalog.jsonb_ops using btree owner to postgres;

create operator class pg_catalog.jsonb_ops default for type jsonb using btree as
    operator 1 pg_catalog.<(jsonb, jsonb),
    operator 2 pg_catalog.<=(jsonb, jsonb),
    operator 3 pg_catalog.=(jsonb, jsonb),
    operator 4 pg_catalog.>=(jsonb, jsonb),
    operator 5 pg_catalog.>(jsonb, jsonb);

alter operator class pg_catalog.jsonb_ops using btree owner to postgres;

create operator family pg_catalog.jsonb_ops using hash;

alter operator family pg_catalog.jsonb_ops using hash add
    function 1(jsonb, jsonb) pg_catalog.jsonb_hash(),
    function 2(jsonb, jsonb) pg_catalog.jsonb_hash_extended();

alter operator family pg_catalog.jsonb_ops using hash owner to postgres;

create operator class pg_catalog.jsonb_ops default for type jsonb using hash as
    operator 1 pg_catalog.=(jsonb, jsonb);

alter operator class pg_catalog.jsonb_ops using hash owner to postgres;

create operator family pg_catalog.jsonb_ops using gin;

alter operator family pg_catalog.jsonb_ops using gin add
    function 1(jsonb, jsonb) pg_catalog.gin_compare_jsonb(),
    function 2(jsonb, jsonb) pg_catalog.gin_extract_jsonb(),
    function 3(jsonb, jsonb) pg_catalog.gin_extract_jsonb_query(),
    function 4(jsonb, jsonb) pg_catalog.gin_consistent_jsonb(),
    function 6(jsonb, jsonb) pg_catalog.gin_triconsistent_jsonb();

alter operator family pg_catalog.jsonb_ops using gin owner to postgres;

create operator class pg_catalog.jsonb_ops default for type jsonb using gin as storage text operator 7 pg_catalog.@>(jsonb, jsonb),
	operator 9 pg_catalog.?(jsonb, text),
	operator 10 pg_catalog.?|(jsonb, text[]),
	operator 11 pg_catalog.?&(jsonb, text[]),
	operator 15 pg_catalog.@?(jsonb, jsonpath),
	operator 16 pg_catalog.@@(jsonb, jsonpath);

alter operator class pg_catalog.jsonb_ops using gin owner to postgres;

create operator family pg_catalog.jsonb_path_ops using gin;

alter operator family pg_catalog.jsonb_path_ops using gin add
    function 1(jsonb, jsonb) pg_catalog.btint4cmp(),
    function 2(jsonb, jsonb) pg_catalog.gin_extract_jsonb_path(),
    function 3(jsonb, jsonb) pg_catalog.gin_extract_jsonb_query_path(),
    function 4(jsonb, jsonb) pg_catalog.gin_consistent_jsonb_path(),
    function 6(jsonb, jsonb) pg_catalog.gin_triconsistent_jsonb_path();

alter operator family pg_catalog.jsonb_path_ops using gin owner to postgres;

create operator class pg_catalog.jsonb_path_ops for type jsonb using gin as storage integer operator 7 pg_catalog.@>(jsonb, jsonb),
	operator 15 pg_catalog.@?(jsonb, jsonpath),
	operator 16 pg_catalog.@@(jsonb, jsonpath);

alter operator class pg_catalog.jsonb_path_ops using gin owner to postgres;

create operator family pg_catalog.integer_minmax_ops using brin;

alter operator family pg_catalog.integer_minmax_ops using brin add
    function 1(bigint, bigint) pg_catalog.brin_minmax_opcinfo(),
    function 2(bigint, bigint) pg_catalog.brin_minmax_add_value(),
    function 3(bigint, bigint) pg_catalog.brin_minmax_consistent(),
    function 4(bigint, bigint) pg_catalog.brin_minmax_union(),
    function 1(bigint, smallint) pg_catalog.brin_minmax_opcinfo(),
    function 2(bigint, smallint) pg_catalog.brin_minmax_add_value(),
    function 3(bigint, smallint) pg_catalog.brin_minmax_consistent(),
    function 4(bigint, smallint) pg_catalog.brin_minmax_union(),
    function 1(bigint, integer) pg_catalog.brin_minmax_opcinfo(),
    function 2(bigint, integer) pg_catalog.brin_minmax_add_value(),
    function 3(bigint, integer) pg_catalog.brin_minmax_consistent(),
    function 4(bigint, integer) pg_catalog.brin_minmax_union(),
    function 1(smallint, smallint) pg_catalog.brin_minmax_opcinfo(),
    function 2(smallint, smallint) pg_catalog.brin_minmax_add_value(),
    function 3(smallint, smallint) pg_catalog.brin_minmax_consistent(),
    function 4(smallint, smallint) pg_catalog.brin_minmax_union(),
    function 1(smallint, bigint) pg_catalog.brin_minmax_opcinfo(),
    function 2(smallint, bigint) pg_catalog.brin_minmax_add_value(),
    function 3(smallint, bigint) pg_catalog.brin_minmax_consistent(),
    function 4(smallint, bigint) pg_catalog.brin_minmax_union(),
    function 1(smallint, integer) pg_catalog.brin_minmax_opcinfo(),
    function 2(smallint, integer) pg_catalog.brin_minmax_add_value(),
    function 3(smallint, integer) pg_catalog.brin_minmax_consistent(),
    function 4(smallint, integer) pg_catalog.brin_minmax_union(),
    function 1(integer, integer) pg_catalog.brin_minmax_opcinfo(),
    function 2(integer, integer) pg_catalog.brin_minmax_add_value(),
    function 3(integer, integer) pg_catalog.brin_minmax_consistent(),
    function 4(integer, integer) pg_catalog.brin_minmax_union(),
    function 1(integer, bigint) pg_catalog.brin_minmax_opcinfo(),
    function 2(integer, bigint) pg_catalog.brin_minmax_add_value(),
    function 3(integer, bigint) pg_catalog.brin_minmax_consistent(),
    function 4(integer, bigint) pg_catalog.brin_minmax_union(),
    function 1(integer, smallint) pg_catalog.brin_minmax_opcinfo(),
    function 2(integer, smallint) pg_catalog.brin_minmax_add_value(),
    function 3(integer, smallint) pg_catalog.brin_minmax_consistent(),
    function 4(integer, smallint) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.integer_minmax_ops using brin owner to postgres;

create operator class pg_catalog.int8_minmax_ops default for type bigint using brin family pg_catalog.integer_minmax_ops as storage bigint operator 1 pg_catalog.<(bigint, bigint),
	operator 2 pg_catalog.<=(bigint, bigint),
	operator 3 pg_catalog.=(bigint, bigint),
	operator 4 pg_catalog.>=(bigint, bigint),
	operator 5 pg_catalog.>(bigint, bigint),
	operator 1 pg_catalog.<(bigint, smallint),
	operator 2 pg_catalog.<=(bigint, smallint),
	operator 3 pg_catalog.=(bigint, smallint),
	operator 4 pg_catalog.>=(bigint, smallint),
	operator 5 pg_catalog.>(bigint, smallint),
	operator 1 pg_catalog.<(bigint, integer),
	operator 2 pg_catalog.<=(bigint, integer),
	operator 3 pg_catalog.=(bigint, integer),
	operator 4 pg_catalog.>=(bigint, integer),
	operator 5 pg_catalog.>(bigint, integer),
	operator 1 pg_catalog.<(smallint, smallint),
	operator 2 pg_catalog.<=(smallint, smallint),
	operator 3 pg_catalog.=(smallint, smallint),
	operator 4 pg_catalog.>=(smallint, smallint),
	operator 5 pg_catalog.>(smallint, smallint),
	operator 1 pg_catalog.<(smallint, bigint),
	operator 2 pg_catalog.<=(smallint, bigint),
	operator 3 pg_catalog.=(smallint, bigint),
	operator 4 pg_catalog.>=(smallint, bigint),
	operator 5 pg_catalog.>(smallint, bigint),
	operator 1 pg_catalog.<(smallint, integer),
	operator 2 pg_catalog.<=(smallint, integer),
	operator 3 pg_catalog.=(smallint, integer),
	operator 4 pg_catalog.>=(smallint, integer),
	operator 5 pg_catalog.>(smallint, integer),
	operator 1 pg_catalog.<(integer, integer),
	operator 2 pg_catalog.<=(integer, integer),
	operator 3 pg_catalog.=(integer, integer),
	operator 4 pg_catalog.>=(integer, integer),
	operator 5 pg_catalog.>(integer, integer),
	operator 1 pg_catalog.<(integer, smallint),
	operator 2 pg_catalog.<=(integer, smallint),
	operator 3 pg_catalog.=(integer, smallint),
	operator 4 pg_catalog.>=(integer, smallint),
	operator 5 pg_catalog.>(integer, smallint),
	operator 1 pg_catalog.<(integer, bigint),
	operator 2 pg_catalog.<=(integer, bigint),
	operator 3 pg_catalog.=(integer, bigint),
	operator 4 pg_catalog.>=(integer, bigint),
	operator 5 pg_catalog.>(integer, bigint);

alter operator class pg_catalog.int8_minmax_ops using brin owner to postgres;

create operator class pg_catalog.int2_minmax_ops default for type smallint using brin family pg_catalog.integer_minmax_ops as storage smallint operator 1 pg_catalog.<(bigint, bigint),
	operator 2 pg_catalog.<=(bigint, bigint),
	operator 3 pg_catalog.=(bigint, bigint),
	operator 4 pg_catalog.>=(bigint, bigint),
	operator 5 pg_catalog.>(bigint, bigint),
	operator 1 pg_catalog.<(bigint, smallint),
	operator 2 pg_catalog.<=(bigint, smallint),
	operator 3 pg_catalog.=(bigint, smallint),
	operator 4 pg_catalog.>=(bigint, smallint),
	operator 5 pg_catalog.>(bigint, smallint),
	operator 1 pg_catalog.<(bigint, integer),
	operator 2 pg_catalog.<=(bigint, integer),
	operator 3 pg_catalog.=(bigint, integer),
	operator 4 pg_catalog.>=(bigint, integer),
	operator 5 pg_catalog.>(bigint, integer),
	operator 1 pg_catalog.<(smallint, smallint),
	operator 2 pg_catalog.<=(smallint, smallint),
	operator 3 pg_catalog.=(smallint, smallint),
	operator 4 pg_catalog.>=(smallint, smallint),
	operator 5 pg_catalog.>(smallint, smallint),
	operator 1 pg_catalog.<(smallint, bigint),
	operator 2 pg_catalog.<=(smallint, bigint),
	operator 3 pg_catalog.=(smallint, bigint),
	operator 4 pg_catalog.>=(smallint, bigint),
	operator 5 pg_catalog.>(smallint, bigint),
	operator 1 pg_catalog.<(smallint, integer),
	operator 2 pg_catalog.<=(smallint, integer),
	operator 3 pg_catalog.=(smallint, integer),
	operator 4 pg_catalog.>=(smallint, integer),
	operator 5 pg_catalog.>(smallint, integer),
	operator 1 pg_catalog.<(integer, integer),
	operator 2 pg_catalog.<=(integer, integer),
	operator 3 pg_catalog.=(integer, integer),
	operator 4 pg_catalog.>=(integer, integer),
	operator 5 pg_catalog.>(integer, integer),
	operator 1 pg_catalog.<(integer, smallint),
	operator 2 pg_catalog.<=(integer, smallint),
	operator 3 pg_catalog.=(integer, smallint),
	operator 4 pg_catalog.>=(integer, smallint),
	operator 5 pg_catalog.>(integer, smallint),
	operator 1 pg_catalog.<(integer, bigint),
	operator 2 pg_catalog.<=(integer, bigint),
	operator 3 pg_catalog.=(integer, bigint),
	operator 4 pg_catalog.>=(integer, bigint),
	operator 5 pg_catalog.>(integer, bigint);

alter operator class pg_catalog.int2_minmax_ops using brin owner to postgres;

create operator class pg_catalog.int4_minmax_ops default for type integer using brin family pg_catalog.integer_minmax_ops as storage integer operator 1 pg_catalog.<(bigint, bigint),
	operator 2 pg_catalog.<=(bigint, bigint),
	operator 3 pg_catalog.=(bigint, bigint),
	operator 4 pg_catalog.>=(bigint, bigint),
	operator 5 pg_catalog.>(bigint, bigint),
	operator 1 pg_catalog.<(bigint, smallint),
	operator 2 pg_catalog.<=(bigint, smallint),
	operator 3 pg_catalog.=(bigint, smallint),
	operator 4 pg_catalog.>=(bigint, smallint),
	operator 5 pg_catalog.>(bigint, smallint),
	operator 1 pg_catalog.<(bigint, integer),
	operator 2 pg_catalog.<=(bigint, integer),
	operator 3 pg_catalog.=(bigint, integer),
	operator 4 pg_catalog.>=(bigint, integer),
	operator 5 pg_catalog.>(bigint, integer),
	operator 1 pg_catalog.<(smallint, smallint),
	operator 2 pg_catalog.<=(smallint, smallint),
	operator 3 pg_catalog.=(smallint, smallint),
	operator 4 pg_catalog.>=(smallint, smallint),
	operator 5 pg_catalog.>(smallint, smallint),
	operator 1 pg_catalog.<(smallint, bigint),
	operator 2 pg_catalog.<=(smallint, bigint),
	operator 3 pg_catalog.=(smallint, bigint),
	operator 4 pg_catalog.>=(smallint, bigint),
	operator 5 pg_catalog.>(smallint, bigint),
	operator 1 pg_catalog.<(smallint, integer),
	operator 2 pg_catalog.<=(smallint, integer),
	operator 3 pg_catalog.=(smallint, integer),
	operator 4 pg_catalog.>=(smallint, integer),
	operator 5 pg_catalog.>(smallint, integer),
	operator 1 pg_catalog.<(integer, integer),
	operator 2 pg_catalog.<=(integer, integer),
	operator 3 pg_catalog.=(integer, integer),
	operator 4 pg_catalog.>=(integer, integer),
	operator 5 pg_catalog.>(integer, integer),
	operator 1 pg_catalog.<(integer, smallint),
	operator 2 pg_catalog.<=(integer, smallint),
	operator 3 pg_catalog.=(integer, smallint),
	operator 4 pg_catalog.>=(integer, smallint),
	operator 5 pg_catalog.>(integer, smallint),
	operator 1 pg_catalog.<(integer, bigint),
	operator 2 pg_catalog.<=(integer, bigint),
	operator 3 pg_catalog.=(integer, bigint),
	operator 4 pg_catalog.>=(integer, bigint),
	operator 5 pg_catalog.>(integer, bigint);

alter operator class pg_catalog.int4_minmax_ops using brin owner to postgres;

create operator family pg_catalog.numeric_minmax_ops using brin;

alter operator family pg_catalog.numeric_minmax_ops using brin add
    function 1(numeric, numeric) pg_catalog.brin_minmax_opcinfo(),
    function 2(numeric, numeric) pg_catalog.brin_minmax_add_value(),
    function 3(numeric, numeric) pg_catalog.brin_minmax_consistent(),
    function 4(numeric, numeric) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.numeric_minmax_ops using brin owner to postgres;

create operator class pg_catalog.numeric_minmax_ops default for type numeric using brin as storage numeric operator 1 pg_catalog.<(numeric, numeric),
	operator 2 pg_catalog.<=(numeric, numeric),
	operator 3 pg_catalog.=(numeric, numeric),
	operator 4 pg_catalog.>=(numeric, numeric),
	operator 5 pg_catalog.>(numeric, numeric);

alter operator class pg_catalog.numeric_minmax_ops using brin owner to postgres;

create operator family pg_catalog.text_minmax_ops using brin;

alter operator family pg_catalog.text_minmax_ops using brin add
    function 1(text, text) pg_catalog.brin_minmax_opcinfo(),
    function 2(text, text) pg_catalog.brin_minmax_add_value(),
    function 3(text, text) pg_catalog.brin_minmax_consistent(),
    function 4(text, text) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.text_minmax_ops using brin owner to postgres;

create operator class pg_catalog.text_minmax_ops default for type text using brin as storage text operator 1 pg_catalog.<(text, text),
	operator 2 pg_catalog.<=(text, text),
	operator 3 pg_catalog.=(text, text),
	operator 4 pg_catalog.>=(text, text),
	operator 5 pg_catalog.>(text, text);

alter operator class pg_catalog.text_minmax_ops using brin owner to postgres;

create operator family pg_catalog.timetz_minmax_ops using brin;

alter operator family pg_catalog.timetz_minmax_ops using brin add
    function 1(time with time zone, time with time zone) pg_catalog.brin_minmax_opcinfo(),
    function 2(time with time zone, time with time zone) pg_catalog.brin_minmax_add_value(),
    function 3(time with time zone, time with time zone) pg_catalog.brin_minmax_consistent(),
    function 4(time with time zone, time with time zone) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.timetz_minmax_ops using brin owner to postgres;

create operator class pg_catalog.timetz_minmax_ops default for type time with time zone using brin as storage time with time zone operator 1 pg_catalog.<(time with time zone, time with time zone),
	operator 2 pg_catalog.<=(time with time zone, time with time zone),
	operator 3 pg_catalog.=(time with time zone, time with time zone),
	operator 4 pg_catalog.>=(time with time zone, time with time zone),
	operator 5 pg_catalog.>(time with time zone, time with time zone);

alter operator class pg_catalog.timetz_minmax_ops using brin owner to postgres;

create operator family pg_catalog.datetime_minmax_ops using brin;

alter operator family pg_catalog.datetime_minmax_ops using brin add
    function 1(timestamp without time zone, timestamp without time zone) pg_catalog.brin_minmax_opcinfo(),
    function 2(timestamp without time zone, timestamp without time zone) pg_catalog.brin_minmax_add_value(),
    function 3(timestamp without time zone, timestamp without time zone) pg_catalog.brin_minmax_consistent(),
    function 4(timestamp without time zone, timestamp without time zone) pg_catalog.brin_minmax_union(),
    function 1(timestamp without time zone, timestamp with time zone) pg_catalog.brin_minmax_opcinfo(),
    function 2(timestamp without time zone, timestamp with time zone) pg_catalog.brin_minmax_add_value(),
    function 3(timestamp without time zone, timestamp with time zone) pg_catalog.brin_minmax_consistent(),
    function 4(timestamp without time zone, timestamp with time zone) pg_catalog.brin_minmax_union(),
    function 1(timestamp without time zone, date) pg_catalog.brin_minmax_opcinfo(),
    function 2(timestamp without time zone, date) pg_catalog.brin_minmax_add_value(),
    function 3(timestamp without time zone, date) pg_catalog.brin_minmax_consistent(),
    function 4(timestamp without time zone, date) pg_catalog.brin_minmax_union(),
    function 1(timestamp with time zone, timestamp with time zone) pg_catalog.brin_minmax_opcinfo(),
    function 2(timestamp with time zone, timestamp with time zone) pg_catalog.brin_minmax_add_value(),
    function 3(timestamp with time zone, timestamp with time zone) pg_catalog.brin_minmax_consistent(),
    function 4(timestamp with time zone, timestamp with time zone) pg_catalog.brin_minmax_union(),
    function 1(timestamp with time zone, timestamp without time zone) pg_catalog.brin_minmax_opcinfo(),
    function 2(timestamp with time zone, timestamp without time zone) pg_catalog.brin_minmax_add_value(),
    function 3(timestamp with time zone, timestamp without time zone) pg_catalog.brin_minmax_consistent(),
    function 4(timestamp with time zone, timestamp without time zone) pg_catalog.brin_minmax_union(),
    function 1(timestamp with time zone, date) pg_catalog.brin_minmax_opcinfo(),
    function 2(timestamp with time zone, date) pg_catalog.brin_minmax_add_value(),
    function 3(timestamp with time zone, date) pg_catalog.brin_minmax_consistent(),
    function 4(timestamp with time zone, date) pg_catalog.brin_minmax_union(),
    function 1(date, date) pg_catalog.brin_minmax_opcinfo(),
    function 2(date, date) pg_catalog.brin_minmax_add_value(),
    function 3(date, date) pg_catalog.brin_minmax_consistent(),
    function 4(date, date) pg_catalog.brin_minmax_union(),
    function 1(date, timestamp without time zone) pg_catalog.brin_minmax_opcinfo(),
    function 2(date, timestamp without time zone) pg_catalog.brin_minmax_add_value(),
    function 3(date, timestamp without time zone) pg_catalog.brin_minmax_consistent(),
    function 4(date, timestamp without time zone) pg_catalog.brin_minmax_union(),
    function 1(date, timestamp with time zone) pg_catalog.brin_minmax_opcinfo(),
    function 2(date, timestamp with time zone) pg_catalog.brin_minmax_add_value(),
    function 3(date, timestamp with time zone) pg_catalog.brin_minmax_consistent(),
    function 4(date, timestamp with time zone) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.datetime_minmax_ops using brin owner to postgres;

create operator class pg_catalog.date_minmax_ops default for type date using brin family pg_catalog.datetime_minmax_ops as storage date operator 1 pg_catalog.<(timestamp, timestamp),
	operator 2 pg_catalog.<=(timestamp, timestamp),
	operator 3 pg_catalog.=(timestamp, timestamp),
	operator 4 pg_catalog.>=(timestamp, timestamp),
	operator 5 pg_catalog.>(timestamp, timestamp),
	operator 1 pg_catalog.<(timestamp, date),
	operator 2 pg_catalog.<=(timestamp, date),
	operator 3 pg_catalog.=(timestamp, date),
	operator 4 pg_catalog.>=(timestamp, date),
	operator 5 pg_catalog.>(timestamp, date),
	operator 1 pg_catalog.<(timestamp, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp, timestamp with time zone),
	operator 1 pg_catalog.<(date, date),
	operator 2 pg_catalog.<=(date, date),
	operator 3 pg_catalog.=(date, date),
	operator 4 pg_catalog.>=(date, date),
	operator 5 pg_catalog.>(date, date),
	operator 1 pg_catalog.<(date, timestamp),
	operator 2 pg_catalog.<=(date, timestamp),
	operator 3 pg_catalog.=(date, timestamp),
	operator 4 pg_catalog.>=(date, timestamp),
	operator 5 pg_catalog.>(date, timestamp),
	operator 1 pg_catalog.<(date, timestamp with time zone),
	operator 2 pg_catalog.<=(date, timestamp with time zone),
	operator 3 pg_catalog.=(date, timestamp with time zone),
	operator 4 pg_catalog.>=(date, timestamp with time zone),
	operator 5 pg_catalog.>(date, timestamp with time zone),
	operator 1 pg_catalog.<(timestamp with time zone, date),
	operator 2 pg_catalog.<=(timestamp with time zone, date),
	operator 3 pg_catalog.=(timestamp with time zone, date),
	operator 4 pg_catalog.>=(timestamp with time zone, date),
	operator 5 pg_catalog.>(timestamp with time zone, date),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone);

alter operator class pg_catalog.date_minmax_ops using brin owner to postgres;

create operator class pg_catalog.timestamp_minmax_ops default for type timestamp without time zone using brin family pg_catalog.datetime_minmax_ops as storage timestamp without time zone operator 1 pg_catalog.<(timestamp, timestamp),
	operator 2 pg_catalog.<=(timestamp, timestamp),
	operator 3 pg_catalog.=(timestamp, timestamp),
	operator 4 pg_catalog.>=(timestamp, timestamp),
	operator 5 pg_catalog.>(timestamp, timestamp),
	operator 1 pg_catalog.<(timestamp, date),
	operator 2 pg_catalog.<=(timestamp, date),
	operator 3 pg_catalog.=(timestamp, date),
	operator 4 pg_catalog.>=(timestamp, date),
	operator 5 pg_catalog.>(timestamp, date),
	operator 1 pg_catalog.<(timestamp, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp, timestamp with time zone),
	operator 1 pg_catalog.<(date, date),
	operator 2 pg_catalog.<=(date, date),
	operator 3 pg_catalog.=(date, date),
	operator 4 pg_catalog.>=(date, date),
	operator 5 pg_catalog.>(date, date),
	operator 1 pg_catalog.<(date, timestamp),
	operator 2 pg_catalog.<=(date, timestamp),
	operator 3 pg_catalog.=(date, timestamp),
	operator 4 pg_catalog.>=(date, timestamp),
	operator 5 pg_catalog.>(date, timestamp),
	operator 1 pg_catalog.<(date, timestamp with time zone),
	operator 2 pg_catalog.<=(date, timestamp with time zone),
	operator 3 pg_catalog.=(date, timestamp with time zone),
	operator 4 pg_catalog.>=(date, timestamp with time zone),
	operator 5 pg_catalog.>(date, timestamp with time zone),
	operator 1 pg_catalog.<(timestamp with time zone, date),
	operator 2 pg_catalog.<=(timestamp with time zone, date),
	operator 3 pg_catalog.=(timestamp with time zone, date),
	operator 4 pg_catalog.>=(timestamp with time zone, date),
	operator 5 pg_catalog.>(timestamp with time zone, date),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone);

alter operator class pg_catalog.timestamp_minmax_ops using brin owner to postgres;

create operator class pg_catalog.timestamptz_minmax_ops default for type timestamp with time zone using brin family pg_catalog.datetime_minmax_ops as storage timestamp with time zone operator 1 pg_catalog.<(timestamp, timestamp),
	operator 2 pg_catalog.<=(timestamp, timestamp),
	operator 3 pg_catalog.=(timestamp, timestamp),
	operator 4 pg_catalog.>=(timestamp, timestamp),
	operator 5 pg_catalog.>(timestamp, timestamp),
	operator 1 pg_catalog.<(timestamp, date),
	operator 2 pg_catalog.<=(timestamp, date),
	operator 3 pg_catalog.=(timestamp, date),
	operator 4 pg_catalog.>=(timestamp, date),
	operator 5 pg_catalog.>(timestamp, date),
	operator 1 pg_catalog.<(timestamp, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp, timestamp with time zone),
	operator 1 pg_catalog.<(date, date),
	operator 2 pg_catalog.<=(date, date),
	operator 3 pg_catalog.=(date, date),
	operator 4 pg_catalog.>=(date, date),
	operator 5 pg_catalog.>(date, date),
	operator 1 pg_catalog.<(date, timestamp),
	operator 2 pg_catalog.<=(date, timestamp),
	operator 3 pg_catalog.=(date, timestamp),
	operator 4 pg_catalog.>=(date, timestamp),
	operator 5 pg_catalog.>(date, timestamp),
	operator 1 pg_catalog.<(date, timestamp with time zone),
	operator 2 pg_catalog.<=(date, timestamp with time zone),
	operator 3 pg_catalog.=(date, timestamp with time zone),
	operator 4 pg_catalog.>=(date, timestamp with time zone),
	operator 5 pg_catalog.>(date, timestamp with time zone),
	operator 1 pg_catalog.<(timestamp with time zone, date),
	operator 2 pg_catalog.<=(timestamp with time zone, date),
	operator 3 pg_catalog.=(timestamp with time zone, date),
	operator 4 pg_catalog.>=(timestamp with time zone, date),
	operator 5 pg_catalog.>(timestamp with time zone, date),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone);

alter operator class pg_catalog.timestamptz_minmax_ops using brin owner to postgres;

create operator family pg_catalog.char_minmax_ops using brin;

alter operator family pg_catalog.char_minmax_ops using brin add
    function 1("char", "char") pg_catalog.brin_minmax_opcinfo(),
    function 2("char", "char") pg_catalog.brin_minmax_add_value(),
    function 3("char", "char") pg_catalog.brin_minmax_consistent(),
    function 4("char", "char") pg_catalog.brin_minmax_union();

alter operator family pg_catalog.char_minmax_ops using brin owner to postgres;

create operator class pg_catalog.char_minmax_ops default for type "char" using brin as storage "char" operator 1 pg_catalog.<("char", "char"),
	operator 2 pg_catalog.<=("char", "char"),
	operator 3 pg_catalog.=("char", "char"),
	operator 4 pg_catalog.>=("char", "char"),
	operator 5 pg_catalog.>("char", "char");

alter operator class pg_catalog.char_minmax_ops using brin owner to postgres;

create operator family pg_catalog.bytea_minmax_ops using brin;

alter operator family pg_catalog.bytea_minmax_ops using brin add
    function 1(bytea, bytea) pg_catalog.brin_minmax_opcinfo(),
    function 2(bytea, bytea) pg_catalog.brin_minmax_add_value(),
    function 3(bytea, bytea) pg_catalog.brin_minmax_consistent(),
    function 4(bytea, bytea) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.bytea_minmax_ops using brin owner to postgres;

create operator class pg_catalog.bytea_minmax_ops default for type bytea using brin as storage bytea operator 1 pg_catalog.<(bytea, bytea),
	operator 2 pg_catalog.<=(bytea, bytea),
	operator 3 pg_catalog.=(bytea, bytea),
	operator 4 pg_catalog.>=(bytea, bytea),
	operator 5 pg_catalog.>(bytea, bytea);

alter operator class pg_catalog.bytea_minmax_ops using brin owner to postgres;

create operator family pg_catalog.name_minmax_ops using brin;

alter operator family pg_catalog.name_minmax_ops using brin add
    function 1(name, name) pg_catalog.brin_minmax_opcinfo(),
    function 2(name, name) pg_catalog.brin_minmax_add_value(),
    function 3(name, name) pg_catalog.brin_minmax_consistent(),
    function 4(name, name) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.name_minmax_ops using brin owner to postgres;

create operator class pg_catalog.name_minmax_ops default for type name using brin as storage name operator 1 pg_catalog.<(name, name),
	operator 2 pg_catalog.<=(name, name),
	operator 3 pg_catalog.=(name, name),
	operator 4 pg_catalog.>=(name, name),
	operator 5 pg_catalog.>(name, name);

alter operator class pg_catalog.name_minmax_ops using brin owner to postgres;

create operator family pg_catalog.oid_minmax_ops using brin;

alter operator family pg_catalog.oid_minmax_ops using brin add
    function 1(oid, oid) pg_catalog.brin_minmax_opcinfo(),
    function 2(oid, oid) pg_catalog.brin_minmax_add_value(),
    function 3(oid, oid) pg_catalog.brin_minmax_consistent(),
    function 4(oid, oid) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.oid_minmax_ops using brin owner to postgres;

create operator class pg_catalog.oid_minmax_ops default for type oid using brin as storage oid operator 1 pg_catalog.<(oid, oid),
	operator 2 pg_catalog.<=(oid, oid),
	operator 3 pg_catalog.=(oid, oid),
	operator 4 pg_catalog.>=(oid, oid),
	operator 5 pg_catalog.>(oid, oid);

alter operator class pg_catalog.oid_minmax_ops using brin owner to postgres;

create operator family pg_catalog.tid_minmax_ops using brin;

alter operator family pg_catalog.tid_minmax_ops using brin add
    function 1(tid, tid) pg_catalog.brin_minmax_opcinfo(),
    function 2(tid, tid) pg_catalog.brin_minmax_add_value(),
    function 3(tid, tid) pg_catalog.brin_minmax_consistent(),
    function 4(tid, tid) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.tid_minmax_ops using brin owner to postgres;

create operator class pg_catalog.tid_minmax_ops default for type tid using brin as storage tid operator 1 pg_catalog.<(tid, tid),
	operator 2 pg_catalog.<=(tid, tid),
	operator 3 pg_catalog.=(tid, tid),
	operator 4 pg_catalog.>=(tid, tid),
	operator 5 pg_catalog.>(tid, tid);

alter operator class pg_catalog.tid_minmax_ops using brin owner to postgres;

create operator family pg_catalog.float_minmax_ops using brin;

alter operator family pg_catalog.float_minmax_ops using brin add
    function 1(real, real) pg_catalog.brin_minmax_opcinfo(),
    function 2(real, real) pg_catalog.brin_minmax_add_value(),
    function 3(real, real) pg_catalog.brin_minmax_consistent(),
    function 4(real, real) pg_catalog.brin_minmax_union(),
    function 1(real, double precision) pg_catalog.brin_minmax_opcinfo(),
    function 2(real, double precision) pg_catalog.brin_minmax_add_value(),
    function 3(real, double precision) pg_catalog.brin_minmax_consistent(),
    function 4(real, double precision) pg_catalog.brin_minmax_union(),
    function 1(double precision, double precision) pg_catalog.brin_minmax_opcinfo(),
    function 2(double precision, double precision) pg_catalog.brin_minmax_add_value(),
    function 3(double precision, double precision) pg_catalog.brin_minmax_consistent(),
    function 4(double precision, double precision) pg_catalog.brin_minmax_union(),
    function 1(double precision, real) pg_catalog.brin_minmax_opcinfo(),
    function 2(double precision, real) pg_catalog.brin_minmax_add_value(),
    function 3(double precision, real) pg_catalog.brin_minmax_consistent(),
    function 4(double precision, real) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.float_minmax_ops using brin owner to postgres;

create operator class pg_catalog.float4_minmax_ops default for type real using brin family pg_catalog.float_minmax_ops as storage real operator 1 pg_catalog.<(real, real),
	operator 2 pg_catalog.<=(real, real),
	operator 3 pg_catalog.=(real, real),
	operator 4 pg_catalog.>=(real, real),
	operator 5 pg_catalog.>(real, real),
	operator 1 pg_catalog.<(real, double precision),
	operator 2 pg_catalog.<=(real, double precision),
	operator 3 pg_catalog.=(real, double precision),
	operator 4 pg_catalog.>=(real, double precision),
	operator 5 pg_catalog.>(real, double precision),
	operator 1 pg_catalog.<(double precision, real),
	operator 2 pg_catalog.<=(double precision, real),
	operator 3 pg_catalog.=(double precision, real),
	operator 4 pg_catalog.>=(double precision, real),
	operator 5 pg_catalog.>(double precision, real),
	operator 1 pg_catalog.<(double precision, double precision),
	operator 2 pg_catalog.<=(double precision, double precision),
	operator 3 pg_catalog.=(double precision, double precision),
	operator 4 pg_catalog.>=(double precision, double precision),
	operator 5 pg_catalog.>(double precision, double precision);

alter operator class pg_catalog.float4_minmax_ops using brin owner to postgres;

create operator class pg_catalog.float8_minmax_ops default for type double precision using brin family pg_catalog.float_minmax_ops as storage double precision operator 1 pg_catalog.<(real, real),
	operator 2 pg_catalog.<=(real, real),
	operator 3 pg_catalog.=(real, real),
	operator 4 pg_catalog.>=(real, real),
	operator 5 pg_catalog.>(real, real),
	operator 1 pg_catalog.<(real, double precision),
	operator 2 pg_catalog.<=(real, double precision),
	operator 3 pg_catalog.=(real, double precision),
	operator 4 pg_catalog.>=(real, double precision),
	operator 5 pg_catalog.>(real, double precision),
	operator 1 pg_catalog.<(double precision, real),
	operator 2 pg_catalog.<=(double precision, real),
	operator 3 pg_catalog.=(double precision, real),
	operator 4 pg_catalog.>=(double precision, real),
	operator 5 pg_catalog.>(double precision, real),
	operator 1 pg_catalog.<(double precision, double precision),
	operator 2 pg_catalog.<=(double precision, double precision),
	operator 3 pg_catalog.=(double precision, double precision),
	operator 4 pg_catalog.>=(double precision, double precision),
	operator 5 pg_catalog.>(double precision, double precision);

alter operator class pg_catalog.float8_minmax_ops using brin owner to postgres;

create operator family pg_catalog.macaddr_minmax_ops using brin;

alter operator family pg_catalog.macaddr_minmax_ops using brin add
    function 1(macaddr, macaddr) pg_catalog.brin_minmax_opcinfo(),
    function 2(macaddr, macaddr) pg_catalog.brin_minmax_add_value(),
    function 3(macaddr, macaddr) pg_catalog.brin_minmax_consistent(),
    function 4(macaddr, macaddr) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.macaddr_minmax_ops using brin owner to postgres;

create operator class pg_catalog.macaddr_minmax_ops default for type macaddr using brin as storage macaddr operator 1 pg_catalog.<(macaddr, macaddr),
	operator 2 pg_catalog.<=(macaddr, macaddr),
	operator 3 pg_catalog.=(macaddr, macaddr),
	operator 4 pg_catalog.>=(macaddr, macaddr),
	operator 5 pg_catalog.>(macaddr, macaddr);

alter operator class pg_catalog.macaddr_minmax_ops using brin owner to postgres;

create operator family pg_catalog.network_minmax_ops using brin;

alter operator family pg_catalog.network_minmax_ops using brin add
    function 1(inet, inet) pg_catalog.brin_minmax_opcinfo(),
    function 2(inet, inet) pg_catalog.brin_minmax_add_value(),
    function 3(inet, inet) pg_catalog.brin_minmax_consistent(),
    function 4(inet, inet) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.network_minmax_ops using brin owner to postgres;

create operator class pg_catalog.inet_minmax_ops for type inet using brin family pg_catalog.network_minmax_ops as storage inet operator 1 pg_catalog.<(inet, inet),
	operator 2 pg_catalog.<=(inet, inet),
	operator 3 pg_catalog.=(inet, inet),
	operator 4 pg_catalog.>=(inet, inet),
	operator 5 pg_catalog.>(inet, inet);

alter operator class pg_catalog.inet_minmax_ops using brin owner to postgres;

create operator family pg_catalog.bpchar_minmax_ops using brin;

alter operator family pg_catalog.bpchar_minmax_ops using brin add
    function 1(character, character) pg_catalog.brin_minmax_opcinfo(),
    function 2(character, character) pg_catalog.brin_minmax_add_value(),
    function 3(character, character) pg_catalog.brin_minmax_consistent(),
    function 4(character, character) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.bpchar_minmax_ops using brin owner to postgres;

create operator class pg_catalog.bpchar_minmax_ops default for type character using brin as storage character operator 1 pg_catalog.<(char, char),
	operator 2 pg_catalog.<=(char, char),
	operator 3 pg_catalog.=(char, char),
	operator 4 pg_catalog.>=(char, char),
	operator 5 pg_catalog.>(char, char);

alter operator class pg_catalog.bpchar_minmax_ops using brin owner to postgres;

create operator family pg_catalog.time_minmax_ops using brin;

alter operator family pg_catalog.time_minmax_ops using brin add
    function 1(time without time zone, time without time zone) pg_catalog.brin_minmax_opcinfo(),
    function 2(time without time zone, time without time zone) pg_catalog.brin_minmax_add_value(),
    function 3(time without time zone, time without time zone) pg_catalog.brin_minmax_consistent(),
    function 4(time without time zone, time without time zone) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.time_minmax_ops using brin owner to postgres;

create operator class pg_catalog.time_minmax_ops default for type time without time zone using brin as storage time without time zone operator 1 pg_catalog.<(time, time),
	operator 2 pg_catalog.<=(time, time),
	operator 3 pg_catalog.=(time, time),
	operator 4 pg_catalog.>=(time, time),
	operator 5 pg_catalog.>(time, time);

alter operator class pg_catalog.time_minmax_ops using brin owner to postgres;

create operator family pg_catalog.interval_minmax_ops using brin;

alter operator family pg_catalog.interval_minmax_ops using brin add
    function 1(interval, interval) pg_catalog.brin_minmax_opcinfo(),
    function 2(interval, interval) pg_catalog.brin_minmax_add_value(),
    function 3(interval, interval) pg_catalog.brin_minmax_consistent(),
    function 4(interval, interval) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.interval_minmax_ops using brin owner to postgres;

create operator class pg_catalog.interval_minmax_ops default for type interval using brin as storage interval operator 1 pg_catalog.<(interval, interval),
	operator 2 pg_catalog.<=(interval, interval),
	operator 3 pg_catalog.=(interval, interval),
	operator 4 pg_catalog.>=(interval, interval),
	operator 5 pg_catalog.>(interval, interval);

alter operator class pg_catalog.interval_minmax_ops using brin owner to postgres;

create operator family pg_catalog.bit_minmax_ops using brin;

alter operator family pg_catalog.bit_minmax_ops using brin add
    function 1(bit, bit) pg_catalog.brin_minmax_opcinfo(),
    function 2(bit, bit) pg_catalog.brin_minmax_add_value(),
    function 3(bit, bit) pg_catalog.brin_minmax_consistent(),
    function 4(bit, bit) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.bit_minmax_ops using brin owner to postgres;

create operator class pg_catalog.bit_minmax_ops default for type bit using brin as storage bit operator 1 pg_catalog.<(bit, bit),
	operator 2 pg_catalog.<=(bit, bit),
	operator 3 pg_catalog.=(bit, bit),
	operator 4 pg_catalog.>=(bit, bit),
	operator 5 pg_catalog.>(bit, bit);

alter operator class pg_catalog.bit_minmax_ops using brin owner to postgres;

create operator family pg_catalog.varbit_minmax_ops using brin;

alter operator family pg_catalog.varbit_minmax_ops using brin add
    function 1(bit varying, bit varying) pg_catalog.brin_minmax_opcinfo(),
    function 2(bit varying, bit varying) pg_catalog.brin_minmax_add_value(),
    function 3(bit varying, bit varying) pg_catalog.brin_minmax_consistent(),
    function 4(bit varying, bit varying) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.varbit_minmax_ops using brin owner to postgres;

create operator class pg_catalog.varbit_minmax_ops default for type bit varying using brin as storage bit varying operator 1 pg_catalog.<(bit varying, bit varying),
	operator 2 pg_catalog.<=(bit varying, bit varying),
	operator 3 pg_catalog.=(bit varying, bit varying),
	operator 4 pg_catalog.>=(bit varying, bit varying),
	operator 5 pg_catalog.>(bit varying, bit varying);

alter operator class pg_catalog.varbit_minmax_ops using brin owner to postgres;

create operator family pg_catalog.uuid_minmax_ops using brin;

alter operator family pg_catalog.uuid_minmax_ops using brin add
    function 1(uuid, uuid) pg_catalog.brin_minmax_opcinfo(),
    function 2(uuid, uuid) pg_catalog.brin_minmax_add_value(),
    function 3(uuid, uuid) pg_catalog.brin_minmax_consistent(),
    function 4(uuid, uuid) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.uuid_minmax_ops using brin owner to postgres;

create operator class pg_catalog.uuid_minmax_ops default for type uuid using brin as storage uuid operator 1 pg_catalog.<(uuid, uuid),
	operator 2 pg_catalog.<=(uuid, uuid),
	operator 3 pg_catalog.=(uuid, uuid),
	operator 4 pg_catalog.>=(uuid, uuid),
	operator 5 pg_catalog.>(uuid, uuid);

alter operator class pg_catalog.uuid_minmax_ops using brin owner to postgres;

create operator family pg_catalog.pg_lsn_minmax_ops using brin;

alter operator family pg_catalog.pg_lsn_minmax_ops using brin add
    function 1(pg_lsn, pg_lsn) pg_catalog.brin_minmax_opcinfo(),
    function 2(pg_lsn, pg_lsn) pg_catalog.brin_minmax_add_value(),
    function 3(pg_lsn, pg_lsn) pg_catalog.brin_minmax_consistent(),
    function 4(pg_lsn, pg_lsn) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.pg_lsn_minmax_ops using brin owner to postgres;

create operator class pg_catalog.pg_lsn_minmax_ops default for type pg_lsn using brin as storage pg_lsn operator 1 pg_catalog.<(pg_lsn, pg_lsn),
	operator 2 pg_catalog.<=(pg_lsn, pg_lsn),
	operator 3 pg_catalog.=(pg_lsn, pg_lsn),
	operator 4 pg_catalog.>=(pg_lsn, pg_lsn),
	operator 5 pg_catalog.>(pg_lsn, pg_lsn);

alter operator class pg_catalog.pg_lsn_minmax_ops using brin owner to postgres;

create operator family pg_catalog.network_inclusion_ops using brin;

alter operator family pg_catalog.network_inclusion_ops using brin add
    function 1(inet, inet) pg_catalog.brin_inclusion_opcinfo(),
    function 2(inet, inet) pg_catalog.brin_inclusion_add_value(),
    function 3(inet, inet) pg_catalog.brin_inclusion_consistent(),
    function 4(inet, inet) pg_catalog.brin_inclusion_union(),
    function 11(inet, inet) pg_catalog.inet_merge(),
    function 12(inet, inet) pg_catalog.inet_same_family(),
    function 13(inet, inet) pg_catalog.network_supeq();

alter operator family pg_catalog.network_inclusion_ops using brin owner to postgres;

create operator class pg_catalog.inet_inclusion_ops default for type inet using brin family pg_catalog.network_inclusion_ops as storage inet operator 3 pg_catalog.&&(inet, inet),
	operator 7 pg_catalog.>>=(inet, inet),
	operator 8 pg_catalog.<<=(inet, inet),
	operator 18 pg_catalog.=(inet, inet),
	operator 24 pg_catalog.>>(inet, inet),
	operator 26 pg_catalog.<<(inet, inet);

alter operator class pg_catalog.inet_inclusion_ops using brin owner to postgres;

create operator family pg_catalog.range_inclusion_ops using brin;

alter operator family pg_catalog.range_inclusion_ops using brin add
    function 1(anyrange, anyrange) pg_catalog.brin_inclusion_opcinfo(),
    function 2(anyrange, anyrange) pg_catalog.brin_inclusion_add_value(),
    function 3(anyrange, anyrange) pg_catalog.brin_inclusion_consistent(),
    function 4(anyrange, anyrange) pg_catalog.brin_inclusion_union(),
    function 11(anyrange, anyrange) pg_catalog.range_merge(),
    function 13(anyrange, anyrange) pg_catalog.range_contains(),
    function 14(anyrange, anyrange) pg_catalog.isempty();

alter operator family pg_catalog.range_inclusion_ops using brin owner to postgres;

create operator class pg_catalog.range_inclusion_ops default for type anyrange using brin as storage anyrange operator 1 pg_catalog.<<(anyrange, anyrange),
	operator 2 pg_catalog.&<(anyrange, anyrange),
	operator 3 pg_catalog.&&(anyrange, anyrange),
	operator 4 pg_catalog.&>(anyrange, anyrange),
	operator 5 pg_catalog.>>(anyrange, anyrange),
	operator 7 pg_catalog.@>(anyrange, anyrange),
	operator 8 pg_catalog.<@(anyrange, anyrange),
	operator 16 pg_catalog.@>(anyrange, anyelement),
	operator 17 pg_catalog.-|-(anyrange, anyrange),
	operator 18 pg_catalog.=(anyrange, anyrange),
	operator 20 pg_catalog.<(anyrange, anyrange),
	operator 21 pg_catalog.<=(anyrange, anyrange),
	operator 22 pg_catalog.>(anyrange, anyrange),
	operator 23 pg_catalog.>=(anyrange, anyrange);

alter operator class pg_catalog.range_inclusion_ops using brin owner to postgres;

create operator family pg_catalog.box_inclusion_ops using brin;

alter operator family pg_catalog.box_inclusion_ops using brin add
    function 1(box, box) pg_catalog.brin_inclusion_opcinfo(),
    function 2(box, box) pg_catalog.brin_inclusion_add_value(),
    function 3(box, box) pg_catalog.brin_inclusion_consistent(),
    function 4(box, box) pg_catalog.brin_inclusion_union(),
    function 11(box, box) pg_catalog.bound_box(),
    function 13(box, box) pg_catalog.box_contain();

alter operator family pg_catalog.box_inclusion_ops using brin owner to postgres;

create operator class pg_catalog.box_inclusion_ops default for type box using brin as storage box operator 1 pg_catalog.<<(box, box),
	operator 2 pg_catalog.&<(box, box),
	operator 3 pg_catalog.&&(box, box),
	operator 4 pg_catalog.&>(box, box),
	operator 5 pg_catalog.>>(box, box),
	operator 6 pg_catalog.~=(box, box),
	operator 7 pg_catalog.@>(box, box),
	operator 8 pg_catalog.<@(box, box),
	operator 9 pg_catalog.&<|(box, box),
	operator 10 pg_catalog.<<|(box, box),
	operator 11 pg_catalog.|>>(box, box),
	operator 12 pg_catalog.|&>(box, box),
	operator 7 pg_catalog.@>(box, point);

alter operator class pg_catalog.box_inclusion_ops using brin owner to postgres;

create operator family pg_catalog.macaddr8_minmax_ops using brin;

alter operator family pg_catalog.macaddr8_minmax_ops using brin add
    function 1(macaddr8, macaddr8) pg_catalog.brin_minmax_opcinfo(),
    function 2(macaddr8, macaddr8) pg_catalog.brin_minmax_add_value(),
    function 3(macaddr8, macaddr8) pg_catalog.brin_minmax_consistent(),
    function 4(macaddr8, macaddr8) pg_catalog.brin_minmax_union();

alter operator family pg_catalog.macaddr8_minmax_ops using brin owner to postgres;

create operator class pg_catalog.macaddr8_minmax_ops default for type macaddr8 using brin as storage macaddr8 operator 1 pg_catalog.<(macaddr8, macaddr8),
	operator 2 pg_catalog.<=(macaddr8, macaddr8),
	operator 3 pg_catalog.=(macaddr8, macaddr8),
	operator 4 pg_catalog.>=(macaddr8, macaddr8),
	operator 5 pg_catalog.>(macaddr8, macaddr8);

alter operator class pg_catalog.macaddr8_minmax_ops using brin owner to postgres;

create operator family pg_catalog.box_ops using spgist;

alter operator family pg_catalog.box_ops using spgist add
    function 1(box, box) pg_catalog.spg_box_quad_config(),
    function 2(box, box) pg_catalog.spg_box_quad_choose(),
    function 3(box, box) pg_catalog.spg_box_quad_picksplit(),
    function 4(box, box) pg_catalog.spg_box_quad_inner_consistent(),
    function 5(box, box) pg_catalog.spg_box_quad_leaf_consistent();

alter operator family pg_catalog.box_ops using spgist owner to postgres;

create operator class pg_catalog.box_ops default for type box using spgist as
    operator 1 pg_catalog.<<(box, box),
    operator 2 pg_catalog.&<(box, box),
    operator 3 pg_catalog.&&(box, box),
    operator 4 pg_catalog.&>(box, box),
    operator 5 pg_catalog.>>(box, box),
    operator 6 pg_catalog.~=(box, box),
    operator 7 pg_catalog.@>(box, box),
    operator 8 pg_catalog.<@(box, box),
    operator 9 pg_catalog.&<|(box, box),
    operator 10 pg_catalog.<<|(box, box),
    operator 11 pg_catalog.|>>(box, box),
    operator 12 pg_catalog.|&>(box, box);

alter operator class pg_catalog.box_ops using spgist owner to postgres;

create operator family pg_catalog.poly_ops using spgist;

alter operator family pg_catalog.poly_ops using spgist add
    function 1(polygon, polygon) pg_catalog.spg_bbox_quad_config(),
    function 2(polygon, polygon) pg_catalog.spg_box_quad_choose(),
    function 3(polygon, polygon) pg_catalog.spg_box_quad_picksplit(),
    function 4(polygon, polygon) pg_catalog.spg_box_quad_inner_consistent(),
    function 5(polygon, polygon) pg_catalog.spg_box_quad_leaf_consistent(),
    function 6(polygon, polygon) pg_catalog.spg_poly_quad_compress();

alter operator family pg_catalog.poly_ops using spgist owner to postgres;

create operator class pg_catalog.poly_ops default for type polygon using spgist as storage box operator 1 pg_catalog.<<(polygon, polygon),
	operator 2 pg_catalog.&<(polygon, polygon),
	operator 3 pg_catalog.&&(polygon, polygon),
	operator 4 pg_catalog.&>(polygon, polygon),
	operator 5 pg_catalog.>>(polygon, polygon),
	operator 6 pg_catalog.~=(polygon, polygon),
	operator 7 pg_catalog.@>(polygon, polygon),
	operator 8 pg_catalog.<@(polygon, polygon),
	operator 9 pg_catalog.&<|(polygon, polygon),
	operator 10 pg_catalog.<<|(polygon, polygon),
	operator 11 pg_catalog.|>>(polygon, polygon),
	operator 12 pg_catalog.|&>(polygon, polygon),
	operator 15 pg_catalog.<->(polygon, point) for order by float_ops;

alter operator class pg_catalog.poly_ops using spgist owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.bool_and() (
    sfunc = booland_statefunc,
    stype = boolean,
    combinefunc = booland_statefunc,
    parallel = safe,
    msfunc = bool_accum,
    minvfunc = bool_accum_inv,
    mstype = internal,
    msspace = 16,
    mfinalfunc = bool_alltrue,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.bool_and() is 'boolean-and aggregate';

alter aggregate pg_catalog.bool_and() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.bool_or() (
    sfunc = boolor_statefunc,
    stype = boolean,
    combinefunc = boolor_statefunc,
    parallel = safe,
    msfunc = bool_accum,
    minvfunc = bool_accum_inv,
    mstype = internal,
    msspace = 16,
    mfinalfunc = bool_anytrue,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.bool_or() is 'boolean-or aggregate';

alter aggregate pg_catalog.bool_or() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.every() (
    sfunc = booland_statefunc,
    stype = boolean,
    combinefunc = booland_statefunc,
    parallel = safe,
    msfunc = bool_accum,
    minvfunc = bool_accum_inv,
    mstype = internal,
    msspace = 16,
    mfinalfunc = bool_alltrue,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.every() is 'boolean-and aggregate';

alter aggregate pg_catalog.every() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max() (
    sfunc = array_larger,
    stype = anyarray,
    combinefunc = array_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max() is 'maximum value of all anyarray input values';

alter aggregate pg_catalog.max() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max() (
    sfunc = int8larger,
    stype = bigint,
    combinefunc = int8larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max() is 'maximum value of all bigint input values';

alter aggregate pg_catalog.max() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max() (
    sfunc = float4larger,
    stype = real,
    combinefunc = float4larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max() is 'maximum value of all float4 input values';

alter aggregate pg_catalog.max() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max() (
    sfunc = float8larger,
    stype = double precision,
    combinefunc = float8larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max() is 'maximum value of all float8 input values';

alter aggregate pg_catalog.max() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max() (
    sfunc = cashlarger,
    stype = money,
    combinefunc = cashlarger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max() is 'maximum value of all money input values';

alter aggregate pg_catalog.max() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max() (
    sfunc = text_larger,
    stype = text,
    combinefunc = text_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max() is 'maximum value of all text input values';

alter aggregate pg_catalog.max() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max(anyenum) (
    sfunc = enum_larger,
    stype = anyenum,
    combinefunc = enum_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(anyenum) is 'maximum value of all enum input values';

alter aggregate pg_catalog.max(anyenum) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max(char) (
    sfunc = bpchar_larger,
    stype = char,
    combinefunc = bpchar_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(char) is 'maximum value of all bpchar input values';

alter aggregate pg_catalog.max(char) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max(date) (
    sfunc = date_larger,
    stype = date,
    combinefunc = date_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(date) is 'maximum value of all date input values';

alter aggregate pg_catalog.max(date) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max(inet) (
    sfunc = network_larger,
    stype = inet,
    combinefunc = network_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(inet) is 'maximum value of all inet input values';

alter aggregate pg_catalog.max(inet) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max(integer) (
    sfunc = int4larger,
    stype = integer,
    combinefunc = int4larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(integer) is 'maximum value of all integer input values';

alter aggregate pg_catalog.max(integer) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max(interval) (
    sfunc = interval_larger,
    stype = interval,
    combinefunc = interval_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(interval) is 'maximum value of all interval input values';

alter aggregate pg_catalog.max(interval) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max(numeric) (
    sfunc = numeric_larger,
    stype = numeric,
    combinefunc = numeric_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(numeric) is 'maximum value of all numeric input values';

alter aggregate pg_catalog.max(numeric) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max(oid) (
    sfunc = oidlarger,
    stype = oid,
    combinefunc = oidlarger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(oid) is 'maximum value of all oid input values';

alter aggregate pg_catalog.max(oid) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max(smallint) (
    sfunc = int2larger,
    stype = smallint,
    combinefunc = int2larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(smallint) is 'maximum value of all smallint input values';

alter aggregate pg_catalog.max(smallint) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max(tid) (
    sfunc = tidlarger,
    stype = tid,
    combinefunc = tidlarger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(tid) is 'maximum value of all tid input values';

alter aggregate pg_catalog.max(tid) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max(time with time zone) (
    sfunc = timetz_larger,
    stype = time with time zone,
    combinefunc = timetz_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(time with time zone) is 'maximum value of all time with time zone input values';

alter aggregate pg_catalog.max(time with time zone) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max(time) (
    sfunc = time_larger,
    stype = time,
    combinefunc = time_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(time) is 'maximum value of all time input values';

alter aggregate pg_catalog.max(time) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max(timestamp with time zone) (
    sfunc = timestamptz_larger,
    stype = timestamp with time zone,
    combinefunc = timestamptz_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(timestamp with time zone) is 'maximum value of all timestamp with time zone input values';

alter aggregate pg_catalog.max(timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.max(timestamp) (
    sfunc = timestamp_larger,
    stype = timestamp,
    combinefunc = timestamp_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(timestamp) is 'maximum value of all timestamp input values';

alter aggregate pg_catalog.max(timestamp) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min() (
    sfunc = array_smaller,
    stype = anyarray,
    combinefunc = array_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min() is 'minimum value of all anyarray input values';

alter aggregate pg_catalog.min() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min() (
    sfunc = int8smaller,
    stype = bigint,
    combinefunc = int8smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min() is 'minimum value of all bigint input values';

alter aggregate pg_catalog.min() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min() (
    sfunc = float4smaller,
    stype = real,
    combinefunc = float4smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min() is 'minimum value of all float4 input values';

alter aggregate pg_catalog.min() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min() (
    sfunc = float8smaller,
    stype = double precision,
    combinefunc = float8smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min() is 'minimum value of all float8 input values';

alter aggregate pg_catalog.min() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min() (
    sfunc = cashsmaller,
    stype = money,
    combinefunc = cashsmaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min() is 'minimum value of all money input values';

alter aggregate pg_catalog.min() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min() (
    sfunc = text_smaller,
    stype = text,
    combinefunc = text_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min() is 'minimum value of all text values';

alter aggregate pg_catalog.min() owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min(anyenum) (
    sfunc = enum_smaller,
    stype = anyenum,
    combinefunc = enum_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(anyenum) is 'minimum value of all enum input values';

alter aggregate pg_catalog.min(anyenum) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min(char) (
    sfunc = bpchar_smaller,
    stype = char,
    combinefunc = bpchar_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(char) is 'minimum value of all bpchar input values';

alter aggregate pg_catalog.min(char) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min(date) (
    sfunc = date_smaller,
    stype = date,
    combinefunc = date_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(date) is 'minimum value of all date input values';

alter aggregate pg_catalog.min(date) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min(inet) (
    sfunc = network_smaller,
    stype = inet,
    combinefunc = network_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(inet) is 'minimum value of all inet input values';

alter aggregate pg_catalog.min(inet) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min(integer) (
    sfunc = int4smaller,
    stype = integer,
    combinefunc = int4smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(integer) is 'minimum value of all integer input values';

alter aggregate pg_catalog.min(integer) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min(interval) (
    sfunc = interval_smaller,
    stype = interval,
    combinefunc = interval_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(interval) is 'minimum value of all interval input values';

alter aggregate pg_catalog.min(interval) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min(numeric) (
    sfunc = numeric_smaller,
    stype = numeric,
    combinefunc = numeric_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(numeric) is 'minimum value of all numeric input values';

alter aggregate pg_catalog.min(numeric) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min(oid) (
    sfunc = oidsmaller,
    stype = oid,
    combinefunc = oidsmaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(oid) is 'minimum value of all oid input values';

alter aggregate pg_catalog.min(oid) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min(smallint) (
    sfunc = int2smaller,
    stype = smallint,
    combinefunc = int2smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(smallint) is 'minimum value of all smallint input values';

alter aggregate pg_catalog.min(smallint) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min(tid) (
    sfunc = tidsmaller,
    stype = tid,
    combinefunc = tidsmaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(tid) is 'minimum value of all tid input values';

alter aggregate pg_catalog.min(tid) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min(time with time zone) (
    sfunc = timetz_smaller,
    stype = time with time zone,
    combinefunc = timetz_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(time with time zone) is 'minimum value of all time with time zone input values';

alter aggregate pg_catalog.min(time with time zone) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min(time) (
    sfunc = time_smaller,
    stype = time,
    combinefunc = time_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(time) is 'minimum value of all time input values';

alter aggregate pg_catalog.min(time) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min(timestamp with time zone) (
    sfunc = timestamptz_smaller,
    stype = timestamp with time zone,
    combinefunc = timestamptz_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(timestamp with time zone) is 'minimum value of all timestamp with time zone input values';

alter aggregate pg_catalog.min(timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create aggregate pg_catalog.min(timestamp) (
    sfunc = timestamp_smaller,
    stype = timestamp,
    combinefunc = timestamp_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(timestamp) is 'minimum value of all timestamp input values';

alter aggregate pg_catalog.min(timestamp) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.!~ (procedure = pg_catalog.bpcharregexne, leftarg = char, rightarg = text, negator = pg_catalog.~, join = pg_catalog.regexnejoinsel, restrict = pg_catalog.regexnesel);

comment on operator pg_catalog.!~(char, text) is 'does not match regular expression, case-sensitive';

alter operator pg_catalog.!~(char, text) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.bpcharregexeq, leftarg = char, rightarg = text, negator = pg_catalog.!~, join = pg_catalog.regexeqjoinsel, restrict = pg_catalog.regexeqsel);

comment on operator pg_catalog.~(char, text) is 'matches regular expression, case-sensitive';

alter operator pg_catalog.~(char, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.!~ (procedure = pg_catalog.nameregexne, leftarg = name, rightarg = text, negator = pg_catalog.~, join = pg_catalog.regexnejoinsel, restrict = pg_catalog.regexnesel);

comment on operator pg_catalog.!~(name, text) is 'does not match regular expression, case-sensitive';

alter operator pg_catalog.!~(name, text) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.nameregexeq, leftarg = name, rightarg = text, negator = pg_catalog.!~, join = pg_catalog.regexeqjoinsel, restrict = pg_catalog.regexeqsel);

comment on operator pg_catalog.~(name, text) is 'matches regular expression, case-sensitive';

alter operator pg_catalog.~(name, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.!~ (procedure = pg_catalog.textregexne, leftarg = text, rightarg = text, negator = pg_catalog.~, join = pg_catalog.regexnejoinsel, restrict = pg_catalog.regexnesel);

comment on operator pg_catalog.!~(text, text) is 'does not match regular expression, case-sensitive';

alter operator pg_catalog.!~(text, text) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.textregexeq, leftarg = text, rightarg = text, negator = pg_catalog.!~, join = pg_catalog.regexeqjoinsel, restrict = pg_catalog.regexeqsel);

comment on operator pg_catalog.~(text, text) is 'matches regular expression, case-sensitive';

alter operator pg_catalog.~(text, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.!~* (procedure = pg_catalog.bpcharicregexne, leftarg = char, rightarg = text, negator = pg_catalog.~*, join = pg_catalog.icregexnejoinsel, restrict = pg_catalog.icregexnesel);

comment on operator pg_catalog.!~*(char, text) is 'does not match regular expression, case-insensitive';

alter operator pg_catalog.!~*(char, text) owner to postgres;

create operator pg_catalog.~* (procedure = pg_catalog.bpcharicregexeq, leftarg = char, rightarg = text, negator = pg_catalog.!~*, join = pg_catalog.icregexeqjoinsel, restrict = pg_catalog.icregexeqsel);

comment on operator pg_catalog.~*(char, text) is 'matches regular expression, case-insensitive';

alter operator pg_catalog.~*(char, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.!~* (procedure = pg_catalog.nameicregexne, leftarg = name, rightarg = text, negator = pg_catalog.~*, join = pg_catalog.icregexnejoinsel, restrict = pg_catalog.icregexnesel);

comment on operator pg_catalog.!~*(name, text) is 'does not match regular expression, case-insensitive';

alter operator pg_catalog.!~*(name, text) owner to postgres;

create operator pg_catalog.~* (procedure = pg_catalog.nameicregexeq, leftarg = name, rightarg = text, negator = pg_catalog.!~*, join = pg_catalog.icregexeqjoinsel, restrict = pg_catalog.icregexeqsel);

comment on operator pg_catalog.~*(name, text) is 'matches regular expression, case-insensitive';

alter operator pg_catalog.~*(name, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.!~* (procedure = pg_catalog.texticregexne, leftarg = text, rightarg = text, negator = pg_catalog.~*, join = pg_catalog.icregexnejoinsel, restrict = pg_catalog.icregexnesel);

comment on operator pg_catalog.!~*(text, text) is 'does not match regular expression, case-insensitive';

alter operator pg_catalog.!~*(text, text) owner to postgres;

create operator pg_catalog.~* (procedure = pg_catalog.texticregexeq, leftarg = text, rightarg = text, negator = pg_catalog.!~*, join = pg_catalog.icregexeqjoinsel, restrict = pg_catalog.icregexeqsel);

comment on operator pg_catalog.~*(text, text) is 'matches regular expression, case-insensitive';

alter operator pg_catalog.~*(text, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.!~~ (procedure = pg_catalog.byteanlike, leftarg = bytea, rightarg = bytea, negator = pg_catalog.~~, join = pg_catalog.nlikejoinsel, restrict = pg_catalog.nlikesel);

comment on operator pg_catalog.!~~(bytea, bytea) is 'does not match LIKE expression';

alter operator pg_catalog.!~~(bytea, bytea) owner to postgres;

create operator pg_catalog.~~ (procedure = pg_catalog.bytealike, leftarg = bytea, rightarg = bytea, negator = pg_catalog.!~~, join = pg_catalog.likejoinsel, restrict = pg_catalog.likesel);

comment on operator pg_catalog.~~(bytea, bytea) is 'matches LIKE expression';

alter operator pg_catalog.~~(bytea, bytea) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.!~~ (procedure = pg_catalog.bpcharnlike, leftarg = char, rightarg = text, negator = pg_catalog.~~, join = pg_catalog.nlikejoinsel, restrict = pg_catalog.nlikesel);

comment on operator pg_catalog.!~~(char, text) is 'does not match LIKE expression';

alter operator pg_catalog.!~~(char, text) owner to postgres;

create operator pg_catalog.~~ (procedure = pg_catalog.bpcharlike, leftarg = char, rightarg = text, negator = pg_catalog.!~~, join = pg_catalog.likejoinsel, restrict = pg_catalog.likesel);

comment on operator pg_catalog.~~(char, text) is 'matches LIKE expression';

alter operator pg_catalog.~~(char, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.!~~ (procedure = pg_catalog.namenlike, leftarg = name, rightarg = text, negator = pg_catalog.~~, join = pg_catalog.nlikejoinsel, restrict = pg_catalog.nlikesel);

comment on operator pg_catalog.!~~(name, text) is 'does not match LIKE expression';

alter operator pg_catalog.!~~(name, text) owner to postgres;

create operator pg_catalog.~~ (procedure = pg_catalog.namelike, leftarg = name, rightarg = text, negator = pg_catalog.!~~, join = pg_catalog.likejoinsel, restrict = pg_catalog.likesel);

comment on operator pg_catalog.~~(name, text) is 'matches LIKE expression';

alter operator pg_catalog.~~(name, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.!~~ (procedure = pg_catalog.textnlike, leftarg = text, rightarg = text, negator = pg_catalog.~~, join = pg_catalog.nlikejoinsel, restrict = pg_catalog.nlikesel);

comment on operator pg_catalog.!~~(text, text) is 'does not match LIKE expression';

alter operator pg_catalog.!~~(text, text) owner to postgres;

create operator pg_catalog.~~ (procedure = pg_catalog.textlike, leftarg = text, rightarg = text, negator = pg_catalog.!~~, join = pg_catalog.likejoinsel, restrict = pg_catalog.likesel);

comment on operator pg_catalog.~~(text, text) is 'matches LIKE expression';

alter operator pg_catalog.~~(text, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.!~~* (procedure = pg_catalog.bpcharicnlike, leftarg = char, rightarg = text, negator = pg_catalog.~~*, join = pg_catalog.icnlikejoinsel, restrict = pg_catalog.icnlikesel);

comment on operator pg_catalog.!~~*(char, text) is 'does not match LIKE expression, case-insensitive';

alter operator pg_catalog.!~~*(char, text) owner to postgres;

create operator pg_catalog.~~* (procedure = pg_catalog.bpchariclike, leftarg = char, rightarg = text, negator = pg_catalog.!~~*, join = pg_catalog.iclikejoinsel, restrict = pg_catalog.iclikesel);

comment on operator pg_catalog.~~*(char, text) is 'matches LIKE expression, case-insensitive';

alter operator pg_catalog.~~*(char, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.!~~* (procedure = pg_catalog.nameicnlike, leftarg = name, rightarg = text, negator = pg_catalog.~~*, join = pg_catalog.icnlikejoinsel, restrict = pg_catalog.icnlikesel);

comment on operator pg_catalog.!~~*(name, text) is 'does not match LIKE expression, case-insensitive';

alter operator pg_catalog.!~~*(name, text) owner to postgres;

create operator pg_catalog.~~* (procedure = pg_catalog.nameiclike, leftarg = name, rightarg = text, negator = pg_catalog.!~~*, join = pg_catalog.iclikejoinsel, restrict = pg_catalog.iclikesel);

comment on operator pg_catalog.~~*(name, text) is 'matches LIKE expression, case-insensitive';

alter operator pg_catalog.~~*(name, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.!~~* (procedure = pg_catalog.texticnlike, leftarg = text, rightarg = text, negator = pg_catalog.~~*, join = pg_catalog.icnlikejoinsel, restrict = pg_catalog.icnlikesel);

comment on operator pg_catalog.!~~*(text, text) is 'does not match LIKE expression, case-insensitive';

alter operator pg_catalog.!~~*(text, text) owner to postgres;

create operator pg_catalog.~~* (procedure = pg_catalog.texticlike, leftarg = text, rightarg = text, negator = pg_catalog.!~~*, join = pg_catalog.iclikejoinsel, restrict = pg_catalog.iclikesel);

comment on operator pg_catalog.~~*(text, text) is 'matches LIKE expression, case-insensitive';

alter operator pg_catalog.~~*(text, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.int84mul, leftarg = bigint, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, integer) is 'multiply';

alter operator pg_catalog.*(bigint, integer) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.int48mul, leftarg = integer, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, bigint) is 'multiply';

alter operator pg_catalog.*(integer, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.int8_mul_cash, leftarg = bigint, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, money) is 'multiply';

alter operator pg_catalog.*(bigint, money) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_int8, leftarg = money, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, bigint) is 'multiply';

alter operator pg_catalog.*(money, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.int82mul, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, smallint) is 'multiply';

alter operator pg_catalog.*(bigint, smallint) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.int28mul, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, bigint) is 'multiply';

alter operator pg_catalog.*(smallint, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.mul_d_interval, leftarg = double precision, rightarg = interval, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, interval) is 'multiply';

alter operator pg_catalog.*(double precision, interval) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.interval_mul, leftarg = interval, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(interval, double precision) is 'multiply';

alter operator pg_catalog.*(interval, double precision) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.flt8_mul_cash, leftarg = double precision, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, money) is 'multiply';

alter operator pg_catalog.*(double precision, money) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_flt8, leftarg = money, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, double precision) is 'multiply';

alter operator pg_catalog.*(money, double precision) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.float84mul, leftarg = double precision, rightarg = real, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, real) is 'multiply';

alter operator pg_catalog.*(double precision, real) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.float48mul, leftarg = real, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(real, double precision) is 'multiply';

alter operator pg_catalog.*(real, double precision) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.int4_mul_cash, leftarg = integer, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, money) is 'multiply';

alter operator pg_catalog.*(integer, money) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_int4, leftarg = money, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, integer) is 'multiply';

alter operator pg_catalog.*(money, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.int42mul, leftarg = integer, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, smallint) is 'multiply';

alter operator pg_catalog.*(integer, smallint) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.int24mul, leftarg = smallint, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, integer) is 'multiply';

alter operator pg_catalog.*(smallint, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_flt4, leftarg = money, rightarg = real, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, real) is 'multiply';

alter operator pg_catalog.*(money, real) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.flt4_mul_cash, leftarg = real, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(real, money) is 'multiply';

alter operator pg_catalog.*(real, money) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_int2, leftarg = money, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, smallint) is 'multiply';

alter operator pg_catalog.*(money, smallint) owner to postgres;

create operator pg_catalog.* (procedure = pg_catalog.int2_mul_cash, leftarg = smallint, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, money) is 'multiply';

alter operator pg_catalog.*(smallint, money) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.*<> (procedure = pg_catalog.record_image_ne, leftarg = record, rightarg = record, commutator = pg_catalog.*<>, negator = pg_catalog.*=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.*<>(record, record) is 'not identical';

alter operator pg_catalog.*<>(record, record) owner to postgres;

create operator pg_catalog.*= (procedure = pg_catalog.record_image_eq, leftarg = record, rightarg = record, commutator = pg_catalog.*=, negator = pg_catalog.*<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.*=(record, record) is 'identical';

alter operator pg_catalog.*=(record, record) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.int8pl_inet, leftarg = bigint, rightarg = inet, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, inet) is 'add';

alter operator pg_catalog.+(bigint, inet) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.inetpl, leftarg = inet, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(inet, bigint) is 'add';

alter operator pg_catalog.+(inet, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.int84pl, leftarg = bigint, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, integer) is 'add';

alter operator pg_catalog.+(bigint, integer) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.int48pl, leftarg = integer, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, bigint) is 'add';

alter operator pg_catalog.+(integer, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.int82pl, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, smallint) is 'add';

alter operator pg_catalog.+(bigint, smallint) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.int28pl, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(smallint, bigint) is 'add';

alter operator pg_catalog.+(smallint, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.date_pli, leftarg = date, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, integer) is 'add';

alter operator pg_catalog.+(date, integer) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.integer_pl_date, leftarg = integer, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, date) is 'add';

alter operator pg_catalog.+(integer, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.date_pl_interval, leftarg = date, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, interval) is 'add';

alter operator pg_catalog.+(date, interval) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_date, leftarg = interval, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, date) is 'add';

alter operator pg_catalog.+(interval, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.datetimetz_pl, leftarg = date, rightarg = time with time zone, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, time with time zone) is 'convert date and time with time zone to timestamp with time zone';

alter operator pg_catalog.+(date, time with time zone) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.timetzdate_pl, leftarg = time with time zone, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time with time zone, date) is 'convert time with time zone and date to timestamp with time zone';

alter operator pg_catalog.+(time with time zone, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.datetime_pl, leftarg = date, rightarg = time, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, time) is 'convert date and time to timestamp';

alter operator pg_catalog.+(date, time) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.timedate_pl, leftarg = time, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time, date) is 'convert time and date to timestamp';

alter operator pg_catalog.+(time, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.float84pl, leftarg = double precision, rightarg = real, commutator = pg_catalog.+);

comment on operator pg_catalog.+(double precision, real) is 'add';

alter operator pg_catalog.+(double precision, real) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.float48pl, leftarg = real, rightarg = double precision, commutator = pg_catalog.+);

comment on operator pg_catalog.+(real, double precision) is 'add';

alter operator pg_catalog.+(real, double precision) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.int42pl, leftarg = integer, rightarg = smallint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, smallint) is 'add';

alter operator pg_catalog.+(integer, smallint) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.int24pl, leftarg = smallint, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(smallint, integer) is 'add';

alter operator pg_catalog.+(smallint, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_timetz, leftarg = interval, rightarg = time with time zone, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, time with time zone) is 'add';

alter operator pg_catalog.+(interval, time with time zone) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.timetz_pl_interval, leftarg = time with time zone, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time with time zone, interval) is 'add';

alter operator pg_catalog.+(time with time zone, interval) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_time, leftarg = interval, rightarg = time, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, time) is 'add';

alter operator pg_catalog.+(interval, time) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.time_pl_interval, leftarg = time, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time, interval) is 'add';

alter operator pg_catalog.+(time, interval) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_timestamptz, leftarg = interval, rightarg = timestamp with time zone, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, timestamp with time zone) is 'add';

alter operator pg_catalog.+(interval, timestamp with time zone) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.timestamptz_pl_interval, leftarg = timestamp with time zone, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(timestamp with time zone, interval) is 'add';

alter operator pg_catalog.+(timestamp with time zone, interval) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_timestamp, leftarg = interval, rightarg = timestamp, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, timestamp) is 'add';

alter operator pg_catalog.+(interval, timestamp) owner to postgres;

create operator pg_catalog.+ (procedure = pg_catalog.timestamp_pl_interval, leftarg = timestamp, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(timestamp, interval) is 'add';

alter operator pg_catalog.+(timestamp, interval) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.path_n_lt, leftarg = path, rightarg = path, commutator = pg_catalog.>);

comment on operator pg_catalog.<(path, path) is 'less than';

alter operator pg_catalog.<(path, path) owner to postgres;

create operator pg_catalog.> (procedure = pg_catalog.path_n_gt, leftarg = path, rightarg = path, commutator = pg_catalog.<);

comment on operator pg_catalog.>(path, path) is 'greater than';

alter operator pg_catalog.>(path, path) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<-> (procedure = pg_catalog.dist_cpoint, leftarg = circle, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(circle, point) is 'distance between';

alter operator pg_catalog.<->(circle, point) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.dist_pc, leftarg = point, rightarg = circle, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, circle) is 'distance between';

alter operator pg_catalog.<->(point, circle) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<-> (procedure = pg_catalog.dist_ppoly, leftarg = point, rightarg = polygon, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, polygon) is 'distance between';

alter operator pg_catalog.<->(point, polygon) owner to postgres;

create operator pg_catalog.<-> (procedure = pg_catalog.dist_polyp, leftarg = polygon, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(polygon, point) is 'distance between';

alter operator pg_catalog.<->(polygon, point) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<< (procedure = pg_catalog.range_before, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.>>, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<<(anyrange, anyrange) is 'is left of';

alter operator pg_catalog.<<(anyrange, anyrange) owner to postgres;

create operator pg_catalog.>> (procedure = pg_catalog.range_after, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<<, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.>>(anyrange, anyrange) is 'is right of';

alter operator pg_catalog.>>(anyrange, anyrange) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<< (procedure = pg_catalog.network_sub, leftarg = inet, rightarg = inet, commutator = pg_catalog.>>, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.<<(inet, inet) is 'is subnet';

alter operator pg_catalog.<<(inet, inet) owner to postgres;

create operator pg_catalog.>> (procedure = pg_catalog.network_sup, leftarg = inet, rightarg = inet, commutator = pg_catalog.<<, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.>>(inet, inet) is 'is supernet';

alter operator pg_catalog.>>(inet, inet) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<<= (procedure = pg_catalog.network_subeq, leftarg = inet, rightarg = inet, commutator = pg_catalog.>>=, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.<<=(inet, inet) is 'is subnet or equal';

alter operator pg_catalog.<<=(inet, inet) owner to postgres;

create operator pg_catalog.>>= (procedure = pg_catalog.network_supeq, leftarg = inet, rightarg = inet, commutator = pg_catalog.<<=, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.>>=(inet, inet) is 'is supernet or equal';

alter operator pg_catalog.>>=(inet, inet) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.path_n_le, leftarg = path, rightarg = path, commutator = pg_catalog.>=);

comment on operator pg_catalog.<=(path, path) is 'less than or equal';

alter operator pg_catalog.<=(path, path) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.path_n_ge, leftarg = path, rightarg = path, commutator = pg_catalog.<=);

comment on operator pg_catalog.>=(path, path) is 'greater than or equal';

alter operator pg_catalog.>=(path, path) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.charne, leftarg = "char", rightarg = "char", commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>("char", "char") is 'not equal';

alter operator pg_catalog.<>("char", "char") owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.chareq, leftarg = "char", rightarg = "char", commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=("char", "char") is 'equal';

alter operator pg_catalog.=("char", "char") owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.array_ne, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(anyarray, anyarray) is 'not equal';

alter operator pg_catalog.<>(anyarray, anyarray) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.array_eq, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(anyarray, anyarray) is 'equal';

alter operator pg_catalog.=(anyarray, anyarray) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.enum_ne, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(anyenum, anyenum) is 'not equal';

alter operator pg_catalog.<>(anyenum, anyenum) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.enum_eq, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(anyenum, anyenum) is 'equal';

alter operator pg_catalog.=(anyenum, anyenum) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.range_ne, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(anyrange, anyrange) is 'not equal';

alter operator pg_catalog.<>(anyrange, anyrange) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.range_eq, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(anyrange, anyrange) is 'equal';

alter operator pg_catalog.=(anyrange, anyrange) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int8ne, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bigint, bigint) is 'not equal';

alter operator pg_catalog.<>(bigint, bigint) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.int8eq, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(bigint, bigint) is 'equal';

alter operator pg_catalog.=(bigint, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.varbitne, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bit varying, bit varying) is 'not equal';

alter operator pg_catalog.<>(bit varying, bit varying) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.varbiteq, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(bit varying, bit varying) is 'equal';

alter operator pg_catalog.=(bit varying, bit varying) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.bitne, leftarg = bit, rightarg = bit, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bit, bit) is 'not equal';

alter operator pg_catalog.<>(bit, bit) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.biteq, leftarg = bit, rightarg = bit, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(bit, bit) is 'equal';

alter operator pg_catalog.=(bit, bit) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.boolne, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(boolean, boolean) is 'not equal';

alter operator pg_catalog.<>(boolean, boolean) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.booleq, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(boolean, boolean) is 'equal';

alter operator pg_catalog.=(boolean, boolean) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.byteane, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bytea, bytea) is 'not equal';

alter operator pg_catalog.<>(bytea, bytea) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.byteaeq, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(bytea, bytea) is 'equal';

alter operator pg_catalog.=(bytea, bytea) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.bpcharne, leftarg = char, rightarg = char, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(char, char) is 'not equal';

alter operator pg_catalog.<>(char, char) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.bpchareq, leftarg = char, rightarg = char, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(char, char) is 'equal';

alter operator pg_catalog.=(char, char) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.circle_ne, leftarg = circle, rightarg = circle, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(circle, circle) is 'not equal by area';

alter operator pg_catalog.<>(circle, circle) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.circle_eq, leftarg = circle, rightarg = circle, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(circle, circle) is 'equal by area';

alter operator pg_catalog.=(circle, circle) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.date_ne, leftarg = date, rightarg = date, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(date, date) is 'not equal';

alter operator pg_catalog.<>(date, date) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.date_eq, leftarg = date, rightarg = date, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(date, date) is 'equal';

alter operator pg_catalog.=(date, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.float8ne, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(double precision, double precision) is 'not equal';

alter operator pg_catalog.<>(double precision, double precision) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.float8eq, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(double precision, double precision) is 'equal';

alter operator pg_catalog.=(double precision, double precision) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.network_ne, leftarg = inet, rightarg = inet, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(inet, inet) is 'not equal';

alter operator pg_catalog.<>(inet, inet) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.network_eq, leftarg = inet, rightarg = inet, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(inet, inet) is 'equal';

alter operator pg_catalog.=(inet, inet) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int4ne, leftarg = integer, rightarg = integer, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(integer, integer) is 'not equal';

alter operator pg_catalog.<>(integer, integer) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.int4eq, leftarg = integer, rightarg = integer, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(integer, integer) is 'equal';

alter operator pg_catalog.=(integer, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.interval_ne, leftarg = interval, rightarg = interval, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(interval, interval) is 'not equal';

alter operator pg_catalog.<>(interval, interval) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.interval_eq, leftarg = interval, rightarg = interval, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(interval, interval) is 'equal';

alter operator pg_catalog.=(interval, interval) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.jsonb_ne, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(jsonb, jsonb) is 'not equal';

alter operator pg_catalog.<>(jsonb, jsonb) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.jsonb_eq, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(jsonb, jsonb) is 'equal';

alter operator pg_catalog.=(jsonb, jsonb) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.lseg_ne, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(lseg, lseg) is 'not equal';

alter operator pg_catalog.<>(lseg, lseg) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.lseg_eq, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(lseg, lseg) is 'equal';

alter operator pg_catalog.=(lseg, lseg) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.macaddr_ne, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(macaddr, macaddr) is 'not equal';

alter operator pg_catalog.<>(macaddr, macaddr) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.macaddr_eq, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(macaddr, macaddr) is 'equal';

alter operator pg_catalog.=(macaddr, macaddr) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.macaddr8_ne, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(macaddr8, macaddr8) is 'not equal';

alter operator pg_catalog.<>(macaddr8, macaddr8) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.macaddr8_eq, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(macaddr8, macaddr8) is 'equal';

alter operator pg_catalog.=(macaddr8, macaddr8) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.cash_ne, leftarg = money, rightarg = money, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(money, money) is 'not equal';

alter operator pg_catalog.<>(money, money) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.cash_eq, leftarg = money, rightarg = money, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(money, money) is 'equal';

alter operator pg_catalog.=(money, money) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.namene, leftarg = name, rightarg = name, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(name, name) is 'not equal';

alter operator pg_catalog.<>(name, name) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.nameeq, leftarg = name, rightarg = name, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(name, name) is 'equal';

alter operator pg_catalog.=(name, name) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.numeric_ne, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(numeric, numeric) is 'not equal';

alter operator pg_catalog.<>(numeric, numeric) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.numeric_eq, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(numeric, numeric) is 'equal';

alter operator pg_catalog.=(numeric, numeric) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.oidne, leftarg = oid, rightarg = oid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(oid, oid) is 'not equal';

alter operator pg_catalog.<>(oid, oid) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.oideq, leftarg = oid, rightarg = oid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(oid, oid) is 'equal';

alter operator pg_catalog.=(oid, oid) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.oidvectorne, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(oidvector, oidvector) is 'not equal';

alter operator pg_catalog.<>(oidvector, oidvector) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.oidvectoreq, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(oidvector, oidvector) is 'equal';

alter operator pg_catalog.=(oidvector, oidvector) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.pg_lsn_ne, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(pg_lsn, pg_lsn) is 'not equal';

alter operator pg_catalog.<>(pg_lsn, pg_lsn) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.pg_lsn_eq, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(pg_lsn, pg_lsn) is 'equal';

alter operator pg_catalog.=(pg_lsn, pg_lsn) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.point_ne, leftarg = point, rightarg = point, commutator = pg_catalog.<>, negator = pg_catalog.~=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(point, point) is 'not equal';

alter operator pg_catalog.<>(point, point) owner to postgres;

create operator pg_catalog.~= (procedure = pg_catalog.point_eq, leftarg = point, rightarg = point, commutator = pg_catalog.~=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.~=(point, point) is 'same as';

alter operator pg_catalog.~=(point, point) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.float4ne, leftarg = real, rightarg = real, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(real, real) is 'not equal';

alter operator pg_catalog.<>(real, real) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.float4eq, leftarg = real, rightarg = real, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(real, real) is 'equal';

alter operator pg_catalog.=(real, real) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.record_ne, leftarg = record, rightarg = record, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(record, record) is 'not equal';

alter operator pg_catalog.<>(record, record) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.record_eq, leftarg = record, rightarg = record, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(record, record) is 'equal';

alter operator pg_catalog.=(record, record) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int2ne, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(smallint, smallint) is 'not equal';

alter operator pg_catalog.<>(smallint, smallint) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.int2eq, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(smallint, smallint) is 'equal';

alter operator pg_catalog.=(smallint, smallint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.textne, leftarg = text, rightarg = text, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(text, text) is 'not equal';

alter operator pg_catalog.<>(text, text) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.texteq, leftarg = text, rightarg = text, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(text, text) is 'equal';

alter operator pg_catalog.=(text, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.tidne, leftarg = tid, rightarg = tid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(tid, tid) is 'not equal';

alter operator pg_catalog.<>(tid, tid) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.tideq, leftarg = tid, rightarg = tid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(tid, tid) is 'equal';

alter operator pg_catalog.=(tid, tid) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.timetz_ne, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(time with time zone, time with time zone) is 'not equal';

alter operator pg_catalog.<>(time with time zone, time with time zone) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.timetz_eq, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(time with time zone, time with time zone) is 'equal';

alter operator pg_catalog.=(time with time zone, time with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.time_ne, leftarg = time, rightarg = time, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(time, time) is 'not equal';

alter operator pg_catalog.<>(time, time) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.time_eq, leftarg = time, rightarg = time, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(time, time) is 'equal';

alter operator pg_catalog.=(time, time) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.timestamptz_ne, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp with time zone, timestamp with time zone) is 'not equal';

alter operator pg_catalog.<>(timestamp with time zone, timestamp with time zone) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.timestamptz_eq, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(timestamp with time zone, timestamp with time zone) is 'equal';

alter operator pg_catalog.=(timestamp with time zone, timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.timestamp_ne, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp, timestamp) is 'not equal';

alter operator pg_catalog.<>(timestamp, timestamp) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.timestamp_eq, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(timestamp, timestamp) is 'equal';

alter operator pg_catalog.=(timestamp, timestamp) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.tsquery_ne, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(tsquery, tsquery) is 'not equal';

alter operator pg_catalog.<>(tsquery, tsquery) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.tsquery_eq, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(tsquery, tsquery) is 'equal';

alter operator pg_catalog.=(tsquery, tsquery) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.tsvector_ne, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(tsvector, tsvector) is 'not equal';

alter operator pg_catalog.<>(tsvector, tsvector) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.tsvector_eq, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(tsvector, tsvector) is 'equal';

alter operator pg_catalog.=(tsvector, tsvector) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.uuid_ne, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(uuid, uuid) is 'not equal';

alter operator pg_catalog.<>(uuid, uuid) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.uuid_eq, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(uuid, uuid) is 'equal';

alter operator pg_catalog.=(uuid, uuid) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.xidneqint4, leftarg = xid, rightarg = integer, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(xid, integer) is 'not equal';

alter operator pg_catalog.<>(xid, integer) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.xideqint4, leftarg = xid, rightarg = integer, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(xid, integer) is 'equal';

alter operator pg_catalog.=(xid, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.xidneq, leftarg = xid, rightarg = xid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(xid, xid) is 'not equal';

alter operator pg_catalog.<>(xid, xid) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.xideq, leftarg = xid, rightarg = xid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes);

comment on operator pg_catalog.=(xid, xid) is 'equal';

alter operator pg_catalog.=(xid, xid) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.arraycontained, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.@>, join = pg_catalog.arraycontjoinsel, restrict = pg_catalog.arraycontsel);

comment on operator pg_catalog.<@(anyarray, anyarray) is 'is contained by';

alter operator pg_catalog.<@(anyarray, anyarray) owner to postgres;

create operator pg_catalog.@> (procedure = pg_catalog.arraycontains, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<@, join = pg_catalog.arraycontjoinsel, restrict = pg_catalog.arraycontsel);

comment on operator pg_catalog.@>(anyarray, anyarray) is 'contains';

alter operator pg_catalog.@>(anyarray, anyarray) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.elem_contained_by_range, leftarg = anyelement, rightarg = anyrange, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<@(anyelement, anyrange) is 'is contained by';

alter operator pg_catalog.<@(anyelement, anyrange) owner to postgres;

create operator pg_catalog.@> (procedure = pg_catalog.range_contains_elem, leftarg = anyrange, rightarg = anyelement, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.@>(anyrange, anyelement) is 'contains';

alter operator pg_catalog.@>(anyrange, anyelement) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.range_contained_by, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<@(anyrange, anyrange) is 'is contained by';

alter operator pg_catalog.<@(anyrange, anyrange) owner to postgres;

create operator pg_catalog.@> (procedure = pg_catalog.range_contains, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.@>(anyrange, anyrange) is 'contains';

alter operator pg_catalog.@>(anyrange, anyrange) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.box_contained, leftarg = box, rightarg = box, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(box, box) is 'is contained by';

alter operator pg_catalog.<@(box, box) owner to postgres;

create operator pg_catalog.@> (procedure = pg_catalog.box_contain, leftarg = box, rightarg = box, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(box, box) is 'contains';

alter operator pg_catalog.@>(box, box) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.circle_contained, leftarg = circle, rightarg = circle, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(circle, circle) is 'is contained by';

alter operator pg_catalog.<@(circle, circle) owner to postgres;

create operator pg_catalog.@> (procedure = pg_catalog.circle_contain, leftarg = circle, rightarg = circle, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(circle, circle) is 'contains';

alter operator pg_catalog.@>(circle, circle) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.jsonb_contained, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(jsonb, jsonb) is 'is contained by';

alter operator pg_catalog.<@(jsonb, jsonb) owner to postgres;

create operator pg_catalog.@> (procedure = pg_catalog.jsonb_contains, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(jsonb, jsonb) is 'contains';

alter operator pg_catalog.@>(jsonb, jsonb) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.on_pb, leftarg = point, rightarg = box, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(point, box) is 'point inside box';

alter operator pg_catalog.<@(point, box) owner to postgres;

create operator pg_catalog.@> (procedure = pg_catalog.box_contain_pt, leftarg = box, rightarg = point, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(box, point) is 'contains';

alter operator pg_catalog.@>(box, point) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.pt_contained_circle, leftarg = point, rightarg = circle, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(point, circle) is 'is contained by';

alter operator pg_catalog.<@(point, circle) owner to postgres;

create operator pg_catalog.@> (procedure = pg_catalog.circle_contain_pt, leftarg = circle, rightarg = point, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(circle, point) is 'contains';

alter operator pg_catalog.@>(circle, point) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.on_ppath, leftarg = point, rightarg = path, commutator = pg_catalog.@>);

comment on operator pg_catalog.<@(point, path) is 'point within closed path, or point on open path';

alter operator pg_catalog.<@(point, path) owner to postgres;

create operator pg_catalog.@> (procedure = pg_catalog.path_contain_pt, leftarg = path, rightarg = point, commutator = pg_catalog.<@);

comment on operator pg_catalog.@>(path, point) is 'contains';

alter operator pg_catalog.@>(path, point) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.pt_contained_poly, leftarg = point, rightarg = polygon, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(point, polygon) is 'is contained by';

alter operator pg_catalog.<@(point, polygon) owner to postgres;

create operator pg_catalog.@> (procedure = pg_catalog.poly_contain_pt, leftarg = polygon, rightarg = point, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(polygon, point) is 'contains';

alter operator pg_catalog.@>(polygon, point) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.poly_contained, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(polygon, polygon) is 'is contained by';

alter operator pg_catalog.<@(polygon, polygon) owner to postgres;

create operator pg_catalog.@> (procedure = pg_catalog.poly_contain, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(polygon, polygon) is 'contains';

alter operator pg_catalog.@>(polygon, polygon) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.tsq_mcontained, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(tsquery, tsquery) is 'is contained by';

alter operator pg_catalog.<@(tsquery, tsquery) owner to postgres;

create operator pg_catalog.@> (procedure = pg_catalog.tsq_mcontains, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(tsquery, tsquery) is 'contains';

alter operator pg_catalog.@>(tsquery, tsquery) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.@ (procedure = pg_catalog.box_contained, leftarg = box, rightarg = box, commutator = pg_catalog.~, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@(box, box) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(box, box) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.box_contain, leftarg = box, rightarg = box, commutator = pg_catalog.@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.~(box, box) is 'deprecated, use @> instead';

alter operator pg_catalog.~(box, box) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.@ (procedure = pg_catalog.circle_contained, leftarg = circle, rightarg = circle, commutator = pg_catalog.~, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@(circle, circle) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(circle, circle) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.circle_contain, leftarg = circle, rightarg = circle, commutator = pg_catalog.@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.~(circle, circle) is 'deprecated, use @> instead';

alter operator pg_catalog.~(circle, circle) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.@ (procedure = pg_catalog.pt_contained_circle, leftarg = point, rightarg = circle, commutator = pg_catalog.~);

comment on operator pg_catalog.@(point, circle) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, circle) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.circle_contain_pt, leftarg = circle, rightarg = point, commutator = pg_catalog.@);

comment on operator pg_catalog.~(circle, point) is 'deprecated, use @> instead';

alter operator pg_catalog.~(circle, point) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.@ (procedure = pg_catalog.on_ppath, leftarg = point, rightarg = path, commutator = pg_catalog.~);

comment on operator pg_catalog.@(point, path) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, path) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.path_contain_pt, leftarg = path, rightarg = point, commutator = pg_catalog.@);

comment on operator pg_catalog.~(path, point) is 'deprecated, use @> instead';

alter operator pg_catalog.~(path, point) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.@ (procedure = pg_catalog.pt_contained_poly, leftarg = point, rightarg = polygon, commutator = pg_catalog.~);

comment on operator pg_catalog.@(point, polygon) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, polygon) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.poly_contain_pt, leftarg = polygon, rightarg = point, commutator = pg_catalog.@);

comment on operator pg_catalog.~(polygon, point) is 'deprecated, use @> instead';

alter operator pg_catalog.~(polygon, point) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.@ (procedure = pg_catalog.poly_contained, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.~, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@(polygon, polygon) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(polygon, polygon) owner to postgres;

create operator pg_catalog.~ (procedure = pg_catalog.poly_contain, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.~(polygon, polygon) is 'deprecated, use @> instead';

alter operator pg_catalog.~(polygon, polygon) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.@@ (procedure = pg_catalog.ts_match_qv, leftarg = tsquery, rightarg = tsvector, commutator = pg_catalog.@@, join = pg_catalog.tsmatchjoinsel, restrict = pg_catalog.tsmatchsel);

comment on operator pg_catalog.@@(tsquery, tsvector) is 'text search match';

alter operator pg_catalog.@@(tsquery, tsvector) owner to postgres;

create operator pg_catalog.@@ (procedure = pg_catalog.ts_match_vq, leftarg = tsvector, rightarg = tsquery, commutator = pg_catalog.@@, join = pg_catalog.tsmatchjoinsel, restrict = pg_catalog.tsmatchsel);

comment on operator pg_catalog.@@(tsvector, tsquery) is 'text search match';

alter operator pg_catalog.@@(tsvector, tsquery) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.@@@ (procedure = pg_catalog.ts_match_qv, leftarg = tsquery, rightarg = tsvector, commutator = pg_catalog.@@@, join = pg_catalog.tsmatchjoinsel, restrict = pg_catalog.tsmatchsel);

comment on operator pg_catalog.@@@(tsquery, tsvector) is 'deprecated, use @@ instead';

alter operator pg_catalog.@@@(tsquery, tsvector) owner to postgres;

create operator pg_catalog.@@@ (procedure = pg_catalog.ts_match_vq, leftarg = tsvector, rightarg = tsquery, commutator = pg_catalog.@@@, join = pg_catalog.tsmatchjoinsel, restrict = pg_catalog.tsmatchsel);

comment on operator pg_catalog.@@@(tsvector, tsquery) is 'deprecated, use @@ instead';

alter operator pg_catalog.@@@(tsvector, tsquery) owner to postgres;

-- Cyclic dependencies found

create function pg_catalog.age(timestamp with time zone) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(timestamp with time zone) is 'date difference preserving months and years';

alter function pg_catalog.age(timestamp with time zone) owner to postgres;

create function pg_catalog.age(timestamp with time zone) returns interval
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$select pg_catalog.age(cast(current_date as timestamp with time zone), $1)$$;

comment on function pg_catalog.age(timestamp with time zone) is 'date difference from today preserving months and years';

alter function pg_catalog.age(timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create function pg_catalog.has_column_privilege(smallint)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(smallint) is 'user privilege on column by user oid, rel oid, col attnum';

alter function pg_catalog.has_column_privilege(smallint) owner to postgres;

create function pg_catalog.has_column_privilege(smallint)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(smallint) is 'user privilege on column by user oid, rel name, col attnum';

alter function pg_catalog.has_column_privilege(smallint) owner to postgres;

-- Cyclic dependencies found

create function pg_catalog.has_column_privilege(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(text) is 'user privilege on column by user oid, rel oid, col name';

alter function pg_catalog.has_column_privilege(text) owner to postgres;

create function pg_catalog.has_column_privilege(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(text) is 'user privilege on column by user oid, rel name, col name';

alter function pg_catalog.has_column_privilege(text) owner to postgres;

-- Cyclic dependencies found

create function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, interval) returns boolean
    stable
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, timestamp with time zone) returns boolean
    stable
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create function pg_catalog.pg_get_viewdef(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(oid) is 'select statement of a view';

alter function pg_catalog.pg_get_viewdef(oid) owner to postgres;

create function pg_catalog.pg_get_viewdef(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(oid) is 'select statement of a view with pretty-print option';

alter function pg_catalog.pg_get_viewdef(oid) owner to postgres;

-- Cyclic dependencies found

create function pg_catalog.pg_get_viewdef(text)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(text) is 'select statement of a view';

alter function pg_catalog.pg_get_viewdef(text) owner to postgres;

create function pg_catalog.pg_get_viewdef(text)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(text) is 'select statement of a view with pretty-print option';

alter function pg_catalog.pg_get_viewdef(text) owner to postgres;

-- Cyclic dependencies found

create function pg_catalog.substring(text, text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
    begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(text) is 'extract text matching SQL99 regular expression';

alter function pg_catalog.substring(text) owner to postgres;

create function pg_catalog.substring(text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(text) is 'extract portion of string';

alter function pg_catalog.substring(text) owner to postgres;

-- Cyclic dependencies found

create function pg_catalog.ts_headline(json) returns json
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(json) is 'generate headline from json';

alter function pg_catalog.ts_headline(json) owner to postgres;

create function pg_catalog.ts_headline(json) returns json
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(json) is 'generate headline from json';

alter function pg_catalog.ts_headline(json) owner to postgres;

-- Cyclic dependencies found

create function pg_catalog.ts_headline(json, text) returns json
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(json, text) is 'generate headline from json';

alter function pg_catalog.ts_headline(json, text) owner to postgres;

create function pg_catalog.ts_headline(json, text) returns json
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(json, text) is 'generate headline from json';

alter function pg_catalog.ts_headline(json, text) owner to postgres;

-- Cyclic dependencies found

create function pg_catalog.ts_headline(jsonb) returns jsonb
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(jsonb) is 'generate headline from jsonb';

alter function pg_catalog.ts_headline(jsonb) owner to postgres;

create function pg_catalog.ts_headline(jsonb) returns jsonb
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(jsonb) is 'generate headline from jsonb';

alter function pg_catalog.ts_headline(jsonb) owner to postgres;

-- Cyclic dependencies found

create function pg_catalog.ts_headline(jsonb, text) returns jsonb
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(jsonb, text) is 'generate headline from jsonb';

alter function pg_catalog.ts_headline(jsonb, text) owner to postgres;

create function pg_catalog.ts_headline(jsonb, text) returns jsonb
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(jsonb, text) is 'generate headline from jsonb';

alter function pg_catalog.ts_headline(jsonb, text) owner to postgres;

-- Cyclic dependencies found

create function pg_catalog.ts_headline(text)
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(text) is 'generate headline';

alter function pg_catalog.ts_headline(text) owner to postgres;

create function pg_catalog.ts_headline(text)
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(text) is 'generate headline';

alter function pg_catalog.ts_headline(text) owner to postgres;

-- Cyclic dependencies found

create function pg_catalog.ts_rank(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank(integer) is 'relevance';

alter function pg_catalog.ts_rank(integer) owner to postgres;

create function pg_catalog.ts_rank(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank(integer) is 'relevance';

alter function pg_catalog.ts_rank(integer) owner to postgres;

-- Cyclic dependencies found

create function pg_catalog.ts_rank_cd(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd(integer) is 'relevance';

alter function pg_catalog.ts_rank_cd(integer) owner to postgres;

create function pg_catalog.ts_rank_cd(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd(integer) is 'relevance';

alter function pg_catalog.ts_rank_cd(integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.*< (procedure = pg_catalog.record_image_lt, leftarg = record, rightarg = record, commutator = pg_catalog.*>, negator = pg_catalog.*>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.*<(record, record) is 'less than';

alter operator pg_catalog.*<(record, record) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.*> (procedure = pg_catalog.record_image_gt, leftarg = record, rightarg = record, commutator = pg_catalog.*<, negator = pg_catalog.*<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.*>(record, record) is 'greater than';

alter operator pg_catalog.*>(record, record) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.*<= (procedure = pg_catalog.record_image_le, leftarg = record, rightarg = record, commutator = pg_catalog.*>=, negator = pg_catalog.*>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.*<=(record, record) is 'less than or equal';

alter operator pg_catalog.*<=(record, record) owner to postgres;

create operator pg_catalog.*>= (procedure = pg_catalog.record_image_ge, leftarg = record, rightarg = record, commutator = pg_catalog.*<=, negator = pg_catalog.*<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.*>=(record, record) is 'greater than or equal';

alter operator pg_catalog.*>=(record, record) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.charlt, leftarg = "char", rightarg = "char", commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<("char", "char") is 'less than';

alter operator pg_catalog.<("char", "char") owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.chargt, leftarg = "char", rightarg = "char", commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>("char", "char") is 'greater than';

alter operator pg_catalog.>("char", "char") owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.charle, leftarg = "char", rightarg = "char", commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=("char", "char") is 'less than or equal';

alter operator pg_catalog.<=("char", "char") owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.charge, leftarg = "char", rightarg = "char", commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=("char", "char") is 'greater than or equal';

alter operator pg_catalog.>=("char", "char") owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.array_lt, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(anyarray, anyarray) is 'less than';

alter operator pg_catalog.<(anyarray, anyarray) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.array_gt, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(anyarray, anyarray) is 'greater than';

alter operator pg_catalog.>(anyarray, anyarray) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.array_le, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(anyarray, anyarray) is 'less than or equal';

alter operator pg_catalog.<=(anyarray, anyarray) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.array_ge, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(anyarray, anyarray) is 'greater than or equal';

alter operator pg_catalog.>=(anyarray, anyarray) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.enum_lt, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(anyenum, anyenum) is 'less than';

alter operator pg_catalog.<(anyenum, anyenum) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.enum_gt, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(anyenum, anyenum) is 'greater than';

alter operator pg_catalog.>(anyenum, anyenum) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.enum_le, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(anyenum, anyenum) is 'less than or equal';

alter operator pg_catalog.<=(anyenum, anyenum) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.enum_ge, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(anyenum, anyenum) is 'greater than or equal';

alter operator pg_catalog.>=(anyenum, anyenum) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.range_lt, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<(anyrange, anyrange) is 'less than';

alter operator pg_catalog.<(anyrange, anyrange) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.range_gt, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.>(anyrange, anyrange) is 'greater than';

alter operator pg_catalog.>(anyrange, anyrange) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.range_le, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<=(anyrange, anyrange) is 'less than or equal';

alter operator pg_catalog.<=(anyrange, anyrange) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.range_ge, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.>=(anyrange, anyrange) is 'greater than or equal';

alter operator pg_catalog.>=(anyrange, anyrange) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int8lt, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bigint, bigint) is 'less than';

alter operator pg_catalog.<(bigint, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int8gt, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bigint, bigint) is 'greater than';

alter operator pg_catalog.>(bigint, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int8le, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bigint, bigint) is 'less than or equal';

alter operator pg_catalog.<=(bigint, bigint) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.int8ge, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bigint, bigint) is 'greater than or equal';

alter operator pg_catalog.>=(bigint, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int84lt, leftarg = bigint, rightarg = integer, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bigint, integer) is 'less than';

alter operator pg_catalog.<(bigint, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int48gt, leftarg = integer, rightarg = bigint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(integer, bigint) is 'greater than';

alter operator pg_catalog.>(integer, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int48le, leftarg = integer, rightarg = bigint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(integer, bigint) is 'less than or equal';

alter operator pg_catalog.<=(integer, bigint) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.int84ge, leftarg = bigint, rightarg = integer, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bigint, integer) is 'greater than or equal';

alter operator pg_catalog.>=(bigint, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int82lt, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bigint, smallint) is 'less than';

alter operator pg_catalog.<(bigint, smallint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int28gt, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(smallint, bigint) is 'greater than';

alter operator pg_catalog.>(smallint, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int28le, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(smallint, bigint) is 'less than or equal';

alter operator pg_catalog.<=(smallint, bigint) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.int82ge, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bigint, smallint) is 'greater than or equal';

alter operator pg_catalog.>=(bigint, smallint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.varbitlt, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bit varying, bit varying) is 'less than';

alter operator pg_catalog.<(bit varying, bit varying) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.varbitgt, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bit varying, bit varying) is 'greater than';

alter operator pg_catalog.>(bit varying, bit varying) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.varbitle, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bit varying, bit varying) is 'less than or equal';

alter operator pg_catalog.<=(bit varying, bit varying) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.varbitge, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bit varying, bit varying) is 'greater than or equal';

alter operator pg_catalog.>=(bit varying, bit varying) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.bitlt, leftarg = bit, rightarg = bit, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bit, bit) is 'less than';

alter operator pg_catalog.<(bit, bit) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.bitgt, leftarg = bit, rightarg = bit, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bit, bit) is 'greater than';

alter operator pg_catalog.>(bit, bit) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.bitle, leftarg = bit, rightarg = bit, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bit, bit) is 'less than or equal';

alter operator pg_catalog.<=(bit, bit) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.bitge, leftarg = bit, rightarg = bit, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bit, bit) is 'greater than or equal';

alter operator pg_catalog.>=(bit, bit) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.boollt, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(boolean, boolean) is 'less than';

alter operator pg_catalog.<(boolean, boolean) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.boolgt, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(boolean, boolean) is 'greater than';

alter operator pg_catalog.>(boolean, boolean) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.boolle, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(boolean, boolean) is 'less than or equal';

alter operator pg_catalog.<=(boolean, boolean) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.boolge, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(boolean, boolean) is 'greater than or equal';

alter operator pg_catalog.>=(boolean, boolean) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.box_lt, leftarg = box, rightarg = box, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.<(box, box) is 'less than by area';

alter operator pg_catalog.<(box, box) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.box_gt, leftarg = box, rightarg = box, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.>(box, box) is 'greater than by area';

alter operator pg_catalog.>(box, box) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.box_le, leftarg = box, rightarg = box, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.<=(box, box) is 'less than or equal by area';

alter operator pg_catalog.<=(box, box) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.box_ge, leftarg = box, rightarg = box, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.>=(box, box) is 'greater than or equal by area';

alter operator pg_catalog.>=(box, box) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.bytealt, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bytea, bytea) is 'less than';

alter operator pg_catalog.<(bytea, bytea) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.byteagt, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bytea, bytea) is 'greater than';

alter operator pg_catalog.>(bytea, bytea) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.byteale, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bytea, bytea) is 'less than or equal';

alter operator pg_catalog.<=(bytea, bytea) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.byteage, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bytea, bytea) is 'greater than or equal';

alter operator pg_catalog.>=(bytea, bytea) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.bpcharlt, leftarg = char, rightarg = char, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(char, char) is 'less than';

alter operator pg_catalog.<(char, char) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.bpchargt, leftarg = char, rightarg = char, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(char, char) is 'greater than';

alter operator pg_catalog.>(char, char) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.bpcharle, leftarg = char, rightarg = char, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(char, char) is 'less than or equal';

alter operator pg_catalog.<=(char, char) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.bpcharge, leftarg = char, rightarg = char, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(char, char) is 'greater than or equal';

alter operator pg_catalog.>=(char, char) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.circle_lt, leftarg = circle, rightarg = circle, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.<(circle, circle) is 'less than by area';

alter operator pg_catalog.<(circle, circle) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.circle_gt, leftarg = circle, rightarg = circle, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.>(circle, circle) is 'greater than by area';

alter operator pg_catalog.>(circle, circle) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.circle_le, leftarg = circle, rightarg = circle, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.<=(circle, circle) is 'less than or equal by area';

alter operator pg_catalog.<=(circle, circle) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.circle_ge, leftarg = circle, rightarg = circle, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.>=(circle, circle) is 'greater than or equal by area';

alter operator pg_catalog.>=(circle, circle) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.date_lt, leftarg = date, rightarg = date, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(date, date) is 'less than';

alter operator pg_catalog.<(date, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.date_gt, leftarg = date, rightarg = date, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(date, date) is 'greater than';

alter operator pg_catalog.>(date, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.date_le, leftarg = date, rightarg = date, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(date, date) is 'less than or equal';

alter operator pg_catalog.<=(date, date) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.date_ge, leftarg = date, rightarg = date, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(date, date) is 'greater than or equal';

alter operator pg_catalog.>=(date, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.date_lt_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(date, timestamp with time zone) is 'less than';

alter operator pg_catalog.<(date, timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.timestamptz_gt_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp with time zone, date) is 'greater than';

alter operator pg_catalog.>(timestamp with time zone, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.timestamptz_le_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp with time zone, date) is 'less than or equal';

alter operator pg_catalog.<=(timestamp with time zone, date) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.date_ge_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(date, timestamp with time zone) is 'greater than or equal';

alter operator pg_catalog.>=(date, timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.date_lt_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(date, timestamp) is 'less than';

alter operator pg_catalog.<(date, timestamp) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.timestamp_gt_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp, date) is 'greater than';

alter operator pg_catalog.>(timestamp, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.timestamp_le_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp, date) is 'less than or equal';

alter operator pg_catalog.<=(timestamp, date) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.date_ge_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(date, timestamp) is 'greater than or equal';

alter operator pg_catalog.>=(date, timestamp) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.float8lt, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(double precision, double precision) is 'less than';

alter operator pg_catalog.<(double precision, double precision) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.float8gt, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(double precision, double precision) is 'greater than';

alter operator pg_catalog.>(double precision, double precision) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.float8le, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(double precision, double precision) is 'less than or equal';

alter operator pg_catalog.<=(double precision, double precision) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.float8ge, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(double precision, double precision) is 'greater than or equal';

alter operator pg_catalog.>=(double precision, double precision) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.float84lt, leftarg = double precision, rightarg = real, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(double precision, real) is 'less than';

alter operator pg_catalog.<(double precision, real) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.float48gt, leftarg = real, rightarg = double precision, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(real, double precision) is 'greater than';

alter operator pg_catalog.>(real, double precision) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.float48le, leftarg = real, rightarg = double precision, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(real, double precision) is 'less than or equal';

alter operator pg_catalog.<=(real, double precision) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.float84ge, leftarg = double precision, rightarg = real, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(double precision, real) is 'greater than or equal';

alter operator pg_catalog.>=(double precision, real) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.network_lt, leftarg = inet, rightarg = inet, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(inet, inet) is 'less than';

alter operator pg_catalog.<(inet, inet) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.network_gt, leftarg = inet, rightarg = inet, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(inet, inet) is 'greater than';

alter operator pg_catalog.>(inet, inet) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.network_le, leftarg = inet, rightarg = inet, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(inet, inet) is 'less than or equal';

alter operator pg_catalog.<=(inet, inet) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.network_ge, leftarg = inet, rightarg = inet, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(inet, inet) is 'greater than or equal';

alter operator pg_catalog.>=(inet, inet) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int48lt, leftarg = integer, rightarg = bigint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(integer, bigint) is 'less than';

alter operator pg_catalog.<(integer, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int84gt, leftarg = bigint, rightarg = integer, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bigint, integer) is 'greater than';

alter operator pg_catalog.>(bigint, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int84le, leftarg = bigint, rightarg = integer, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bigint, integer) is 'less than or equal';

alter operator pg_catalog.<=(bigint, integer) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.int48ge, leftarg = integer, rightarg = bigint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(integer, bigint) is 'greater than or equal';

alter operator pg_catalog.>=(integer, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int4lt, leftarg = integer, rightarg = integer, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(integer, integer) is 'less than';

alter operator pg_catalog.<(integer, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int4gt, leftarg = integer, rightarg = integer, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(integer, integer) is 'greater than';

alter operator pg_catalog.>(integer, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int4le, leftarg = integer, rightarg = integer, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(integer, integer) is 'less than or equal';

alter operator pg_catalog.<=(integer, integer) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.int4ge, leftarg = integer, rightarg = integer, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(integer, integer) is 'greater than or equal';

alter operator pg_catalog.>=(integer, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int42lt, leftarg = integer, rightarg = smallint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(integer, smallint) is 'less than';

alter operator pg_catalog.<(integer, smallint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int24gt, leftarg = smallint, rightarg = integer, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(smallint, integer) is 'greater than';

alter operator pg_catalog.>(smallint, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int24le, leftarg = smallint, rightarg = integer, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(smallint, integer) is 'less than or equal';

alter operator pg_catalog.<=(smallint, integer) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.int42ge, leftarg = integer, rightarg = smallint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(integer, smallint) is 'greater than or equal';

alter operator pg_catalog.>=(integer, smallint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.interval_lt, leftarg = interval, rightarg = interval, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(interval, interval) is 'less than';

alter operator pg_catalog.<(interval, interval) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.interval_gt, leftarg = interval, rightarg = interval, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(interval, interval) is 'greater than';

alter operator pg_catalog.>(interval, interval) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.interval_le, leftarg = interval, rightarg = interval, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(interval, interval) is 'less than or equal';

alter operator pg_catalog.<=(interval, interval) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.interval_ge, leftarg = interval, rightarg = interval, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(interval, interval) is 'greater than or equal';

alter operator pg_catalog.>=(interval, interval) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.jsonb_lt, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(jsonb, jsonb) is 'less than';

alter operator pg_catalog.<(jsonb, jsonb) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.jsonb_gt, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(jsonb, jsonb) is 'greater than';

alter operator pg_catalog.>(jsonb, jsonb) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.jsonb_le, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(jsonb, jsonb) is 'less than or equal';

alter operator pg_catalog.<=(jsonb, jsonb) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.jsonb_ge, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(jsonb, jsonb) is 'greater than or equal';

alter operator pg_catalog.>=(jsonb, jsonb) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.lseg_lt, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.>, negator = pg_catalog.>=);

comment on operator pg_catalog.<(lseg, lseg) is 'less than by length';

alter operator pg_catalog.<(lseg, lseg) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.lseg_gt, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<, negator = pg_catalog.<=);

comment on operator pg_catalog.>(lseg, lseg) is 'greater than by length';

alter operator pg_catalog.>(lseg, lseg) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.lseg_le, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.>=, negator = pg_catalog.>);

comment on operator pg_catalog.<=(lseg, lseg) is 'less than or equal by length';

alter operator pg_catalog.<=(lseg, lseg) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.lseg_ge, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<=, negator = pg_catalog.<);

comment on operator pg_catalog.>=(lseg, lseg) is 'greater than or equal by length';

alter operator pg_catalog.>=(lseg, lseg) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.macaddr_lt, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(macaddr, macaddr) is 'less than';

alter operator pg_catalog.<(macaddr, macaddr) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.macaddr_gt, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(macaddr, macaddr) is 'greater than';

alter operator pg_catalog.>(macaddr, macaddr) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.macaddr_le, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(macaddr, macaddr) is 'less than or equal';

alter operator pg_catalog.<=(macaddr, macaddr) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.macaddr_ge, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(macaddr, macaddr) is 'greater than or equal';

alter operator pg_catalog.>=(macaddr, macaddr) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.macaddr8_lt, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(macaddr8, macaddr8) is 'less than';

alter operator pg_catalog.<(macaddr8, macaddr8) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.macaddr8_gt, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(macaddr8, macaddr8) is 'greater than';

alter operator pg_catalog.>(macaddr8, macaddr8) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.macaddr8_le, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(macaddr8, macaddr8) is 'less than or equal';

alter operator pg_catalog.<=(macaddr8, macaddr8) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.macaddr8_ge, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(macaddr8, macaddr8) is 'greater than or equal';

alter operator pg_catalog.>=(macaddr8, macaddr8) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.cash_lt, leftarg = money, rightarg = money, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(money, money) is 'less than';

alter operator pg_catalog.<(money, money) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.cash_gt, leftarg = money, rightarg = money, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(money, money) is 'greater than';

alter operator pg_catalog.>(money, money) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.cash_le, leftarg = money, rightarg = money, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(money, money) is 'less than or equal';

alter operator pg_catalog.<=(money, money) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.cash_ge, leftarg = money, rightarg = money, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(money, money) is 'greater than or equal';

alter operator pg_catalog.>=(money, money) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.namelt, leftarg = name, rightarg = name, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(name, name) is 'less than';

alter operator pg_catalog.<(name, name) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.namegt, leftarg = name, rightarg = name, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(name, name) is 'greater than';

alter operator pg_catalog.>(name, name) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.namele, leftarg = name, rightarg = name, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(name, name) is 'less than or equal';

alter operator pg_catalog.<=(name, name) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.namege, leftarg = name, rightarg = name, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(name, name) is 'greater than or equal';

alter operator pg_catalog.>=(name, name) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.namelttext, leftarg = name, rightarg = text, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(name, text) is 'less than';

alter operator pg_catalog.<(name, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.textgtname, leftarg = text, rightarg = name, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(text, name) is 'greater than';

alter operator pg_catalog.>(text, name) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.textlename, leftarg = text, rightarg = name, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(text, name) is 'less than or equal';

alter operator pg_catalog.<=(text, name) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.namegetext, leftarg = name, rightarg = text, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(name, text) is 'greater than or equal';

alter operator pg_catalog.>=(name, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.numeric_lt, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(numeric, numeric) is 'less than';

alter operator pg_catalog.<(numeric, numeric) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.numeric_gt, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(numeric, numeric) is 'greater than';

alter operator pg_catalog.>(numeric, numeric) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.numeric_le, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(numeric, numeric) is 'less than or equal';

alter operator pg_catalog.<=(numeric, numeric) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.numeric_ge, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(numeric, numeric) is 'greater than or equal';

alter operator pg_catalog.>=(numeric, numeric) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.oidlt, leftarg = oid, rightarg = oid, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(oid, oid) is 'less than';

alter operator pg_catalog.<(oid, oid) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.oidgt, leftarg = oid, rightarg = oid, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(oid, oid) is 'greater than';

alter operator pg_catalog.>(oid, oid) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.oidle, leftarg = oid, rightarg = oid, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(oid, oid) is 'less than or equal';

alter operator pg_catalog.<=(oid, oid) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.oidge, leftarg = oid, rightarg = oid, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(oid, oid) is 'greater than or equal';

alter operator pg_catalog.>=(oid, oid) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.oidvectorlt, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(oidvector, oidvector) is 'less than';

alter operator pg_catalog.<(oidvector, oidvector) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.oidvectorgt, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(oidvector, oidvector) is 'greater than';

alter operator pg_catalog.>(oidvector, oidvector) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.oidvectorle, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(oidvector, oidvector) is 'less than or equal';

alter operator pg_catalog.<=(oidvector, oidvector) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.oidvectorge, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(oidvector, oidvector) is 'greater than or equal';

alter operator pg_catalog.>=(oidvector, oidvector) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.pg_lsn_lt, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(pg_lsn, pg_lsn) is 'less than';

alter operator pg_catalog.<(pg_lsn, pg_lsn) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.pg_lsn_gt, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(pg_lsn, pg_lsn) is 'greater than';

alter operator pg_catalog.>(pg_lsn, pg_lsn) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.pg_lsn_le, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(pg_lsn, pg_lsn) is 'less than or equal';

alter operator pg_catalog.<=(pg_lsn, pg_lsn) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.pg_lsn_ge, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(pg_lsn, pg_lsn) is 'greater than or equal';

alter operator pg_catalog.>=(pg_lsn, pg_lsn) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.float48lt, leftarg = real, rightarg = double precision, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(real, double precision) is 'less than';

alter operator pg_catalog.<(real, double precision) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.float84gt, leftarg = double precision, rightarg = real, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(double precision, real) is 'greater than';

alter operator pg_catalog.>(double precision, real) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.float84le, leftarg = double precision, rightarg = real, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(double precision, real) is 'less than or equal';

alter operator pg_catalog.<=(double precision, real) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.float48ge, leftarg = real, rightarg = double precision, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(real, double precision) is 'greater than or equal';

alter operator pg_catalog.>=(real, double precision) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.float4lt, leftarg = real, rightarg = real, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(real, real) is 'less than';

alter operator pg_catalog.<(real, real) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.float4gt, leftarg = real, rightarg = real, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(real, real) is 'greater than';

alter operator pg_catalog.>(real, real) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.float4le, leftarg = real, rightarg = real, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(real, real) is 'less than or equal';

alter operator pg_catalog.<=(real, real) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.float4ge, leftarg = real, rightarg = real, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(real, real) is 'greater than or equal';

alter operator pg_catalog.>=(real, real) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.record_lt, leftarg = record, rightarg = record, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(record, record) is 'less than';

alter operator pg_catalog.<(record, record) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.record_gt, leftarg = record, rightarg = record, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(record, record) is 'greater than';

alter operator pg_catalog.>(record, record) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.record_le, leftarg = record, rightarg = record, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(record, record) is 'less than or equal';

alter operator pg_catalog.<=(record, record) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.record_ge, leftarg = record, rightarg = record, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(record, record) is 'greater than or equal';

alter operator pg_catalog.>=(record, record) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int28lt, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(smallint, bigint) is 'less than';

alter operator pg_catalog.<(smallint, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int82gt, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bigint, smallint) is 'greater than';

alter operator pg_catalog.>(bigint, smallint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int82le, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bigint, smallint) is 'less than or equal';

alter operator pg_catalog.<=(bigint, smallint) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.int28ge, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(smallint, bigint) is 'greater than or equal';

alter operator pg_catalog.>=(smallint, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int24lt, leftarg = smallint, rightarg = integer, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(smallint, integer) is 'less than';

alter operator pg_catalog.<(smallint, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int42gt, leftarg = integer, rightarg = smallint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(integer, smallint) is 'greater than';

alter operator pg_catalog.>(integer, smallint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int42le, leftarg = integer, rightarg = smallint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(integer, smallint) is 'less than or equal';

alter operator pg_catalog.<=(integer, smallint) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.int24ge, leftarg = smallint, rightarg = integer, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(smallint, integer) is 'greater than or equal';

alter operator pg_catalog.>=(smallint, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int2lt, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(smallint, smallint) is 'less than';

alter operator pg_catalog.<(smallint, smallint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int2gt, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(smallint, smallint) is 'greater than';

alter operator pg_catalog.>(smallint, smallint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int2le, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(smallint, smallint) is 'less than or equal';

alter operator pg_catalog.<=(smallint, smallint) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.int2ge, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(smallint, smallint) is 'greater than or equal';

alter operator pg_catalog.>=(smallint, smallint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.textltname, leftarg = text, rightarg = name, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(text, name) is 'less than';

alter operator pg_catalog.<(text, name) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.namegttext, leftarg = name, rightarg = text, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(name, text) is 'greater than';

alter operator pg_catalog.>(name, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.nameletext, leftarg = name, rightarg = text, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(name, text) is 'less than or equal';

alter operator pg_catalog.<=(name, text) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.textgename, leftarg = text, rightarg = name, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(text, name) is 'greater than or equal';

alter operator pg_catalog.>=(text, name) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.text_lt, leftarg = text, rightarg = text, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(text, text) is 'less than';

alter operator pg_catalog.<(text, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.text_gt, leftarg = text, rightarg = text, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(text, text) is 'greater than';

alter operator pg_catalog.>(text, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.text_le, leftarg = text, rightarg = text, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(text, text) is 'less than or equal';

alter operator pg_catalog.<=(text, text) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.text_ge, leftarg = text, rightarg = text, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(text, text) is 'greater than or equal';

alter operator pg_catalog.>=(text, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.tidlt, leftarg = tid, rightarg = tid, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(tid, tid) is 'less than';

alter operator pg_catalog.<(tid, tid) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.tidgt, leftarg = tid, rightarg = tid, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(tid, tid) is 'greater than';

alter operator pg_catalog.>(tid, tid) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.tidle, leftarg = tid, rightarg = tid, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(tid, tid) is 'less than or equal';

alter operator pg_catalog.<=(tid, tid) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.tidge, leftarg = tid, rightarg = tid, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(tid, tid) is 'greater than or equal';

alter operator pg_catalog.>=(tid, tid) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timetz_lt, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(time with time zone, time with time zone) is 'less than';

alter operator pg_catalog.<(time with time zone, time with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.timetz_gt, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(time with time zone, time with time zone) is 'greater than';

alter operator pg_catalog.>(time with time zone, time with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.timetz_le, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(time with time zone, time with time zone) is 'less than or equal';

alter operator pg_catalog.<=(time with time zone, time with time zone) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.timetz_ge, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(time with time zone, time with time zone) is 'greater than or equal';

alter operator pg_catalog.>=(time with time zone, time with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.time_lt, leftarg = time, rightarg = time, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(time, time) is 'less than';

alter operator pg_catalog.<(time, time) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.time_gt, leftarg = time, rightarg = time, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(time, time) is 'greater than';

alter operator pg_catalog.>(time, time) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.time_le, leftarg = time, rightarg = time, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(time, time) is 'less than or equal';

alter operator pg_catalog.<=(time, time) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.time_ge, leftarg = time, rightarg = time, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(time, time) is 'greater than or equal';

alter operator pg_catalog.>=(time, time) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamptz_lt_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp with time zone, date) is 'less than';

alter operator pg_catalog.<(timestamp with time zone, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.date_gt_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(date, timestamp with time zone) is 'greater than';

alter operator pg_catalog.>(date, timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.date_le_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(date, timestamp with time zone) is 'less than or equal';

alter operator pg_catalog.<=(date, timestamp with time zone) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.timestamptz_ge_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp with time zone, date) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp with time zone, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamptz_lt, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp with time zone, timestamp with time zone) is 'less than';

alter operator pg_catalog.<(timestamp with time zone, timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.timestamptz_gt, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp with time zone, timestamp with time zone) is 'greater than';

alter operator pg_catalog.>(timestamp with time zone, timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.timestamptz_le, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp with time zone, timestamp with time zone) is 'less than or equal';

alter operator pg_catalog.<=(timestamp with time zone, timestamp with time zone) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.timestamptz_ge, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp with time zone, timestamp with time zone) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp with time zone, timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamptz_lt_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp with time zone, timestamp) is 'less than';

alter operator pg_catalog.<(timestamp with time zone, timestamp) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.timestamp_gt_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp, timestamp with time zone) is 'greater than';

alter operator pg_catalog.>(timestamp, timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.timestamp_le_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp, timestamp with time zone) is 'less than or equal';

alter operator pg_catalog.<=(timestamp, timestamp with time zone) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.timestamptz_ge_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp with time zone, timestamp) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp with time zone, timestamp) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamp_lt_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp, date) is 'less than';

alter operator pg_catalog.<(timestamp, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.date_gt_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(date, timestamp) is 'greater than';

alter operator pg_catalog.>(date, timestamp) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.date_le_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(date, timestamp) is 'less than or equal';

alter operator pg_catalog.<=(date, timestamp) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.timestamp_ge_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp, date) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamp_lt_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp, timestamp with time zone) is 'less than';

alter operator pg_catalog.<(timestamp, timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.timestamptz_gt_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp with time zone, timestamp) is 'greater than';

alter operator pg_catalog.>(timestamp with time zone, timestamp) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.timestamptz_le_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp with time zone, timestamp) is 'less than or equal';

alter operator pg_catalog.<=(timestamp with time zone, timestamp) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.timestamp_ge_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp, timestamp with time zone) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp, timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamp_lt, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp, timestamp) is 'less than';

alter operator pg_catalog.<(timestamp, timestamp) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.timestamp_gt, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp, timestamp) is 'greater than';

alter operator pg_catalog.>(timestamp, timestamp) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.timestamp_le, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp, timestamp) is 'less than or equal';

alter operator pg_catalog.<=(timestamp, timestamp) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.timestamp_ge, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp, timestamp) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp, timestamp) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.tsquery_lt, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(tsquery, tsquery) is 'less than';

alter operator pg_catalog.<(tsquery, tsquery) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.tsquery_gt, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(tsquery, tsquery) is 'greater than';

alter operator pg_catalog.>(tsquery, tsquery) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.tsquery_le, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(tsquery, tsquery) is 'less than or equal';

alter operator pg_catalog.<=(tsquery, tsquery) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.tsquery_ge, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(tsquery, tsquery) is 'greater than or equal';

alter operator pg_catalog.>=(tsquery, tsquery) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.tsvector_lt, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(tsvector, tsvector) is 'less than';

alter operator pg_catalog.<(tsvector, tsvector) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.tsvector_gt, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(tsvector, tsvector) is 'greater than';

alter operator pg_catalog.>(tsvector, tsvector) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.tsvector_le, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(tsvector, tsvector) is 'less than or equal';

alter operator pg_catalog.<=(tsvector, tsvector) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.tsvector_ge, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(tsvector, tsvector) is 'greater than or equal';

alter operator pg_catalog.>=(tsvector, tsvector) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.uuid_lt, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(uuid, uuid) is 'less than';

alter operator pg_catalog.<(uuid, uuid) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.uuid_gt, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(uuid, uuid) is 'greater than';

alter operator pg_catalog.>(uuid, uuid) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.uuid_le, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(uuid, uuid) is 'less than or equal';

alter operator pg_catalog.<=(uuid, uuid) owner to postgres;

create operator pg_catalog.>= (procedure = pg_catalog.uuid_ge, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(uuid, uuid) is 'greater than or equal';

alter operator pg_catalog.>=(uuid, uuid) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int84ne, leftarg = bigint, rightarg = integer, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bigint, integer) is 'not equal';

alter operator pg_catalog.<>(bigint, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int48ne, leftarg = integer, rightarg = bigint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(integer, bigint) is 'not equal';

alter operator pg_catalog.<>(integer, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.int84eq, leftarg = bigint, rightarg = integer, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(bigint, integer) is 'equal';

alter operator pg_catalog.=(bigint, integer) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.int48eq, leftarg = integer, rightarg = bigint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(integer, bigint) is 'equal';

alter operator pg_catalog.=(integer, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int82ne, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bigint, smallint) is 'not equal';

alter operator pg_catalog.<>(bigint, smallint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int28ne, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(smallint, bigint) is 'not equal';

alter operator pg_catalog.<>(smallint, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.int82eq, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(bigint, smallint) is 'equal';

alter operator pg_catalog.=(bigint, smallint) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.int28eq, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(smallint, bigint) is 'equal';

alter operator pg_catalog.=(smallint, bigint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.date_ne_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(date, timestamp with time zone) is 'not equal';

alter operator pg_catalog.<>(date, timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.timestamptz_ne_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp with time zone, date) is 'not equal';

alter operator pg_catalog.<>(timestamp with time zone, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.date_eq_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(date, timestamp with time zone) is 'equal';

alter operator pg_catalog.=(date, timestamp with time zone) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.timestamptz_eq_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(timestamp with time zone, date) is 'equal';

alter operator pg_catalog.=(timestamp with time zone, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.date_ne_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(date, timestamp) is 'not equal';

alter operator pg_catalog.<>(date, timestamp) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.timestamp_ne_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp, date) is 'not equal';

alter operator pg_catalog.<>(timestamp, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.date_eq_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(date, timestamp) is 'equal';

alter operator pg_catalog.=(date, timestamp) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.timestamp_eq_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(timestamp, date) is 'equal';

alter operator pg_catalog.=(timestamp, date) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.float84ne, leftarg = double precision, rightarg = real, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(double precision, real) is 'not equal';

alter operator pg_catalog.<>(double precision, real) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.float48ne, leftarg = real, rightarg = double precision, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(real, double precision) is 'not equal';

alter operator pg_catalog.<>(real, double precision) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.float84eq, leftarg = double precision, rightarg = real, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(double precision, real) is 'equal';

alter operator pg_catalog.=(double precision, real) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.float48eq, leftarg = real, rightarg = double precision, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(real, double precision) is 'equal';

alter operator pg_catalog.=(real, double precision) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int42ne, leftarg = integer, rightarg = smallint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(integer, smallint) is 'not equal';

alter operator pg_catalog.<>(integer, smallint) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int24ne, leftarg = smallint, rightarg = integer, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(smallint, integer) is 'not equal';

alter operator pg_catalog.<>(smallint, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.int42eq, leftarg = integer, rightarg = smallint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(integer, smallint) is 'equal';

alter operator pg_catalog.=(integer, smallint) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.int24eq, leftarg = smallint, rightarg = integer, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(smallint, integer) is 'equal';

alter operator pg_catalog.=(smallint, integer) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.namenetext, leftarg = name, rightarg = text, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(name, text) is 'not equal';

alter operator pg_catalog.<>(name, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.textnename, leftarg = text, rightarg = name, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(text, name) is 'not equal';

alter operator pg_catalog.<>(text, name) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.nameeqtext, leftarg = name, rightarg = text, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(name, text) is 'equal';

alter operator pg_catalog.=(name, text) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.texteqname, leftarg = text, rightarg = name, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(text, name) is 'equal';

alter operator pg_catalog.=(text, name) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.timestamptz_ne_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp with time zone, timestamp) is 'not equal';

alter operator pg_catalog.<>(timestamp with time zone, timestamp) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.timestamp_ne_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp, timestamp with time zone) is 'not equal';

alter operator pg_catalog.<>(timestamp, timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.timestamptz_eq_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(timestamp with time zone, timestamp) is 'equal';

alter operator pg_catalog.=(timestamp with time zone, timestamp) owner to postgres;

create operator pg_catalog.= (procedure = pg_catalog.timestamp_eq_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(timestamp, timestamp with time zone) is 'equal';

alter operator pg_catalog.=(timestamp, timestamp with time zone) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.~<=~ (procedure = pg_catalog.bpchar_pattern_le, leftarg = char, rightarg = char, commutator = pg_catalog.~>=~, negator = pg_catalog.~>~, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.~<=~(char, char) is 'less than or equal';

alter operator pg_catalog.~<=~(char, char) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.~>=~ (procedure = pg_catalog.bpchar_pattern_ge, leftarg = char, rightarg = char, commutator = pg_catalog.~<=~, negator = pg_catalog.~<~, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.~>=~(char, char) is 'greater than or equal';

alter operator pg_catalog.~>=~(char, char) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.~<~ (procedure = pg_catalog.bpchar_pattern_lt, leftarg = char, rightarg = char, commutator = pg_catalog.~>~, negator = pg_catalog.~>=~, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.~<~(char, char) is 'less than';

alter operator pg_catalog.~<~(char, char) owner to postgres;

create operator pg_catalog.~>~ (procedure = pg_catalog.bpchar_pattern_gt, leftarg = char, rightarg = char, commutator = pg_catalog.~<~, negator = pg_catalog.~<=~, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.~>~(char, char) is 'greater than';

alter operator pg_catalog.~>~(char, char) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.~<=~ (procedure = pg_catalog.text_pattern_le, leftarg = text, rightarg = text, commutator = pg_catalog.~>=~, negator = pg_catalog.~>~, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.~<=~(text, text) is 'less than or equal';

alter operator pg_catalog.~<=~(text, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.~>=~ (procedure = pg_catalog.text_pattern_ge, leftarg = text, rightarg = text, commutator = pg_catalog.~<=~, negator = pg_catalog.~<~, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.~>=~(text, text) is 'greater than or equal';

alter operator pg_catalog.~>=~(text, text) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.~<~ (procedure = pg_catalog.text_pattern_lt, leftarg = text, rightarg = text, commutator = pg_catalog.~>~, negator = pg_catalog.~>=~, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.~<~(text, text) is 'less than';

alter operator pg_catalog.~<~(text, text) owner to postgres;

create operator pg_catalog.~>~ (procedure = pg_catalog.text_pattern_gt, leftarg = text, rightarg = text, commutator = pg_catalog.~<~, negator = pg_catalog.~<=~, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.~>~(text, text) is 'greater than';

alter operator pg_catalog.~>~(text, text) owner to postgres;

